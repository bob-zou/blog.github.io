<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>golang 中 slice 和 array 的区别</title>
    <url>/2021/02/01/golang-array-vs-slice/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><table>
<thead>
<tr>
<th>Array</th>
<th>Slice</th>
</tr>
</thead>
<tbody><tr>
<td>底层是一段连续的内存空间</td>
<td>底层是一个指向数组的指针(数组指针)</td>
</tr>
<tr>
<td>只有len属性, 且长度固定</td>
<td>有len和cap属性, 且不固定</td>
</tr>
<tr>
<td>Go数组是值类型, 赋值和函数传参操作都会复制整个数组数据</td>
<td>引用类型</td>
</tr>
</tbody></table>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="大数组传参"><a href="#大数组传参" class="headerlink" title="大数组传参"></a>大数组传参</h3><p>一个大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免上述问题。<br>切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率。</p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p><strong>测试代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">array</span><span class="params">()</span></span> [SIZE]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x [SIZE]<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">		x[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice</span><span class="params">()</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	x := <span class="built_in">make</span>([]<span class="type">int</span>, SIZE)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">		x[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkArray</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		array()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSlice</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		slice()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果：</strong></p>
<blockquote>
<p>各个字段含义: 核数(4)，循环次数，平均每次执行时间，每次执行堆上分配内存总量，分配次数</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=100</span><br><span class="line">BenchmarkArray-4         3633415               312 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4         2575620               499 ns/op             896 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=1000</span><br><span class="line">BenchmarkArray-4          437178              2835 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4          304779              3781 ns/op            8192 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=10000</span><br><span class="line">BenchmarkArray-4           38402             27179 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4           33938             36109 ns/op           81920 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=100000</span><br><span class="line">BenchmarkArray-4            3666            294832 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4            2868            358106 ns/op          802818 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=1000000</span><br><span class="line">BenchmarkArray-4             213           5484479 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkSlice-4             358           3994363 ns/op         8003590 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SIZE=10000000</span><br><span class="line">BenchmarkArray-4               7         170413247 ns/op        80003074 B/op          1 allocs/op</span><br><span class="line">BenchmarkSlice-4              42          27718152 ns/op        80003080 B/op          1 allocs/op</span><br></pre></td></tr></table></figure>
<p>这样对比看来，并非所有时候都适合用切片代替数组，因为切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗也未必比 make 消耗大。</p>
<h3 id="Array-修改拷贝的值不影响原来的数组"><a href="#Array-修改拷贝的值不影响原来的数组" class="headerlink" title="Array 修改拷贝的值不影响原来的数组"></a>Array 修改拷贝的值不影响原来的数组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">    b := a</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">    fmt.Println(a, b) <span class="comment">// [1 2 3 5 6] [10 2 3 5 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Slice-底层是数组指针-修改拷贝的值影响原来的切片"><a href="#Slice-底层是数组指针-修改拷贝的值影响原来的切片" class="headerlink" title="Slice 底层是数组指针, 修改拷贝的值影响原来的切片"></a>Slice 底层是数组指针, 修改拷贝的值影响原来的切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	b := a</span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">	fmt.Println(a, b) <span class="comment">// [10 2 3 5 6] [10 2 3 5 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在cap不足时-append会返回新的切片"><a href="#在cap不足时-append会返回新的切片" class="headerlink" title="在cap不足时, append会返回新的切片"></a>在cap不足时, append会返回新的切片</h3><blockquote>
<p>当原来切片的cap小于1024时, 新切片的cap为原来的 2 倍<br>当原来切片的cap大于等于1024时, 新切片的cap为原来的 1.25 倍</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	b := a</span><br><span class="line">	b = <span class="built_in">append</span>(b, <span class="number">7</span>)</span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">	fmt.Println(a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a)) <span class="comment">// [1 2 3 5 6] 5 5</span></span><br><span class="line">	fmt.Println(b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b)) <span class="comment">// [10 2 3 5 6 7] 6 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>array</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Golang 中 Channel</title>
    <url>/2021/11/26/golang-channel/</url>
    <content><![CDATA[<h2 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h2><p>目前我们喜欢go，使用go进行后端开发，其实主要go的并发性实在太好了，而channel作为goroutine之间通信的工具也是非常的简单，高效且有趣。</p>
<h2 id="什么是channel"><a href="#什么是channel" class="headerlink" title="什么是channel"></a>什么是channel</h2><ul>
<li>channel是并发安全的</li>
<li>用于存储在goroutine之间存储和传输数据</li>
<li>FIFO</li>
<li>可以阻塞和唤醒goroutine</li>
</ul>
<h2 id="channel的底层数据结构"><a href="#channel的底层数据结构" class="headerlink" title="channel的底层数据结构"></a>channel的底层数据结构</h2><p>我们先直接从<code>runtime/chan.go</code>中查看channel的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们来分析一下各个字段存在的意义:</p>
<ul>
<li>首先，我们定义channel的时候定义了channel的类型和长度，所以channel的结构里面必然会有一个表示元素类型和一段用于存储数据的内存<ul>
<li>也就是上面的 <code>elemtype *_type</code> 和 <code>buf unsafe.Pointer</code></li>
<li><code>dataqsiz uint</code> 记录的队列的长度，<code>elemsize uint16</code>记录的类型的长度，有了长度和类型的长度，就能知道buf的大小</li>
<li>channel主要有读和写两个操作，读和写是独立的，所以需要记录从哪里读，从哪里写，也就是这里的<code>sendx uint</code>和<code>recvx uint</code></li>
</ul>
</li>
<li>我们可以用<code>len</code>方法获取到channel中元素的数量，<code>qcount   uint</code>就记录了这个值</li>
<li>当我们关闭一个channel时，如果channel里面还有元素，我们依旧可以读取，那就要需要标记位标记channel是否关闭，也就是<code>closed uint32</code></li>
<li>channel需要被用于多协程之间通信，而channel本身优势并发安全的，所有channel中必要需要一个锁，也就是<code>lock mutex</code></li>
<li>我们在使用channel的时候进程会应该channel没有空间或者没有内容而阻塞读写的协程，之后这些被柱塞的携程还需要被唤醒，而这些被阻塞的协程就被放在了<code>recvq waitq</code>和<code>sendq waitq</code></li>
</ul>
<p>至此，channel的数据接口就介绍完了。</p>
<h2 id="channel工作流程图解"><a href="#channel工作流程图解" class="headerlink" title="channel工作流程图解"></a>channel工作流程图解</h2><blockquote>
<p>下面都省略了请求锁和释放锁的过程</p>
</blockquote>
<h3 id="1-我们先定义一个长度为8的channel"><a href="#1-我们先定义一个长度为8的channel" class="headerlink" title="1. 我们先定义一个长度为8的channel"></a>1. 我们先定义一个长度为8的channel</h3><p><img src="/1.png" alt="1"></p>
<h3 id="2-向channel中发送一个元素"><a href="#2-向channel中发送一个元素" class="headerlink" title="2. 向channel中发送一个元素"></a>2. 向channel中发送一个元素</h3><p><img src="/2.png" alt="2"></p>
<p>这时channel还是空的，发送的元素不会被阻塞</p>
<h3 id="3-不停的发送元素，直到channel被塞满"><a href="#3-不停的发送元素，直到channel被塞满" class="headerlink" title="3. 不停的发送元素，直到channel被塞满"></a>3. 不停的发送元素，直到channel被塞满</h3><p><img src="/3.png" alt="3"></p>
<h3 id="4-channel被塞满后，继续发送元素9"><a href="#4-channel被塞满后，继续发送元素9" class="headerlink" title="4. channel被塞满后，继续发送元素9"></a>4. channel被塞满后，继续发送元素9</h3><p><img src="/4.png" alt="4"><br>因为channel已经满了，所以元素9无法发送，发送的goroutine（就叫它G1吧）被阻塞，并放到了发送队列（类型为<code>waitq</code>，里面存放的是<code>sudog</code>）里<br>sudog结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	g *g  <span class="comment">// 被阻塞的goroutine</span></span><br><span class="line">	next *sudog</span><br><span class="line">	prev *sudog</span><br><span class="line">	elem unsafe.Pointer <span class="comment">// 要发送元素 9 存放的位置</span></span><br><span class="line">	acquiretime <span class="type">int64</span></span><br><span class="line">	releasetime <span class="type">int64</span></span><br><span class="line">	ticket      <span class="type">uint32</span></span><br><span class="line">	isSelect <span class="type">bool</span></span><br><span class="line">	success <span class="type">bool</span></span><br><span class="line">	parent   *sudog</span><br><span class="line">	waitlink *sudog</span><br><span class="line">	waittail *sudog</span><br><span class="line">	c        *hchan <span class="comment">// 这里就是我们定义的 ch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要调度有GMP调度模型完成，主要就是将自己存为sudog，扔进队列，使用gopark标记waitting状态，唤醒的时候调用goready标记runnable，之后再被GMP调度。</p>
<h3 id="5-从channel中读取一个元素"><a href="#5-从channel中读取一个元素" class="headerlink" title="5. 从channel中读取一个元素"></a>5. 从channel中读取一个元素</h3><p><img src="/5.png" alt="5"></p>
<h3 id="6-被读取一个元素后，队列就又有空间了，这是被阻塞的G1被唤醒，把-9-写入到队列中"><a href="#6-被读取一个元素后，队列就又有空间了，这是被阻塞的G1被唤醒，把-9-写入到队列中" class="headerlink" title="6. 被读取一个元素后，队列就又有空间了，这是被阻塞的G1被唤醒，把 9 写入到队列中"></a>6. 被读取一个元素后，队列就又有空间了，这是被阻塞的G1被唤醒，把 9 写入到队列中</h3><p><img src="/6.png" alt="6"></p>
<h3 id="7-之后我们读取完所有的元素"><a href="#7-之后我们读取完所有的元素" class="headerlink" title="7. 之后我们读取完所有的元素"></a>7. 之后我们读取完所有的元素</h3><p><img src="/7.png" alt="7"></p>
<h3 id="8-当channel中没有元素可以读了，读的goroutine就会被扔到recvq中"><a href="#8-当channel中没有元素可以读了，读的goroutine就会被扔到recvq中" class="headerlink" title="8. 当channel中没有元素可以读了，读的goroutine就会被扔到recvq中"></a>8. 当channel中没有元素可以读了，读的goroutine就会被扔到<code>recvq</code>中</h3><p><img src="/8.png" alt="8"></p>
<h2 id="为什么channel在函数间传递时都不用传递指针？"><a href="#为什么channel在函数间传递时都不用传递指针？" class="headerlink" title="为什么channel在函数间传递时都不用传递指针？"></a>为什么channel在函数间传递时都不用传递指针？</h2><p>应该make返回的ch就是一个指针了，channel实际的内存地址被分配到在堆中，我们获取到的是指想堆的地址。</p>
<h2 id="接受者先阻塞-和-发送者先阻塞-channel处理的逻辑一样吗？"><a href="#接受者先阻塞-和-发送者先阻塞-channel处理的逻辑一样吗？" class="headerlink" title="接受者先阻塞 和 发送者先阻塞 channel处理的逻辑一样吗？"></a>接受者先阻塞 和 发送者先阻塞 channel处理的逻辑一样吗？</h2><p>接受者先阻塞的时候，当发送者发送数据时，数据会被channel直接发送给接受者，剩下了将 数据拷贝到队列，再拷贝出来的时间，同时因为接受者已经拿到了数据，就不用在请求锁和释放锁。</p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>channel</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang三色标记、混合写屏障GC模式图文全分析</title>
    <url>/2021/01/28/golang-gc/</url>
    <content><![CDATA[<blockquote>
<p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。</p>
<p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了多次的迭代优化来解决这个问题。</p>
</blockquote>
<h2 id="内容提纲"><a href="#内容提纲" class="headerlink" title="内容提纲"></a>内容提纲</h2><ul>
<li>G0 V1.3之前的标记-清除(mark and sweep)算法</li>
<li>Go V1.3之前的标记-清扫(mark and sweep)的缺点</li>
<li>Go V1.5的三色并发标记法</li>
<li>Go V1.5的三色标记为什么需要STW</li>
<li>Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )</li>
<li>Go V1.8混合写屏障机制</li>
<li>Go V1.8混合写屏障机制的全场景分析</li>
</ul>
<h2 id="一、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#一、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="一、Go V1.3之前的标记-清除(mark and sweep)算法"></a>一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>此算法主要有两个主要的步骤：</p>
<ul>
<li>标记(Mark phase)</li>
<li>清除(Sweep phase)</li>
</ul>
<p><strong>第一步</strong> 暂停程序业务逻辑<br>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停，即<code>STW(stop the world)</code>。<br>也就是说，这段时间程序会卡在那儿。<br><img src="/mas-1.png" alt="setp-1"></p>
<p><strong>第二步</strong> 开始标记，程序找出它所有可达的对象，并做上标记<br><img src="/mas-2.png" alt="setp-2"></p>
<p><strong>第三步</strong> 标记完了之后，然后开始清除未标记的对象<br><img src="/mas-3.png" alt="setp-3"></p>
<p><strong>第四步</strong> 停止暂停，让程序继续跑。<br>然后循环重复这个过程，直到process程序生命周期结束。</p>
<h2 id="二、标记-清扫-mark-and-sweep-的缺点"><a href="#二、标记-清扫-mark-and-sweep-的缺点" class="headerlink" title="二、标记-清扫(mark and sweep)的缺点"></a>二、标记-清扫(mark and sweep)的缺点</h2><ul>
<li><code>STW(stop the world)</code> 让程序暂停，程序出现卡顿 (<code>重要问题</code>)。</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产生heap碎片</li>
</ul>
<p>Go V1.3版本之前就是以上来实施的, 流程是<br><img src="/mas-4.png" alt="before v1.3"></p>
<p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围<br><img src="/mas-5.png" alt="v1.3"></p>
<p><strong>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序</strong></p>
<p>Go是如何面对并这个问题的呢？接下来Go V1.5版本 就用<code>三色并发标记法</code>来优化这个问题.</p>
<h2 id="三、Go-V1-5的三色并发标记法"><a href="#三、Go-V1-5的三色并发标记法" class="headerlink" title="三、Go V1.5的三色并发标记法"></a>三、Go V1.5的三色并发标记法</h2><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.</p>
<p><strong>第一步</strong> 就是只要是新创建的对象, 默认的颜色都是标记为<code>白色</code>.<br><img src="/tri-color-1.png" alt="setp-1-1"><br>这里面需要注意的是, 所谓<code>程序</code>, 则是一些对象的根节点集合.<br>所以上图,可以转换如下的方式来表示.<br><img src="/tri-color-2.png" alt="setp-1-2"></p>
<p><strong>第二步</strong> 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从<code>白色</code>集合放入<code>灰色</code>集合。<br><img src="/tri-color-3.png" alt="setp-2-1"></p>
<p><strong>第三步</strong> 遍历<code>灰色</code>集合，将<code>灰色</code>对象引用的对象从<code>白色</code>集合放入<code>灰色</code>集合，之后将此<code>灰色</code>对象放入<code>黑色</code>集合<br><img src="/tri-color-4.png" alt="setp-3-1"></p>
<p><strong>第四步</strong> 重复第三步, 直到<code>灰色</code>中无任何对象.<br><img src="/tri-color-5.png" alt="setp-4-1"><br><img src="/tri-color-6.png" alt="setp-4-2"></p>
<p><strong>第五步</strong> 回收所有的<code>白色</code>标记表的对象. 也就是回收垃圾.<br><img src="/tri-color-7.png" alt="setp-5-1"></p>
<p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性, 那么又是如何实现<code>并行</code>的呢?<br>同时又是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p>
<h2 id="四、没有STW的三色标记法"><a href="#四、没有STW的三色标记法" class="headerlink" title="四、没有STW的三色标记法"></a>四、没有STW的三色标记法</h2><p>我们还是基于上述的<code>三色并发标记法</code>来说, 他是一定要依赖<code>STW</code>的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。</p>
<p>我们举一个场景, 如果<code>三色标记法</code>, 标记过程不使用<code>STW</code>将会发生什么事情?<br><img src="/tri-no-stw-1.png" alt="tri-no-stw"><br><img src="/tri-no-stw-2.png" alt="tri-no-stw"><br><img src="/tri-no-stw-3.png" alt="tri-no-stw"><br><img src="/tri-no-stw-4.png" alt="tri-no-stw"><br><img src="/tri-no-stw-5.png" alt="tri-no-stw"></p>
<p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的</p>
<ul>
<li>条件1: 一个<code>白色</code>对象被<code>黑色</code>对象引用(<strong><code>白色</code>被挂在<code>黑色</code>下</strong>)</li>
<li>条件2: <code>灰色</code>对象与它之间的可达关系的<code>白色</code>对象遭到破坏(<strong><code>灰色</code>同时丢了该<code>白色</code></strong>)<br>当以上两个条件同时满足时, 就会出现对象丢失现象!</li>
</ul>
<p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉!</p>
<p>为了防止这种现象的发生，最简单的方式就是<code>STW</code>，直接禁止掉其他用户程序对对象引用关系的干扰，<strong>但是<code>STW</code>的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少<code>STW</code>时间呢？</p>
<h2 id="五、屏障机制"><a href="#五、屏障机制" class="headerlink" title="五、屏障机制"></a>五、屏障机制</h2><p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失,所以引出两种方式.</p>
<h3 id="强-弱-三色不变式"><a href="#强-弱-三色不变式" class="headerlink" title="强-弱 三色不变式"></a>强-弱 三色不变式</h3><h4 id="强三色不变式-不存在黑色对象引用到白色对象的指针"><a href="#强三色不变式-不存在黑色对象引用到白色对象的指针" class="headerlink" title="强三色不变式 - 不存在黑色对象引用到白色对象的指针"></a>强三色不变式 - 不存在黑色对象引用到白色对象的指针</h4><p><img src="/sw-1.png" alt="sw-1"></p>
<h4 id="弱三色不变式-所有被黑色对象引用的白色对象都处于灰色保护状态"><a href="#弱三色不变式-所有被黑色对象引用的白色对象都处于灰色保护状态" class="headerlink" title="弱三色不变式 - 所有被黑色对象引用的白色对象都处于灰色保护状态"></a>弱三色不变式 - 所有被黑色对象引用的白色对象都处于灰色保护状态</h4><p><img src="/sw-2.png" alt="sw-2"></p>
<p>为了遵循上述的两个方式,Golang团队初步得到了两种屏障方式<code>插入屏障</code>和<code>删除屏障</code></p>
<h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p><strong>具体操作</strong>: 在<code>A对象</code>引用<code>B对象</code>的时候，<code>B对象</code>被标记为灰色。(将B挂在A下游，B必须被标记为<code>灰色</code>)<br><strong>满足</strong>: <strong>强三色不变式</strong>. (不存在<code>黑色</code>对象引用<code>白色</code>对象的情况了， 因为<code>白色</code>会强制变成<code>灰色</code>)</p>
<p>伪码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;   </span><br><span class="line">  //1</span><br><span class="line">  标记灰色(新下游对象ptr)   </span><br><span class="line">  </span><br><span class="line">  //2</span><br><span class="line">  当前下游对象slot = 新下游对象ptr                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span><br><span class="line">A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色</span><br></pre></td></tr></table></figure>

<p>这段伪码逻辑就是写屏障.<br>我们知道,<code>黑色</code>对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>.<br><code>栈</code>空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用,所以<code>插入屏障</code>机制,在<code>栈</code>空间的对象操作中不使用.<br>而仅仅使用在<code>堆</code>空间对象的操作中.</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。<br><img src="/sw-3.png" alt="sw-3"><br><img src="/sw-4.png" alt="sw-4"><br><img src="/sw-5.png" alt="sw-5"><br><img src="/sw-6.png" alt="sw-6"><br><img src="/sw-7.png" alt="sw-7"><br><img src="/sw-8.png" alt="sw-8"><br>但是如果<code>栈</code>不添加,当全部三色标记扫描之后,<code>栈</code>上有可能依然存在<code>白色</code>对象被引用的情况(如上图的<code>对象9</code>).<br>所以要对<code>栈</code>重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动<code>STW</code>暂停.<br>直到栈空间的三色标记结束.<br><img src="/sw-9.png" alt="sw-9"><br><img src="/sw-10.png" alt="sw-10"><br><img src="/sw-11.png" alt="sw-11"><br>最后将<code>栈</code>和<code>堆</code>空间扫描剩余的全部<code>白色</code>节点清除. 这次<code>STW</code>大约的时间在<code>10~100ms</code>间.<br><img src="/sw-12.png" alt="sw-12"></p>
<h3 id="删除屏蔽"><a href="#删除屏蔽" class="headerlink" title="删除屏蔽"></a>删除屏蔽</h3><p><strong>具体操作</strong>: 被删除的对象，如果自身为<code>灰色</code>或者<code>白色</code>，那么被标记为<code>灰色</code>。<br><strong>满足</strong>: <strong>弱三色不变式</strong>. (保护<code>灰色</code>对象到<code>白色</code>对象的路径不会断)</p>
<p>伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;</span><br><span class="line">  //1</span><br><span class="line">  if (当前对象是灰色 || 当前对象是白色) &#123;</span><br><span class="line">      标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //2</span><br><span class="line">  当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(B, nil)   //A对象，删除B对象的引用  B被A删除，被标记为灰(如果A为灰度或者A为白色)</span><br><span class="line">A.添加下游对象(B, C)     //A对象，更换下游B变成C   B被A删除，被标记为灰(如果A为灰度或者A为白色)</span><br></pre></td></tr></table></figure>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。<br><img src="/sw-13.png" alt="sw-13"><br><img src="/sw-14.png" alt="sw-14"><br><img src="/sw-15.png" alt="sw-15"><br><img src="/sw-16.png" alt="sw-16"><br><img src="/sw-17.png" alt="sw-17"><br><img src="/sw-18.png" alt="sw-18"><br><img src="/sw-19.png" alt="sw-19"></p>
<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<h2 id="六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制"><a href="#六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="六、Go V1.8的混合写屏障(hybrid write barrier)机制"></a>六、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li>插入写屏障：结束时需要<code>STW</code>来重新扫描栈，标记栈上引用的<code>白色</code>对象的存活；</li>
<li>删除写屏障：回收精度低，GC开始时<code>STW</code>扫描<code>堆栈</code>来记录初始快照，这个过程会保护开始时刻的所有存活对象。<br>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了<code>STW</code>的时间。结合了两者的优点。</li>
</ul>
<h3 id="混合写屏障规则"><a href="#混合写屏障规则" class="headerlink" title="混合写屏障规则"></a>混合写屏障规则</h3><p><strong>具体操作</strong>:</p>
<ul>
<li>GC开始将<code>栈</code>上的对象全部扫描并标记为<code>黑色</code>(之后不再进行第二次重复扫描，无需<code>STW</code>)，</li>
<li>GC期间，任何在栈上创建的新对象，均为<code>黑色</code>。</li>
<li>被删除的对象标记为<code>灰色</code>。</li>
<li>被添加的对象标记为<code>灰色</code>。</li>
</ul>
<p><strong>满足</strong>: <strong>变形的弱三色不变式</strong></p>
<p><strong>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率</strong></p>
<p>伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">    //1 </span><br><span class="line">    标记灰色(当前下游对象slot)    //只要当前下游对象被移走，就标记灰色</span><br><span class="line">      </span><br><span class="line">    //2 </span><br><span class="line">    标记灰色(新下游对象ptr)</span><br><span class="line">          </span><br><span class="line">    //3</span><br><span class="line">    当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合写屏障的具体场景分析"><a href="#混合写屏障的具体场景分析" class="headerlink" title="混合写屏障的具体场景分析"></a>混合写屏障的具体场景分析</h3><p>注意<code>混合写屏障</code>是<code>GC</code>的一种屏障机制，所以只是当程序执行<code>GC</code>的时候，才会触发这种机制。<br>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><strong>GC开始：扫描栈区，将可达对象全部标记为黑</strong><br><img src="/hwb-1.png" alt="hwb-1"><br><img src="/hwb-2.png" alt="hwb-2"></p>
<p><strong>场景一</strong><br>对象被一个<code>堆</code>对象删除引用，成为<code>栈</code>对象的下游<br>伪代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用</span><br><span class="line">栈对象1-&gt;对象7 = 堆对象7；  //将堆对象7 挂在 栈对象1 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；    //对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>
<p><img src="/hwb-3.png" alt="hwb-3"><br><img src="/hwb-4.png" alt="hwb-4"></p>
<p><strong>场景二</strong><br>对象被一个<code>栈</code>对象删除引用，成为另一个<code>栈</code>对象的下游<br>伪代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new 栈对象9；</span><br><span class="line">对象8-&gt;对象3 = 对象3；      //将栈对象3 挂在 栈对象9 下游</span><br><span class="line">对象2-&gt;对象3 = null；      //对象2 删除引用 对象3</span><br></pre></td></tr></table></figure>
<p><img src="/hwb-5.png" alt="hwb-5"><br><img src="/hwb-6.png" alt="hwb-6"><br><img src="/hwb-7.png" alt="hwb-7"></p>
<p><strong>场景三</strong><br>对象被一个<code>堆</code>对象删除引用，成为另一个<code>堆</code>对象的下游<br>伪代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；         //对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>
<p><img src="/hwb-8.png" alt="hwb-8"><br><img src="/hwb-9.png" alt="hwb-9"><br><img src="/hwb-10.png" alt="hwb-10"></p>
<p><strong>场景四</strong><br>对象从一个<code>栈</code>对象删除引用，成为另一个<code>堆</code>对象的下游<br>伪代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7；       //将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；         //对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>
<p><img src="/hwb-11.png" alt="hwb-11"><br><img src="/hwb-12.png" alt="hwb-12"><br><img src="/hwb-13.png" alt="hwb-13"></p>
<p>Golang中的<code>混合写屏障</code>满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的<code>栈</code>，使其变<code>黑</code>并一直保持，这个过程不需要<code>STW</code>，而标记结束后，因为<code>栈</code>在扫描后始终是<code>黑色</code>的，也无需再进行re-scan操作了，减少了<code>STW</code>的时间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p>
<p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。<br>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通<br>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<p>参考文献:</p>
<ul>
<li><a href="https://www.cnblogs.com/wangyiyang/p/12191591.html">https://www.cnblogs.com/wangyiyang/p/12191591.html</a></li>
<li><a href="https://www.jianshu.com/p/eb6b3aff9ca5">https://www.jianshu.com/p/eb6b3aff9ca5</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/74853110">https://zhuanlan.zhihu.com/p/74853110</a></li>
</ul>
<h2 id="相关好博客推荐"><a href="#相关好博客推荐" class="headerlink" title="相关好博客推荐"></a>相关好博客推荐</h2><ul>
<li><a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">Garbage Collection In Go : Part I - Semantics</a></li>
<li><a href="https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html">Garbage Collection In Go : Part II - GC Traces</a></li>
<li><a href="https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html">Garbage Collection In Go : Part III - GC Pacing</a></li>
</ul>
<p><strong>原文作者:</strong> <a href="https://segmentfault.com/u/aceld">刘丹冰 Aceld</a><br><strong>原文地址:</strong> <a href="https://segmentfault.com/a/1190000022030353">Golang三色标记、混合写屏障GC模式图文全分析</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>gc</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>gin vs net/http</title>
    <url>/2021/02/23/golang-gin-vs-http/</url>
    <content><![CDATA[<h2 id="gin-优点"><a href="#gin-优点" class="headerlink" title="gin 优点"></a>gin 优点</h2><ul>
<li>轻量框架，提供web服务的常用工具函数(如panic捕获，json格式校验等等)。开发者可以以少量代码，轻松构建web服务。</li>
<li>以中间件抽象通用逻辑（如鉴权，检验入参，日志审计等逻辑），供一个或一组URL使用，提高代码复用率。</li>
<li>基于上述的中间件特性，代码具有很强的可扩展性。</li>
<li>支持常见的render模板(json, xml, html, yaml, string), 满足轻松动态资源，后端api服务等多种业务场景。</li>
<li>更高的路由匹配效率。 </li>
<li>使用context池，减少runtime的GC工作量。</li>
</ul>
<h2 id="net-x2F-http-和-gin-的关系"><a href="#net-x2F-http-和-gin-的关系" class="headerlink" title="net&#x2F;http 和 gin 的关系"></a>net&#x2F;http 和 gin 的关系</h2><ul>
<li>gin更像是一个功能强大的路由器，提供更便捷的web服务解决方案，而其余功能则复用net&#x2F;http。</li>
<li>网络层实现，http parser 都是由 net&#x2F;http 实现的。<br><img src="/gin-1.png" alt="gin-1"></li>
</ul>
<h2 id="强大的工具包-gin-Context"><a href="#强大的工具包-gin-Context" class="headerlink" title="强大的工具包: gin.Context"></a>强大的工具包: gin.Context</h2><h3 id="gin-Context-的功能"><a href="#gin-Context-的功能" class="headerlink" title="gin.Context 的功能"></a>gin.Context 的功能</h3><p>在日常的web服务开发中，我们总会频繁地使用以下功能：</p>
<ul>
<li>获取query参数</li>
<li>读取POST或PUT的请求体</li>
<li>请求体的反序列化以及响应体的序列化</li>
<li>读写 HTTP Header</li>
<li>读写 cookie<br>而gin.Context, 作为一个web框架通用函数工具包，涵盖了上述的功能。<br>此前，笔者没有阅读源码之前，一直以为gin.Context实现了context.Context的Deadline函数，可以用来做一些熔断相关的功能，<br>但其实并没有，类似的功能还是要依赖 net&#x2F;http 的 Request.Context()来实现。</li>
</ul>
<h3 id="gin-Context-的优势"><a href="#gin-Context-的优势" class="headerlink" title="gin.Context 的优势"></a>gin.Context 的优势</h3><h2 id="效率更高的路由器：Radix-Tree"><a href="#效率更高的路由器：Radix-Tree" class="headerlink" title="效率更高的路由器：Radix Tree"></a>效率更高的路由器：Radix Tree</h2><h3 id="net-x2F-http-路由器的实现"><a href="#net-x2F-http-路由器的实现" class="headerlink" title="net&#x2F;http 路由器的实现"></a>net&#x2F;http 路由器的实现</h3><h3 id="gin-路由器的实现-radix-tree"><a href="#gin-路由器的实现-radix-tree" class="headerlink" title="gin 路由器的实现: radix tree"></a>gin 路由器的实现: radix tree</h3><h3 id="两种路由器实现的效率差异"><a href="#两种路由器实现的效率差异" class="headerlink" title="两种路由器实现的效率差异"></a>两种路由器实现的效率差异</h3><h2 id="更优雅的抽象：中间件"><a href="#更优雅的抽象：中间件" class="headerlink" title="更优雅的抽象：中间件"></a>更优雅的抽象：中间件</h2>]]></content>
      <tags>
        <tag>golang</tag>
        <tag>面试题</tag>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang调度器GMP原理与调度全分析</title>
    <url>/2021/01/29/golang-gmp/</url>
    <content><![CDATA[<blockquote>
<p>该文章主要详细具体的介绍Goroutine调度器过程及原理，可以对Go调度器的详细调度过程有一个清晰的理解。</p>
</blockquote>
<h2 id="内容提纲"><a href="#内容提纲" class="headerlink" title="内容提纲"></a>内容提纲</h2><ul>
<li>Golang调度器的由来</li>
<li>Goroutine调度器的GMP模型及设计思想</li>
<li>Goroutine调度场景过程全图文解析</li>
</ul>
<h2 id="一、Golang调度器的由来？"><a href="#一、Golang调度器的由来？" class="headerlink" title="一、Golang调度器的由来？"></a>一、Golang调度器的由来？</h2><h3 id="单进程时代不需要调度器"><a href="#单进程时代不需要调度器" class="headerlink" title="单进程时代不需要调度器"></a>单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。<br>早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是<code>单进程时代</code>, 一切的程序只能串行发生。<br><img src="/sproc-1.png" alt="sproc-1"></p>
<p>早期的单进程操作系统，面临2个问题：</p>
<ul>
<li>单一的执行流程，计算机只能一个任务一个任务的处理</li>
<li>进程阻塞所带来的CPU时间浪费<br>那么能不能有多个进程来宏观一起来执行多个任务呢？<br>后来操作系统就具有了最早的并发能力： <strong>多进程并发</strong><br>当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</li>
</ul>
<h3 id="多进程-x2F-线程时代有了调度器需求"><a href="#多进程-x2F-线程时代有了调度器需求" class="headerlink" title="多进程&#x2F;线程时代有了调度器需求"></a>多进程&#x2F;线程时代有了调度器需求</h3><p><img src="/mproc-1.png" alt="mproc-1"><br>在多进程&#x2F;多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞CPU可以立刻切换到其他进程中去执行，而且调度CPU的算法可以保证在运行的进程都可以被分配到CPU的运行时间片。<br>这样从宏观来看，似乎多个进程是在同时被运行。<br>但新的问题就又出现了，进程拥有太多的资源，进程的<strong>创建</strong>、<strong>切换</strong>、<strong>销毁</strong>，都会占用很长的时间。<br>CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p>
<p><strong>怎么才能提高CPU的利用率呢？</strong><br><img src="/mproc-2.png" alt="mproc-2"><br>很明显，CPU调度切换的是进程和线程。<br>尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p>
<h3 id="协程来提高CPU利用率"><a href="#协程来提高CPU利用率" class="headerlink" title="协程来提高CPU利用率"></a>协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力。<br>但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(<a href="https://blog.zouyapeng.com/2021/01/31/linux-process-vm/">进程虚拟内存</a> 会占用<strong>4GB</strong>[32位操作系统], 而线程也要大约<strong>4MB</strong>)。<br>大量的进程&#x2F;线程出现了新的问题：</p>
<ul>
<li>高内存占用</li>
<li>调度的高消耗CPU<br>之后，攻城狮们就发现，其实一个线程分为<code>内核态线程</code>和<code>用户态线程</code>。<br>一个<code>用户态线程</code>必须要绑定一个<code>内核态线程</code></li>
</ul>
<p>但是CPU并不知道有<code>用户态线程</code>的存在，它只知道它运行的是一个<code>内核态线程</code>(Linux的PCB进程控制块)。<br><img src="/co-routine-1.png" alt="co-routine-1"><br>这样，我们再去细化去分类一下，内核线程依然叫<code>线程(thread)</code>，用户线程叫<code>协程(co-routine)</code>.<br><img src="/co-routine-2.png" alt="co-routine-2"><br>看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。<br>之后，我们就看到了有3种协程和线程的映射关系</p>
<h4 id="N-1-关系-N个协程绑定1个线程"><a href="#N-1-关系-N个协程绑定1个线程" class="headerlink" title="N:1 关系(N个协程绑定1个线程)"></a>N:1 关系(N个协程绑定1个线程)</h4><p>优点:</p>
<ul>
<li>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。<br>缺点：</li>
<li>一个进程的所有协程都绑定在一个线程上。</li>
<li>某个程序用不了硬件的多核加速能力。</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。<br><img src="/co-routine-3.png" alt="co-routine-3"></li>
</ul>
<h4 id="1-1-关系-1个协程绑定1个线程"><a href="#1-1-关系-1个协程绑定1个线程" class="headerlink" title="1:1 关系(1个协程绑定1个线程)"></a>1:1 关系(1个协程绑定1个线程)</h4><p>优点: 简单易于实现<br>缺点: </p>
<ul>
<li>协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。<br><img src="/co-routine-4.png" alt="co-routine-4"></li>
</ul>
<h4 id="M-N关系-M个协程绑定1个线程-是N-1和1-1类型的结合-但是难以实现"><a href="#M-N关系-M个协程绑定1个线程-是N-1和1-1类型的结合-但是难以实现" class="headerlink" title="M:N关系(M个协程绑定1个线程, 是N:1和1:1类型的结合, 但是难以实现)"></a>M:N关系(M个协程绑定1个线程, 是N:1和1:1类型的结合, 但是难以实现)</h4><p><img src="/co-routine-5.png" alt="co-routine-5"><br>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p>
<h3 id="Go语言的协程-goroutine"><a href="#Go语言的协程-goroutine" class="headerlink" title="Go语言的协程(goroutine)"></a>Go语言的协程(goroutine)</h3><p>Go为了提供更容易使用的并发方法，使用了<code>goroutine</code>和<code>channel</code>。<br>goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。<br>最关键的是，<strong>程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发</strong>。<br>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。<br>虽然一个goroutine的栈只占几KB，但实际是<strong>可伸缩的</strong>，如果需要更多内容，<code>runtime</code>会自动为goroutine分配。<br>Goroutine特点：</p>
<ul>
<li>占用内存更小（几kb）</li>
<li>调度更灵活(<code>runtime</code>调度)</li>
</ul>
<h3 id="被废弃的goroutine调度器"><a href="#被废弃的goroutine调度器" class="headerlink" title="被废弃的goroutine调度器"></a>被废弃的goroutine调度器</h3><p>既然我们知道了<code>协程</code>和<code>线程</code>的关系，那么最关键的一点就是调度协程的调度器的实现了。<br>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了。<br>那么我们先来分析一下被废弃的调度器是如何运作的？</p>
<p>大部分文章都是会用<code>G</code>来表示Goroutine，用<code>M</code>来表示线程(OS Thread)，那么我们也会用这种表达的对应关系。<br><img src="/go-schd-old-1.png" alt="go-schd-old-1"><br>下面我们来看看被废弃的golang调度器是如何实现的<br><img src="/go-schd-old-2.png" alt="go-schd-old-2"><br><code>M</code>想要执行、放回<code>G</code>都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局<code>G</code>队列是有互斥锁进行保护的。<br>老调度器有几个缺点：</p>
<ul>
<li>创建、销毁、调度<code>G</code>都需要每个<code>M</code>获取锁，这就形成了激烈的锁竞争。</li>
<li><code>M</code>转移<code>G</code>会造成延迟和额外的系统负载。比如当<code>G</code>中包含创建新协程的时候，<code>M</code>创建了<code>G2</code>，为了继续执行<code>G</code>，需要把<code>G2</code>交给<code>M2</code>执行，也造成了很差的局部性，因为<code>G2</code>和<code>G</code>是相关的，最好放在<code>M</code>上执行，而不是<code>M2</code>上。</li>
<li>系统调用(CPU在<code>M</code>之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ul>
<h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。<br>在新调度器中，出列M(thread)和G(goroutine)，又引入了P(Processor)。<br><img src="/go-schd-1.png" alt="go-schd-1.png"><br><strong>Processor包含了运行goroutine的资源</strong>，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p>
<h3 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h3><p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。<br><img src="/go-schd-2.png" alt="go-schd-2.png"><br><strong>全局队列（Global Queue）</strong>：存放等待运行的G。<br><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过<strong>256</strong>个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。<br><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。<br><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。<br>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。</p>
<p><strong>P和M的个数问题</strong></p>
<ul>
<li>P的数量<ul>
<li>由启动时环境变量<code>GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>GOMAXPROCS</code>个goroutine在同时运行。</li>
</ul>
</li>
<li>M的数量<ul>
<li>go语言本身的限制：go程序启动时，会设置M的最大数量，默认<strong>10000</strong>。但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li><code>runtime/debug</code>中的<code>SetMaxThreads</code>函数，设置<code>M</code>的最大数量</li>
<li>一个<code>M</code>阻塞了，会创建新的<code>M</code><br><code>M</code>与<code>P</code>的数量没有绝对关系，一个<code>M</code>阻塞，<code>P</code>就会去创建或者切换另一个<code>M</code>，所以，即使<code>P</code>的默认数量是<strong>1</strong>，也有可能会创建很多个<code>M</code>出来。</li>
</ul>
</li>
</ul>
<p><strong>P和M何时会被创建</strong></p>
<ul>
<li><strong>P</strong>，在确定了<code>P</code>的最大数量n后，运行时系统会根据这个数量创建n个<code>P</code>。</li>
<li><strong>M</strong>，没有足够的<code>M</code>来关联<code>P</code>并运行其中的可运行的<code>G</code>。比如所有的<code>M</code>此时都阻塞住了，而<code>P</code>中还有很多就绪任务，就会去寻找空闲的<code>M</code>，而没有空闲的，就会去创建新的<code>M</code>。</li>
</ul>
<h3 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h3><ul>
<li><strong>复用线程</strong>(避免频繁的创建、销毁线程，而是对线程的复用)<ul>
<li><strong>work stealing机制</strong>，当本线程无可运行的<code>G</code>时，尝试从其他线程绑定的<code>P</code>偷取<code>G</code>，而不是销毁线程。</li>
<li><strong>hand off机制</strong>，当本线程因为<code>G</code>进行系统调用阻塞时，线程释放绑定的<code>P</code>，把<code>P</code>转移给其他空闲的线程执行。</li>
</ul>
</li>
<li><strong>利用并行</strong><ul>
<li><code>GOMAXPROCS</code>设置<code>P</code>的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。</li>
<li><code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS</code> &#x3D; 核数&#x2F;2，则最多利用了一半的CPU核进行并行。</li>
</ul>
</li>
<li><strong>抢占</strong><ul>
<li>在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</li>
</ul>
</li>
<li><strong>全局G队列</strong><ul>
<li>在新的调度器中依然有全局<code>G</code>队列，但功能已经被弱化了，当<code>M</code>执行work stealing从其他<code>P</code>偷不到<code>G</code>时，它可以从全局<code>G</code>队列获取<code>G</code>。</li>
</ul>
</li>
</ul>
<h3 id="go-func-调度流程"><a href="#go-func-调度流程" class="headerlink" title="go func() 调度流程"></a>go func() 调度流程</h3><p><img src="/go-schd-3.png" alt="go-schd-3.png"><br>从上图我们可以分析出几个结论：</p>
<ol>
<li>我们通过 <code>go func()</code>来创建一个goroutine；</li>
<li>有两个存储<code>G</code>的队列，一个是局部调度器<code>P</code>的本地队列、一个是全局<code>G</code>队列。新创建的<code>G</code>会先保存在<code>P</code>的本地队列中，如果<code>P</code>的本地队列已经满了就会保存在全局的队列中；</li>
<li><code>G</code>只能运行在<code>M</code>中，一个<code>M</code>必须持有一个<code>P</code>，<code>M</code>与<code>P</code>是1：1的关系。<code>M</code>会从<code>P</code>的本地队列弹出一个可执行状态的<code>G</code>来执行，如果<code>P</code>的本地队列为空，就会想其他的<code>MP</code>组合偷取一个可执行的<code>G</code>来执行； </li>
<li>一个<code>M</code>调度<code>G</code>执行的过程是一个循环机制；</li>
<li>当<code>M</code>执行某一个<code>G</code>时候如果发生了<code>syscall</code>或则其余阻塞操作，<code>M</code>会阻塞，如果当前有一些<code>G</code>在执行，<code>runtime</code>会把这个线程<code>M</code>从<code>P</code>中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个<code>P</code>； </li>
<li>当<code>M</code>系统调用结束时候，这个<code>G</code>会尝试获取一个空闲的<code>P</code>执行，并放入到这个<code>P</code>的本地队列。如果获取不到<code>P</code>，那么这个线程<code>M</code>变成休眠状态， 加入到空闲线程中，然后这个<code>G</code>会被放入全局队列中。</li>
</ol>
<h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><p><img src="/go-schd-4.png" alt="go-schd-4.png"><br><strong>M0</strong><br><code>M0</code>是启动程序后的编号为0的主线程，这个<code>M</code>对应的实例会在全局变量<code>runtime.m0</code>中，不需要在heap上分配，<code>M0</code>负责执行初始化操作和启动第一个<code>G</code>， 在之后<code>M0</code>就和其他的<code>M</code>一样了。<br><strong>G0</strong><br><code>G0</code>是每次启动一个<code>M</code>都会第一个创建的gourtine，<code>G0</code>仅用于负责调度的<code>G</code>，<code>G0</code>不指向任何可执行的函数, 每个<code>M</code>都会有一个自己的<code>G0</code>。在调度或系统调用时会使用<code>G0</code>的栈空间, 全局变量的<code>G0</code>是<code>M0</code>的<code>G0</code>。</p>
<p>我们来跟踪一段代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们来针对上面的代码对调度器里面的结构做一个分析, 也会经历如上图所示的过程：</p>
<ol>
<li><code>runtime</code>创建最初的线程<code>M0</code>和<code>G0</code>，并把两者关联。</li>
<li>调度器初始化：初始化<code>M0</code>、栈、垃圾回收，以及创建和初始化由<code>GOMAXPROCS</code>个<code>P</code>构成的<code>P</code>列表。</li>
<li>示例代码中的<code>main</code>函数是<code>main.main</code>，<code>runtime</code>中也有个<code>main</code>函数(<code>runtime.main</code>)，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建goroutine，称它为main goroutine吧，然后把main goroutine加入到<code>P</code>的本地队列。</li>
<li>启动<code>M0</code>，<code>M0</code>已经绑定了<code>P</code>，会从<code>P</code>的本地队列获取<code>G</code>，获取到main goroutine。</li>
<li><code>G</code>拥有栈，<code>M</code>根据<code>G</code>中的栈信息和调度信息设置运行环境</li>
<li><code>M</code>运行<code>G</code></li>
<li><code>G</code>退出，再次回到<code>M</code>获取可运行的<code>G</code>，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行Defer和Panic处理，或调用<code>runtime.exit</code>退出程序。<br>调度器的生命周期几乎占满了一个GO程序的一生，<code>runtime.main</code>的goroutine执行之前都是为调度器做准备工作，<code>runtime.main</code>的goroutine运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</li>
</ol>
<h3 id="可视化GMP编程"><a href="#可视化GMP编程" class="headerlink" title="可视化GMP编程"></a>可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据</p>
<h4 id="方式1：go-tool-trace"><a href="#方式1：go-tool-trace" class="headerlink" title="方式1：go tool trace"></a>方式1：go tool trace</h4><p>trace记录了运行时的信息，能提供可视化的Web页面。<br>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run trace.go </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>会得到一个trace.out文件，然后我们可以用一个工具打开，来分析这个文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go tool trace trace.out </span><br><span class="line">2020/02/23 10:44:11 Parsing trace...</span><br><span class="line">2020/02/23 10:44:11 Splitting trace...</span><br><span class="line">2020/02/23 10:44:11 Opening browser. Trace viewer is listening on http://127.0.0.1:33479</span><br></pre></td></tr></table></figure>
<p>我们可以通过浏览器打开<a href="http://127.0.0.1:33479网址，点击view">http://127.0.0.1:33479网址，点击view</a> trace 能够看见可视化的调度流程。<br><img src="/trace-1.png" alt="trace-1"><br><img src="/trace-2.png" alt="trace-2"></p>
<p><strong>G信息</strong>：点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。<br><img src="/trace-3.png" alt="trace-3"><br><em>一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论</em><br>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p>
<p><strong>M信息</strong>：点击Threads那一行可视化的数据条，我们会看到一些详细的信息。<br><img src="/trace-4.png" alt="trace-4"><br><em>一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论</em><br><img src="/trace-5.png" alt="trace-5"><br>G1中调用了main.main，创建了trace goroutine G18。G1运行在P1上，G18运行在P0上。<br>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。<br>我们在来看看上面的M信息。<br><img src="/trace-6.png" alt="trace-6"><br>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：<br><img src="/trace-7.png" alt="trace-7"><br>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p>
<h4 id="方式2：Debug-trace"><a href="#方式2：Debug-trace" class="headerlink" title="方式2：Debug trace"></a>方式2：Debug trace</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build trace2.go</span><br></pre></td></tr></table></figure>
<p>通过Debug方式运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=1000 ./trace2 </span><br><span class="line">SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p><code>SCHED</code>：调试信息输出标志字符串，代表本行是goroutine调度器的输出；<br><code>0ms</code>：即从程序启动到输出这行日志的时间；<br><code>gomaxprocs</code>: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；<br><code>idleprocs</code>: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；<br><code>threads</code>: os threads&#x2F;M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；<br><code>spinningthreads</code>: 处于自旋状态的os thread数量；<br><code>idlethread</code>: 处于idle状态的os thread的数量；<br><code>runqueue=0</code>： Scheduler全局队列中G的数量；<br><code>[0 0]</code>: 分别为2个P的local queue中的G的数量。</p>
<h2 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a>三、Go调度器调度场景过程全解析</h2><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><p>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P1的本地队列。<br><img src="/scene-1.png" alt="scene-1"></p>
<h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><p>G1运行完成后(函数：<code>goexit</code>)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：<code>schedule</code>）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：<code>execute</code>)。实现了线程M1的复用。<br><img src="/scene-2.png" alt="scene-2"></p>
<h3 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h3><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入P1的本地队列，P1本地队列满了。<br><img src="/scene-3.png" alt="scene-3"></p>
<h3 id="场景4"><a href="#场景4" class="headerlink" title="场景4"></a>场景4</h3><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建G转移到全局队列)<br><em>实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列</em><br><img src="/scene-4.png" alt="scene-4"><br>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。</p>
<h3 id="场景5"><a href="#场景5" class="headerlink" title="场景5"></a>场景5</h3><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。<br><img src="/scene-5.png" alt="scene-5"><br>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</p>
<h3 id="场景6"><a href="#场景6" class="headerlink" title="场景6"></a>场景6</h3><p>规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。<br><img src="/scene-6.png" alt="scene-6"><br>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程（没有G但为运行状态的线程，不断寻找G）。</p>
<h3 id="场景7"><a href="#场景7" class="headerlink" title="场景7"></a>场景7</h3><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。<br>M2从全局队列取的G数量符合下面的公式：<code>n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))</code><br>至少从全局队列取1个G，但每次不要从全局队列移动太多的G到P本地队列，给其他P留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。<br><img src="/scene-7.png" alt="scene-7"><br>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。</p>
<h3 id="场景8"><a href="#场景8" class="headerlink" title="场景8"></a>场景8</h3><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。<br><img src="/scene-8.png" alt="scene-8"><br>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p>
<h3 id="场景9"><a href="#场景9" class="headerlink" title="场景9"></a>场景9</h3><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。<br><img src="/scene-9.png" alt="scene-9"><br>为什么要让M3和M4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU。<br>为什么不销毁现场，来节约CPU资源。<br>因为创建和销毁CPU也会浪费时间，我们希望当有新goroutine创建时，立刻能有M运行它，如果销毁再新建就增加了时延，降低了效率。<br>当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有<code>GOMAXPROCS</code>个自旋的线程(当前例子中的<code>GOMAXPROCS</code>&#x3D;4，所以一共4个P)，多余的没事做线程会让他们休眠。</p>
<h3 id="场景10"><a href="#场景10" class="headerlink" title="场景10"></a>场景10</h3><p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;&#x3D;P, 大部分都是M在抢占需要运行的P)，<br>G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，<br>P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。<br>本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。<br><img src="/scene-10.png" alt="scene-10"></p>
<h3 id="场景11"><a href="#场景11" class="headerlink" title="场景11"></a>场景11</h3><p>G8创建了G9，假如G8进行了非阻塞系统调用。<br><img src="/scene-11.png" alt="scene-11"><br>M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。<br>当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，<br>如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。<br><strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发</strong>。</p>
<h2 id="相关好博客推荐"><a href="#相关好博客推荐" class="headerlink" title="相关好博客推荐"></a>相关好博客推荐</h2><ul>
<li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">Scheduling In Go: Part I - OS Scheduler</a></li>
<li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Scheduling In Go : Part II - Go Scheduler</a></li>
<li><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">Scheduling In Go : Part III - Concurrency</a></li>
</ul>
<p><strong>原文作者:</strong> <a href="https://segmentfault.com/u/aceld">刘丹冰 Aceld</a><br><strong>原文地址:</strong> <a href="https://segmentfault.com/a/1190000021951119">Golang三色标记、混合写屏障GC模式图文全分析</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>面试题</tag>
        <tag>goroutine</tag>
        <tag>gmp</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解析 Go 中 Slice 底层实现</title>
    <url>/2021/02/03/golang-slice/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>切片本身并不是动态数组或者数组指针。<br>它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。<br><strong>切片本身是一个只读对象，其工作机制类似数组指针的一种封装</strong>。</p>
<p>切片是对数组一个连续片段的引用，所以切片是一个引用类型。<br>这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。<br>需要注意的是，终止索引标识的项不包括在切片内。<br>切片提供了一个与指向数组的动态窗口。</p>
<p>给定项的切片索引可能比相关数组的相同元素的索引小。<br>切片的长度可以在运行时修改。</p>
<p>Slice 的数据结构定义如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/slice-1.png" alt="slice-1"><br><img src="/slice-2.png" alt="slice-2"></p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="空切片和nil切片"><a href="#空切片和nil切片" class="headerlink" title="空切片和nil切片"></a>空切片和nil切片</h3><p><img src="/slice-3.png" alt="slice-3"><br><img src="/slice-4.png" alt="slice-4"><br>空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。<br>最后需要说明的一点是。不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>当一个切片的容量满了，就需要扩容了。怎么扩，策略是什么？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc(unsafe.Pointer(&amp;et))</span><br><span class="line">		racereadrangepc(old.array, <span class="type">uintptr</span>(old.<span class="built_in">len</span>*<span class="type">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(old.array, <span class="type">uintptr</span>(old.<span class="built_in">len</span>*<span class="type">int</span>(et.size)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果新要扩容的容量比原来的容量还要小，这代表要缩容了，那么可以直接报panic了。</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果当前切片的大小为0，还调用了扩容方法，那么就新生成一个新的容量的切片返回。</span></span><br><span class="line">		<span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是扩容的策略</span></span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">			<span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">			<span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算新的切片的容量，长度。</span></span><br><span class="line">	<span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line">	<span class="keyword">const</span> ptrSize = unsafe.Sizeof((*<span class="type">byte</span>)(<span class="literal">nil</span>))</span><br><span class="line">	<span class="keyword">switch</span> et.size &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">		newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">		capmem = roundupsize(<span class="type">uintptr</span>(newcap))</span><br><span class="line">		newcap = <span class="type">int</span>(capmem)</span><br><span class="line">	<span class="keyword">case</span> ptrSize:</span><br><span class="line">		lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * ptrSize</span><br><span class="line">		newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * ptrSize</span><br><span class="line">		capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">		newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">		newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">		capmem = roundupsize(<span class="type">uintptr</span>(newcap) * et.size)</span><br><span class="line">		newcap = <span class="type">int</span>(capmem / et.size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断非法的值，保证容量是在增加，并且容量不超过最大容量</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> || <span class="type">uintptr</span>(newcap) &gt; maxSliceCap(et.size) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 在老的切片后面继续扩充容量</span></span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		<span class="comment">// 将 lenmem 这个多个 bytes 从 old.array地址 拷贝到 p 的地址处</span></span><br><span class="line">		memmove(p, old.array, lenmem)</span><br><span class="line">		<span class="comment">// 先将 P 地址加上新的容量得到新切片容量的地址，然后将新切片容量地址后面的 capmem-newlenmem 个 bytes 这块内存初始化。为之后继续 append() 操作腾出空间。</span></span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 重新申请新的数组给新切片</span></span><br><span class="line">		<span class="comment">// 重新申请 capmen 这个大的内存地址，并且初始化为0值</span></span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">			<span class="comment">// 如果还不能打开写锁，那么只能把 lenmem 大小的 bytes 字节从 old.array 拷贝到 p 的地址处</span></span><br><span class="line">			memmove(p, old.array, lenmem)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 循环拷贝老的切片的值</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; lenmem; i += et.size &#123;</span><br><span class="line">				typedmemmove(et, add(p, i), add(old.array, i))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回最终新切片，容量更新为最新扩容之后的容量</span></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述就是扩容的实现。主要需要关注的有两点，一个是扩容时候的策略，还有一个就是扩容是生成全新的内存地址还是在原来的地址后追加。</p>
<h3 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h3><p>Go 中切片扩容的策略是这样的：</p>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap） </li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap）</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ul>
<h3 id="扩容之后的数组是新数组还是老数组"><a href="#扩容之后的数组是新数组还是老数组" class="headerlink" title="扩容之后的数组是新数组还是老数组"></a>扩容之后的数组是新数组还是老数组</h3><p><strong>情况一</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	array := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	slice := array[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	newSlice := <span class="built_in">append</span>(slice, <span class="number">50</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, slice, &amp;slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, newSlice, &amp;newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">	newSlice[<span class="number">1</span>] += <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;After slice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, slice, &amp;slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&quot;</span>, newSlice, &amp;newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After array = %v\n&quot;</span>, array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Before slice = [10 20], Pointer = 0xc4200c0040, len = 2, cap = 4</span><br><span class="line">Before newSlice = [10 20 50], Pointer = 0xc4200c0060, len = 3, cap = 4</span><br><span class="line">After slice = [10 30], Pointer = 0xc4200c0040, len = 2, cap = 4</span><br><span class="line">After newSlice = [10 30 50], Pointer = 0xc4200c0060, len = 3, cap = 4</span><br><span class="line">After array = [10 30 50 40]</span><br></pre></td></tr></table></figure>
<p>把上述过程用图表示出来，如下图。<br><img src="/slice-5.png" alt="slice-5"><br>通过打印的结果，我们可以看到，在这种情况下，扩容以后并没有新建一个新的数组，扩容前后的数组都是同一个，这也就导致了新的切片修改了一个值，也影响到了老的切片了。<br>并且 append() 操作也改变了原来数组里面的值。<br>一个 append() 操作影响了这么多地方，如果原数组上有多个切片，那么这些切片都会被影响！无意间就产生了莫名的 bug！<br>这种情况，由于原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。<br>这种情况也极容易出现在字面量创建切片时候，第三个参数 cap 传值的时候，如果用字面量创建切片，cap 并不等于指向数组的总容量，那么这种情况就会发生。<br>上面这种情况非常危险，极度容易产生 bug 。<br>建议用字面量创建切片的时候，cap 的值一定要保持清醒，避免共享原数组导致的 bug。</p>
<p><strong>情况二</strong><br>情况二其实就是在扩容策略里面举的例子，在那个例子中之所以生成了新的切片，是因为原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。<br>所以建议尽量避免情况一，尽量使用情况二，避免 bug 产生。</p>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>Slice 中拷贝方法有2个</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return </span></span><br><span class="line">	<span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// n 记录下源切片或者目标切片较短的那一个的长度</span></span><br><span class="line">	n := fm.<span class="built_in">len</span></span><br><span class="line">	<span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">		n = to.<span class="built_in">len</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果入参 width = 0，也不需要拷贝了，返回较短的切片的长度</span></span><br><span class="line">	<span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果开启了竞争检测</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc(unsafe.Pointer(&amp;to))</span><br><span class="line">		pc := funcPC(slicecopy)</span><br><span class="line">		racewriterangepc(to.array, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)), callerpc, pc)</span><br><span class="line">		racereadrangepc(fm.array, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)), callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果开启了 The memory sanitizer (msan)</span></span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanwrite(to.array, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)))</span><br><span class="line">		msanread(fm.array, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size := <span class="type">uintptr</span>(n) * width</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">1</span> &#123; </span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> is this still worth it with new memmove impl?</span></span><br><span class="line">		<span class="comment">// 如果只有一个元素，那么指针直接转换即可</span></span><br><span class="line">		*(*<span class="type">byte</span>)(to.array) = *(*<span class="type">byte</span>)(fm.array) <span class="comment">// known to be a byte pointer</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果不止一个元素，那么就把 size 个 bytes 从 fm.array 地址开始，拷贝到 to.array 地址之后</span></span><br><span class="line">		memmove(to.array, fm.array, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。<br><img src="/slice-6.png" alt="slice-6"></p>
<p>举个例子，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	array := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">6</span>)</span><br><span class="line">	n := <span class="built_in">copy</span>(slice, array)</span><br><span class="line">	fmt.Println(n,slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个拷贝的方法，这个方法原理和 slicecopy 方法类似，不在赘述了，注释写在代码里面了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicestringcopy</span><span class="params">(to []<span class="type">byte</span>, fm <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return </span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(fm) == <span class="number">0</span> || <span class="built_in">len</span>(to) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// n 记录下源切片或者目标切片较短的那一个的长度</span></span><br><span class="line">	n := <span class="built_in">len</span>(fm)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(to) &lt; n &#123;</span><br><span class="line">		n = <span class="built_in">len</span>(to)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果开启了竞争检测</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc(unsafe.Pointer(&amp;to))</span><br><span class="line">		pc := funcPC(slicestringcopy)</span><br><span class="line">		racewriterangepc(unsafe.Pointer(&amp;to[<span class="number">0</span>]), <span class="type">uintptr</span>(n), callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果开启了 The memory sanitizer (msan)</span></span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanwrite(unsafe.Pointer(&amp;to[<span class="number">0</span>]), <span class="type">uintptr</span>(n))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拷贝字符串至字节数组</span></span><br><span class="line">	memmove(unsafe.Pointer(&amp;to[<span class="number">0</span>]), stringStructOf(&amp;fm).str, <span class="type">uintptr</span>(n))</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举个例子，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line">	n := <span class="built_in">copy</span>(slice, <span class="string">&quot;abcdef&quot;</span>)</span><br><span class="line">	fmt.Println(n,slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到拷贝，切片中有一个需要注意的问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;value = %d , value-addr = %x , slice-addr = %x\n&quot;</span>, value, &amp;value, &amp;slice[index])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">value = 10 , value-addr = c4200aedf8 , slice-addr = c4200b0320</span><br><span class="line">value = 20 , value-addr = c4200aedf8 , slice-addr = c4200b0328</span><br><span class="line">value = 30 , value-addr = c4200aedf8 , slice-addr = c4200b0330</span><br><span class="line">value = 40 , value-addr = c4200aedf8 , slice-addr = c4200b0338</span><br></pre></td></tr></table></figure>
<p>从上面结果我们可以看到，如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。<br>所以每次打印 Value 的地址都不变。</p>
<p><img src="/slice-7.png" alt="slice-7"><br>由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &amp;slice[index] 获取真实的地址。</p>
<p><strong>原文地址:</strong> <a href="https://halfrost.com/go_slice/">深入解析 Go 中 Slice 底层实现</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>slice</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 1.18 泛型全面讲解：一篇讲清泛型的全部</title>
    <url>/2022/06/13/golang-specification/</url>
    <content><![CDATA[<blockquote>
<p>原文出处: <a href="https://segmentfault.com/a/1190000041634906">https://segmentfault.com/a/1190000041634906</a></p>
</blockquote>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><blockquote>
<p>本文力求能让未接触过泛型编程的人也能较好理解Go的泛型，所以行文可能略显啰嗦。但是请相信我，看完这篇文章你能获得对Go泛型非常全面的了解</p>
</blockquote>
<ul>
<li>2022年3月15日，争议非常大但同时也备受期待的泛型终于伴随着Go1.18发布了。</li>
<li>可是因为Go对泛型的支持时间跨度太大，有非常多的以<code>泛型</code>为关键字的文章都是在介绍Go1.18之前的旧泛型提案或者设计，而很多设计最终在Go1.18中被废弃或发生了更改。</li>
<li>并且很多介绍Go1.18泛型的文章(包括官方的)都过于简单，并没对Go的泛型做完整的介绍，也没让大家意识到这次Go引入泛型给语言增加了多少复杂度（当然也可能单纯是我没搜到更好的文章）</li>
<li>出于这些原因，我决定参考 <a href="https://go.dev/ref/spec">The Go Programming Language Specification</a> ，写一篇比较完整系统介绍Go1.18 泛型的文章。</li>
<li>这篇文章可能是目前介绍Go泛型比较全面的文章之一了</li>
</ul>
<h1 id="一切从函数的形参和实参说起"><a href="#一切从函数的形参和实参说起" class="headerlink" title="一切从函数的形参和实参说起"></a>一切从函数的形参和实参说起</h1><p>假设我们有个计算两数之和的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数很简单，但是它有个问题——无法计算int类型之外的和。如果我们想计算浮点或者字符串的和该怎么办？解决办法之一就是像下面这样为不同类型定义不同的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddFloat32</span><span class="params">(a <span class="type">float32</span>, b <span class="type">float32</span>)</span></span> <span class="type">float32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddString</span><span class="params">(a <span class="type">string</span>, b <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可是除此之外还有没有更好的方法？答案是有的，我们可以来回顾下函数的 <em><strong>形参(parameter)</strong></em> 和 <em><strong>实参(argument)</strong></em> 这一基本概念：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="comment">// 变量a,b是函数的形参   &quot;a int, b int&quot; 这一串被称为形参列表</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add(<span class="number">100</span>,<span class="number">200</span>) <span class="comment">// 调用函数时，传入的100和200是实参</span></span><br></pre></td></tr></table></figure>
<p>我们知道，函数的 <em><strong>形参(parameter)</strong></em> 只是类似占位符的东西并没有具体的值，只有我们调用函数传入 <em><strong>实参(argument)</strong></em> 之后才有具体的值。<br>那么，如果我们将 <em><strong>形参 实参</strong></em> 这个概念推广一下，给变量的类型也引入和类似形参实参的概念的话，问题就迎刃而解：在这里我们将其称之为 <em><strong>类型形参(type parameter)</strong></em> 和 <em><strong>类型实参(type argument)</strong></em> ，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 T 是类型形参，在定义函数时它的类型是不确定的，类似占位符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a T, b T)</span></span> T &#123;  </span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段伪代码中， T 被称为 <em><strong>类型形参(type parameter)</strong></em> ，它不是具体的类型，在定义函数时类型并不确定。<br>因为 T 的类型并不确定，所以我们需要像函数的形参那样，在调用函数的时候再传入具体的类型。<br>这样我们不就能一个函数同时支持多个不同的类型了吗？在这里被传入的具体类型被称为 <em><strong>类型实参(type argument)</strong></em>:<br>下面一段伪代码展示了调用函数时传入类型实参的方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [T=int]中的 int 是类型实参，代表着函数Add()定义中的类型形参 T 全都被 int 替换</span></span><br><span class="line">Add[T=<span class="type">int</span>](<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 传入类型实参int后，Add()函数的定义可近似看成下面这样：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">( a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子：当我们想要计算两个字符串之和的时候，就传入string类型实参</span></span><br><span class="line">Add[T=<span class="type">string</span>](<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)</span><br><span class="line"><span class="comment">// 类型实参string传入后，Add()函数的定义可近似视为如下</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">( a <span class="type">string</span>, b <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过引入 <em><strong>类型形参</strong></em> 和 <em><strong>类型实参</strong></em> 这两个概念，我们让一个函数获得了处理多种不同类型数据的能力，这种编程方式被称为 <em><strong>泛型编程</strong></em>。</p>
<p>可能你会已奇怪，我通过Go的 <em><strong>接口+反射</strong></em> 不也能实现这样的动态数据处理吗？是的，泛型能实现的功能通过接口+反射也基本能实现。<br>但是使用过反射的人都知道反射机制有很多问题：</p>
<ul>
<li>用起来麻烦</li>
<li>失去了编译时的类型检查，不仔细写容易出错</li>
<li>性能不太理想</li>
</ul>
<p>而在泛型适用的时候，它能解决上面这些问题。<br>但这也不意味着泛型是万金油，泛型有着自己的适用场景，当你疑惑是不是该用泛型的话，请记住下面这条经验：</p>
<ul>
<li>如果你经常要分别为不同的类型写完全相同逻辑的代码，那么使用泛型将是最合适的选择</li>
</ul>
<h1 id="Go的泛型"><a href="#Go的泛型" class="headerlink" title="Go的泛型"></a>Go的泛型</h1><p>通过上面的伪代码，我们实际上已经对Go的泛型编程有了最初步也是最重要的认识—— <em><strong>类型形参</strong></em> 和 <em><strong>类型实参</strong></em> 。<br>而Go1.18也是通过这种方式实现的泛型，但是单纯的形参实参是远远不能实现泛型编程的，所以Go还引入了非常多全新的概念：</p>
<ul>
<li>类型形参 (Type parameter)</li>
<li>类型实参(Type argument)</li>
<li>类型形参列表( Type parameter list)</li>
<li>类型约束(Type constraint)</li>
<li>实例化(Instantiations)</li>
<li>泛型类型(Generic type)</li>
<li>泛型接收器(Generic receiver)</li>
<li>泛型函数(Generic function)<br>等等等等。</li>
</ul>
<p>啊，实在概念太多了头晕？没事请跟着我慢慢来，首先从 泛型类型(generic type) 讲起</p>
<h1 id="类型形参、类型实参、类型约束和泛型类型"><a href="#类型形参、类型实参、类型约束和泛型类型" class="headerlink" title="类型形参、类型实参、类型约束和泛型类型"></a>类型形参、类型实参、类型约束和泛型类型</h1><p>观察下面这个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSlice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a IntSlice = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> b IntSlice = []<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125; <span class="comment">// ✗ 错误，因为IntSlice的底层类型是[]int，浮点类型的切片无法赋值</span></span><br></pre></td></tr></table></figure>
<p>这里定义了一个新的类型 <code>IntSlice</code> ，它的底层类型是 <code>[]int</code> ，理所当然只有int类型的切片能赋值给 <code>IntSlice</code> 类型的变量。<br>接下来如果我们想要定义一个可以容纳 <code>float32</code> 或 <code>string</code> 等其他类型的切片的话该怎么办？很简单，给每种类型都定义个新类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Float32Slie []<span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> Float64Slice []<span class="type">float64</span></span><br></pre></td></tr></table></figure>
<p>但是这样做的问题显而易见，它们结构都是一样的只是成员类型不同就需要重新定义这么多新类型。<br>那么有没有一个办法能只定义一个类型就能代表上面这所有的类型呢？答案是可以的，这时候就需要用到泛型了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span>|<span class="type">float32</span>|<span class="type">float64</span> ] []T</span><br></pre></td></tr></table></figure>
<p>不同于一般的类型定义，这里类型名称 Slice 后带了中括号，对各个部分做一个解说就是：</p>
<ul>
<li><code>T</code> 就是上面介绍过的 <em><strong>类型形参(Type parameter)</strong></em> ，在定义<code>Slice</code>类型的时候 <code>T</code> 代表的具体类型并不确定，类似一个占位符</li>
<li><code>int|float32|float64</code> 这部分被称为 ***类型约束(Type constraint)***，中间的 <code>|</code> 的意思是告诉编译器，类型形参 <code>T</code>只可以接收 <code>int</code> 或 <code>float32</code> 或 <code>float64</code> 这三种类型的实参</li>
<li>中括号里的 <code>T int|float32|float64</code> 这一整串因为定义了所有的类型形参(在这个例子里只有一个类型形参T），所以我们称其为 <em><strong>类型形参列表(type parameter list)</strong></em></li>
<li>这里新定义的类型名称叫 <code>Slice[T]</code></li>
</ul>
<p>这种类型定义的方式中带了类型形参，很明显和普通的类型定义非常不一样，所以我们将这种<br>类型定义中带 <em><strong>类型形参</strong></em> 的类型，称之为 <em><strong>泛型类型(Generic type)</strong></em></p>
<p>泛型类型不能直接拿来使用，必须传入 <em><strong>类型实参(Type argument)</strong></em> 将其确定为具体的类型之后才可使用。<br>而传入类型实参确定具体类型的操作被称为 <em><strong>实例化(Instantiations)</strong></em> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里传入了类型实参int，泛型类型Slice[T]被实例化为具体的类型 Slice[int]</span></span><br><span class="line"><span class="keyword">var</span> a Slice[<span class="type">int</span>] = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  </span><br><span class="line">fmt.Printf(<span class="string">&quot;Type Name: %T&quot;</span>,a)  <span class="comment">//输出：Type Name: Slice[int]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入类型实参float32, 将泛型类型Slice[T]实例化为具体的类型 Slice[string]</span></span><br><span class="line"><span class="keyword">var</span> b Slice[<span class="type">float32</span>] = []<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125; </span><br><span class="line">fmt.Printf(<span class="string">&quot;Type Name: %T&quot;</span>,b)  <span class="comment">//输出：Type Name: Slice[float32]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。因为变量a的类型为Slice[int]，b的类型为Slice[float32]，两者类型不同</span></span><br><span class="line">a = b  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。string不在类型约束 int|float32|float64 中，不能用来实例化泛型类型</span></span><br><span class="line"><span class="keyword">var</span> c Slice[<span class="type">string</span>] = []<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。Slice[T]是泛型类型，不可直接使用必须实例化为具体的类型</span></span><br><span class="line"><span class="keyword">var</span> x Slice[T] = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br></pre></td></tr></table></figure>

<p>对于上面的例子，我们先给泛型类型 <code>Slice[T]</code> 传入了类型实参 <code>int</code> ，这样泛型类型就被实例化为了具体类型 <code>Slice[int]</code> ，被实例化之后的类型定义可近似视为如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[<span class="type">int</span>] []<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>我们用实例化后的类型 <code>Slice[int]</code> 定义了一个新的变量 <code>a</code> ，这个变量可以存储int类型的切片。<br>之后我们还用同样的方法实例化出了另一个类型 <code>Slice[float32]</code> ，并创建了变量 <code>b</code> 。</p>
<p>因为变量 a 和 b 就是具体的不同类型了(一个 <code>Slice[int]</code> ，一个 <code>Slice[float32]</code>），所以 <code>a = b</code> 这样不同类型之间的变量赋值是不允许的。</p>
<p>同时，因为 <code>Slice[T]</code> 的类型约束限定了只能使用 <code>int</code> 或 <code>float32</code> 或 <code>float64</code> 来实例化自己，所以 <code>Slice[string]</code> 这样使用 <code>string</code> 类型来实例化是错误的。</p>
<p>上面只是个最简单的例子，实际上类型形参的数量可以远远不止一个，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyMap类型定义了两个类型形参 KEY 和 VALUE。分别为两个形参指定了不同的类型约束</span></span><br><span class="line"><span class="comment">// 这个泛型类型的名字叫： MyMap[KEY, VALUE]</span></span><br><span class="line"><span class="keyword">type</span> MyMap[KEY <span class="type">int</span> | <span class="type">string</span>, VALUE <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">map</span>[KEY]VALUE  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类型实参 string 和 flaot64 替换了类型形参 KEY 、 VALUE，泛型类型被实例化为具体的类型：MyMap[string, float64]</span></span><br><span class="line"><span class="keyword">var</span> a MyMap[<span class="type">string</span>, <span class="type">float64</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>&#123;</span><br><span class="line">    <span class="string">&quot;jack_score&quot;</span>: <span class="number">9.6</span>,</span><br><span class="line">    <span class="string">&quot;bob_score&quot;</span>:  <span class="number">8.4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用上面的例子重新复习下各种概念的话：</p>
<ul>
<li>KEY和VALUE是类型形参</li>
<li><code>int|string</code> 是KEY的 <strong>类型约束</strong> ， <code>float32|float64</code> 是VALUE的 <strong>类型约束</strong></li>
<li><code>KEY int|string</code>, <code>VALUE float32|float64</code> 整个一串文本因为定义了所有形参所以被称为 <strong>类型形参列表</strong></li>
<li><code>Map[KEY, VALUE]</code> 是 <strong>泛型类型</strong> ，类型的名字就叫 <code>Map[KEY, VALUE]</code></li>
<li><code>var a MyMap[string, float64] = xx</code> 中的<code>string</code>和<code>float64</code>是类型实参，用于分别替换KEY和VALUE，实例化出了具体的类型 <code>MyMap[string, float64]</code></li>
</ul>
<p>还有点头晕？没事，的确一下子有太多概念了，这里用一张图就能简单说清楚：<br><img src="/1.png" alt="1"></p>
<h2 id="其他的泛型类型"><a href="#其他的泛型类型" class="headerlink" title="其他的泛型类型"></a>其他的泛型类型</h2><p>所有类型定义都可使用类型形参，所以下面这种结构体以及接口的定义也可以使用类型形参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个泛型类型的结构体。可用 int 或 sring 类型实例化</span></span><br><span class="line"><span class="keyword">type</span> MyStruct[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Data T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个泛型接口(关于泛型接口在后半部分会详细讲解）</span></span><br><span class="line"><span class="keyword">type</span> IPrintData[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    Print(data T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个泛型通道，可用类型实参 int 或 string 实例化</span></span><br><span class="line"><span class="keyword">type</span> MyChan[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">chan</span> T</span><br></pre></td></tr></table></figure>
<h2 id="类型形参的互相套用"><a href="#类型形参的互相套用" class="headerlink" title="类型形参的互相套用"></a>类型形参的互相套用</h2><p>类型形参是可以互相套用的，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WowStruct[T <span class="type">int</span> | <span class="type">float32</span>, S []T] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data     S</span><br><span class="line">    MaxValue T</span><br><span class="line">    MinValue T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子看起来有点复杂且难以理解，但实际上只要记住一点：任何泛型类型都必须传入类型实参实例化才可以使用。所以我们这就尝试传入类型实参看看：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型类型 WowStuct[T, S] 被实例化后的类型名称就叫 WowStruct[int, []int]</span></span><br><span class="line"><span class="keyword">var</span> ws WowStruct[<span class="type">int</span>, []<span class="type">int</span>]</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们为<code>T</code>传入了实参 <code>int</code>，然后因为 <code>S</code> 的定义是 <code>[]T</code> ，所以 <code>S</code> 的实参自然是 <code>[]int</code> 。<br>经过实例化之后 <code>WowStruct[T,S]</code> 的定义类似如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个存储int类型切片，以及切片中最大、最小值的结构体</span></span><br><span class="line"><span class="keyword">type</span> WowStruct[<span class="type">int</span>, []<span class="type">int</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data     []<span class="type">int</span></span><br><span class="line">    MaxValue <span class="type">int</span></span><br><span class="line">    MinValue <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="几种语法错误"><a href="#几种语法错误" class="headerlink" title="几种语法错误"></a>几种语法错误</h2><p>定义泛型类型的时候，基础类型不能只有类型形参，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误，类型形参不能单独使用</span></span><br><span class="line"><span class="keyword">type</span> CommonType[T <span class="type">int</span>|<span class="type">string</span>|<span class="type">float32</span>] T</span><br></pre></td></tr></table></figure>
<p>当类型约束的一些写法会被编译器误认为是表达式时会报错。如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//✗ 错误。T *int会被编译器误认为是表达式 T乘以int，而不是int指针</span></span><br><span class="line"><span class="keyword">type</span> NewType[T *<span class="type">int</span>] []T</span><br><span class="line"><span class="comment">// 上面代码再编译器眼中：它认为你要定义一个存放切片的数组，数组长度由 T 乘以 int 计算得到</span></span><br><span class="line"><span class="keyword">type</span> NewType [T * <span class="type">int</span>][]T </span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误。和上面一样，这里不光*被会认为是乘号，| 还会被认为是按位或操作</span></span><br><span class="line"><span class="keyword">type</span> NewType2[T *<span class="type">int</span>|*<span class="type">float64</span>] []T </span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误</span></span><br><span class="line"><span class="keyword">type</span> NewType2 [T (<span class="type">int</span>)] []T </span><br></pre></td></tr></table></figure>
<p>为了避免这种误解，解决办法就是给类型约束包上 <code>interface&#123;&#125;</code> 或加上逗号消除歧义（关于接口具体的用法会在后半篇提及）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NewType[T <span class="keyword">interface</span>&#123;*<span class="type">int</span>&#125;] []T</span><br><span class="line"><span class="keyword">type</span> NewType2[T <span class="keyword">interface</span>&#123;*<span class="type">int</span>|*<span class="type">float64</span>&#125;] []T </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果类型约束中只有一个类型，可以添加个逗号消除歧义</span></span><br><span class="line"><span class="keyword">type</span> NewType3[T *<span class="type">int</span>,] []T</span><br><span class="line"></span><br><span class="line"><span class="comment">//✗ 错误。如果类型约束不止一个类型，加逗号是不行的</span></span><br><span class="line"><span class="keyword">type</span> NewType4[T *<span class="type">int</span>|*<span class="type">float32</span>,] []T </span><br></pre></td></tr></table></figure>
<p>因为上面逗号的用法限制比较大，这里推荐统一用 <code>interface&#123;&#125;</code> 解决问题</p>
<h2 id="特殊的泛型类型"><a href="#特殊的泛型类型" class="headerlink" title="特殊的泛型类型"></a>特殊的泛型类型</h2><p>这里讨论种比较特殊的泛型类型，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Wow[T <span class="type">int</span> | <span class="type">string</span>] <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a Wow[<span class="type">int</span>] = <span class="number">123</span>     <span class="comment">// 编译正确</span></span><br><span class="line"><span class="keyword">var</span> b Wow[<span class="type">string</span>] = <span class="number">123</span>  <span class="comment">// 编译正确</span></span><br><span class="line"><span class="keyword">var</span> c Wow[<span class="type">string</span>] = <span class="string">&quot;hello&quot;</span> <span class="comment">// 编译错误，因为&quot;hello&quot;不能赋值给底层类型int</span></span><br></pre></td></tr></table></figure>
<p>这里虽然使用了类型形参，但因为类型定义是 <code>type Wow[T int|string] int</code> ，所以无论传入什么类型实参，实例化后的新类型的底层类型都是 int 。<br>所以int类型的数字123可以赋值给变量a和b，但string类型的字符串 “hello” 不能赋值给c</p>
<p>这个例子没有什么具体意义，但是可以让我们理解泛型类型的实例化的机制</p>
<h2 id="泛型类型的套娃"><a href="#泛型类型的套娃" class="headerlink" title="泛型类型的套娃"></a>泛型类型的套娃</h2><p>泛型和普通的类型一样，可以互相嵌套定义出更加复杂的新类型，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先定义个泛型类型 Slice[T]</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span>|<span class="type">string</span>|<span class="type">float32</span>|<span class="type">float64</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✗ 错误。泛型类型Slice[T]的类型约束中不包含uint, uint8</span></span><br><span class="line"><span class="keyword">type</span> UintSlice[T <span class="type">uint</span>|<span class="type">uint8</span>] Slice[T]  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 正确。基于泛型类型Slice[T]定义了新的泛型类型 FloatSlice[T] 。FloatSlice[T]只接受float32和float64两种类型</span></span><br><span class="line"><span class="keyword">type</span> FloatSlice[T <span class="type">float32</span>|<span class="type">float64</span>] Slice[T] </span><br><span class="line"></span><br><span class="line"><span class="comment">// ✓ 正确。基于泛型类型Slice[T]定义的新泛型类型 IntAndStringSlice[T]</span></span><br><span class="line"><span class="keyword">type</span> IntAndStringSlice[T <span class="type">int</span>|<span class="type">string</span>] Slice[T]  </span><br><span class="line"><span class="comment">// ✓ 正确 基于IntAndStringSlice[T]套娃定义出的新泛型类型</span></span><br><span class="line"><span class="keyword">type</span> IntSlice[T <span class="type">int</span>] IntAndStringSlice[T] </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map中套一个泛型类型Slice[T]</span></span><br><span class="line"><span class="keyword">type</span> WowMap[T <span class="type">int</span>|<span class="type">string</span>] <span class="keyword">map</span>[<span class="type">string</span>]Slice[T]</span><br><span class="line"><span class="comment">// 在map中套Slice[T]的另一种写法</span></span><br><span class="line"><span class="keyword">type</span> WowMap2[T Slice[<span class="type">int</span>] | Slice[<span class="type">string</span>]] <span class="keyword">map</span>[<span class="type">string</span>]T</span><br></pre></td></tr></table></figure>

<h2 id="类型约束的两种选择"><a href="#类型约束的两种选择" class="headerlink" title="类型约束的两种选择"></a>类型约束的两种选择</h2><p>观察下面两种类型约束的写法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WowStruct[T <span class="type">int</span>|<span class="type">string</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Data []T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WowStruct2[T []<span class="type">int</span>|[]<span class="type">string</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Data T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅限于这个例子，这两种写法和实现的功能其实是差不多的，实例化之后结构体相同。<br>但是像下面这种情况的时候，我们使用前一种写法会更好：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WowStruct3[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data     []T</span><br><span class="line">    MaxValue T</span><br><span class="line">    MinValue T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名结构体不支持泛型"><a href="#匿名结构体不支持泛型" class="headerlink" title="匿名结构体不支持泛型"></a>匿名结构体不支持泛型</h2><p>我们有时候会经常用到匿名的结构体，并在定义好匿名结构体之后直接初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">testCase := <span class="keyword">struct</span> &#123;</span><br><span class="line">    caseName <span class="type">string</span></span><br><span class="line">    got      <span class="type">int</span></span><br><span class="line">    want     <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    caseName: <span class="string">&quot;test OK&quot;</span>,</span><br><span class="line">    got:      <span class="number">100</span>,</span><br><span class="line">    want:     <span class="number">100</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么匿名结构体能不能使用泛型呢？答案是不能，下面的用法是错误的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">testCase := <span class="keyword">struct</span>[T <span class="type">int</span>|<span class="type">string</span>] &#123;</span><br><span class="line">    caseName <span class="type">string</span></span><br><span class="line">    got      T</span><br><span class="line">    want     T</span><br><span class="line">&#125;[<span class="type">int</span>]&#123;</span><br><span class="line">    caseName: <span class="string">&quot;test OK&quot;</span>,</span><br><span class="line">    got:      <span class="number">100</span>,</span><br><span class="line">    want:     <span class="number">100</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在使用泛型的时候我们只能放弃使用匿名结构体，对于很多场景来说这会造成麻烦（最主要麻烦集中在单元测试的时候，为泛型做单元测试会非常麻烦，这点我之后的文章将会详细阐述）</p>
<h1 id="泛型receiver"><a href="#泛型receiver" class="headerlink" title="泛型receiver"></a>泛型receiver</h1><p>看了上的例子，你一定会说，介绍了这么多复杂的概念，但好像泛型类型根本没什么用处啊？<br>是的，单纯的泛型类型实际上对开发来说用处并不大。<br>但是如果将泛型类型和接下来要介绍的泛型receiver相结合的话，泛型就有了非常大的实用性了<br>我们知道，定义了新的普通类型之后可以给类型添加方法。<br>那么可以给泛型类型添加方法吗？答案自然是可以的，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice[T <span class="type">int</span> | <span class="type">float32</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s MySlice[T])</span></span> Sum() T &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子为泛型类型 <code>MySlice[T]</code> 添加了一个计算成员总和的方法 <code>Sum()</code> 。注意观察这个方法的定义：</p>
<ul>
<li>首先看receiver (<code>s MySlice[T]</code>) ，所以我们直接把类型名称 <code>MySlice[T]</code> 写入了receiver中</li>
<li>然后方法的返回参数我们使用了类型形参 <strong>T</strong> (实际上如果有需要的话，方法的接收参数也可以实用类型形参)</li>
<li>在方法的定义中，我们也可以使用类型形参 <strong>T</strong> （在这个例子里，我们通过 <code>var sum T</code> 定义了一个新的变量 <code>sum</code> )</li>
</ul>
<p>对于这个泛型类型 <code>MySlice[T]</code> 我们该如何使用？还记不记得之前强调过很多次的，泛型类型无论如何都需要先用类型实参实例化，所以用法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s MySlice[<span class="type">int</span>] = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(s.Sum()) <span class="comment">// 输出：10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 MySlice[<span class="type">float32</span>] = []<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;</span><br><span class="line">fmt.Println(s2.Sum()) <span class="comment">// 输出：10.0</span></span><br></pre></td></tr></table></figure>
<p>该如何理解上面的实例化？首先我们用类型实参 <code>int</code> 实例化了泛型类型 <code>MySlice[T]</code>，所以泛型类型定义中的所有 <code>T</code> 都被替换为 <code>int</code>，最终我们可以把代码看作下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice[<span class="type">int</span>] []<span class="type">int</span> <span class="comment">// 实例化后的类型名叫 MyIntSlice[int]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法中所有类型形参 T 都被替换为类型实参 int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s MySlice[<span class="type">int</span>])</span></span> Sum() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span> </span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 float32 实例化和用 int 实例化同理，此处不再赘述。<br>通过泛型receiver，泛型的实用性一下子得到了巨大的扩展。<br>在没有泛型之前如果想实现通用的数据结构，诸如：堆、栈、队列、链表之类的话，我们的选择只有两个：</p>
<ul>
<li>为每种类型写一个实现</li>
<li>使用 接口+反射</li>
</ul>
<p>而有了泛型之后，我们就能非常简单地创建通用数据结构了。<br>接下来用一个更加实用的例子 —— 队列 来讲解</p>
<h2 id="基于泛型的队列"><a href="#基于泛型的队列" class="headerlink" title="基于泛型的队列"></a>基于泛型的队列</h2><p>队列是一种先入先出的数据结构，它和现实中排队一样，数据只能从队尾放入、从队首取出，先放入的数据优先被取出来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里类型约束使用了空接口，代表的意思是所有类型都可以用来实例化泛型类型 Queue[T] (关于接口在后半部分会详细介绍）</span></span><br><span class="line"><span class="keyword">type</span> Queue[T <span class="keyword">interface</span>&#123;&#125;] <span class="keyword">struct</span> &#123;</span><br><span class="line">    elements []T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据放入队列尾部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue[T])</span></span> Put(value T) &#123;</span><br><span class="line">    q.elements = <span class="built_in">append</span>(q.elements, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列头部取出并从头部删除对应数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue[T])</span></span> Pop() (T, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value T</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q.elements) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value = q.elements[<span class="number">0</span>]</span><br><span class="line">    q.elements = q.elements[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> value, <span class="built_in">len</span>(q.elements) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q Queue[T])</span></span> Size() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(q.elements)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了方便说明，上面是队列非常简单的一种实现方法，没有考虑线程安全等很多问题</p>
</blockquote>
<p><code>Queue[T]</code> 因为是泛型类型，所以要使用的话必须实例化，实例化与使用方法如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> q1 Queue[<span class="type">int</span>]  <span class="comment">// 可存放int类型数据的队列</span></span><br><span class="line">q1.Put(<span class="number">1</span>)</span><br><span class="line">q1.Put(<span class="number">2</span>)</span><br><span class="line">q1.Put(<span class="number">3</span>)</span><br><span class="line">q1.Pop() <span class="comment">// 1</span></span><br><span class="line">q1.Pop() <span class="comment">// 2</span></span><br><span class="line">q1.Pop() <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> q2 Queue[<span class="type">string</span>]  <span class="comment">// 可存放string类型数据的队列</span></span><br><span class="line">q2.Put(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">q2.Put(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">q2.Put(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">q2.Pop() <span class="comment">// &quot;A&quot;</span></span><br><span class="line">q2.Pop() <span class="comment">// &quot;B&quot;</span></span><br><span class="line">q2.Pop() <span class="comment">// &quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> q3 Queue[<span class="keyword">struct</span>&#123;Name <span class="type">string</span>&#125;] </span><br><span class="line"><span class="keyword">var</span> q4 Queue[[]<span class="type">int</span>] <span class="comment">// 可存放[]int切片的队列</span></span><br><span class="line"><span class="keyword">var</span> q5 Queue[<span class="keyword">chan</span> <span class="type">int</span>] <span class="comment">// 可存放int通道的队列</span></span><br><span class="line"><span class="keyword">var</span> q6 Queue[io.Reader] <span class="comment">// 可存放接口的队列</span></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>
<h2 id="动态判断变量的类型"><a href="#动态判断变量的类型" class="headerlink" title="动态判断变量的类型"></a>动态判断变量的类型</h2><p>使用接口的时候经常会用到类型断言或 type swith 来确定接口具体的类型，然后对不同类型做出不同的处理，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">123</span></span><br><span class="line">i.(<span class="type">int</span>) <span class="comment">// 类型断言</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type switch</span></span><br><span class="line"><span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么你一定会想到，对于 valut T 这样通过类型形参定义的变量，我们能不能判断具体类型然后对不同类型做出不同处理呢？答案是不允许的，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue[T])</span></span> Put(value T) &#123;</span><br><span class="line">    value.(<span class="type">int</span>) <span class="comment">// 错误。泛型类型定义的变量不能使用类型断言</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误。不允许使用type switch 来判断 value 的具体类型</span></span><br><span class="line">    <span class="keyword">switch</span> value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然type switch和类型断言不能用，但我们可通过反射机制达到目的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver Queue[T])</span></span> Put(value T) &#123;</span><br><span class="line">    <span class="comment">// Printf() 可输出变量value的类型(底层就是通过反射实现的)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T&quot;</span>, value) </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射可以动态获得变量value的类型从而分情况处理</span></span><br><span class="line">    v := reflect.ValueOf(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Int:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来达到了我们的目的，可是当你写出上面这样的代码时候就出现了一个问题：</p>
<ul>
<li>你为了避免使用反射而选择了泛型，结果到头来又为了一些功能在在泛型中使用反射</li>
</ul>
<p>当出现这种情况的时候你可能需要重新思考一下，自己的需求是不是真的需要用泛型（毕竟泛型机制本身就很复杂了，再加上反射的复杂度，增加的复杂度并不一定值得）<br>当然，这一切选择权都在你自己的手里，根据具体情况斟酌</p>
<h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><p>在介绍完泛型类型和泛型receiver之后，我们来介绍最后一个可以使用泛型的地方——泛型函数。<br>有了上面的知识，写泛型函数也十分简单。假设我们想要写一个计算两个数之和的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数理所当然只能计算int的和，而浮点的计算是不支持的。这时候我们可以像下面这样定义一个泛型函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float32</span> | <span class="title">float64</span>]<span class="params">(a T, b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是泛型函数的定义。</p>
<blockquote>
<p>这种带类型形参的函数被称为 <strong>泛型函数</strong></p>
</blockquote>
<p>它和普通函数的点不同在于函数名之后带了类型形参。<br>这里的类型形参的意义、写法和用法因为与泛型类型是一模一样的，就不再赘述了。<br>和泛型类型一样，泛型函数也是不能直接调用的，要使用泛型函数的话必须传入类型实参之后才能调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Add[<span class="type">int</span>](<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 传入类型实参int，计算结果为 3</span></span><br><span class="line">Add[<span class="type">float32</span>](<span class="number">1.0</span>, <span class="number">2.0</span>) <span class="comment">// 传入类型实参float32, 计算结果为 3.0</span></span><br><span class="line"></span><br><span class="line">Add[<span class="type">string</span>](<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>) <span class="comment">// 错误。因为泛型函数Add的类型约束中并不包含string</span></span><br></pre></td></tr></table></figure>
<p>或许你会觉得这样每次都要手动指定类型实参太不方便了。<br>所以Go还支持类型实参的自动推导：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Add(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 1，2是int类型，编译请自动推导出类型实参T是int</span></span><br><span class="line">Add(<span class="number">1.0</span>, <span class="number">2.0</span>) <span class="comment">// 1.0, 2.0 是浮点，编译请自动推导出类型实参T是float32</span></span><br></pre></td></tr></table></figure>
<p>自动推导的写法就好像免去了传入实参的步骤一样，但请记住这仅仅只是编译器帮我们推导出了类型实参，实际上传入实参步骤还是发生了的。</p>
<h2 id="匿名函数不支持泛型"><a href="#匿名函数不支持泛型" class="headerlink" title="匿名函数不支持泛型"></a>匿名函数不支持泛型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fn := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b </span><br><span class="line">&#125;  <span class="comment">// 定义了一个匿名函数并赋值给 fn </span></span><br><span class="line"></span><br><span class="line">fmt.Println(fn(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure>
<p>那么Go支不支持匿名泛型函数呢？答案是不能—— <strong>匿名函数不能自己定义类型形参</strong> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误，匿名函数不能自己定义类型实参</span></span><br><span class="line">fnGeneric := <span class="function"><span class="keyword">func</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float32</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">fmt.Println(fnGeneric(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>但是匿名函数可以使用别处定义好的类型实参，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float32</span> | <span class="title">float64</span>]<span class="params">(a, b T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名函数可使用已经定义好的类型形参</span></span><br><span class="line">    fn2 := <span class="function"><span class="keyword">func</span><span class="params">(i T, j T)</span></span> T &#123;</span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span> - j*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn2(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="既然支持泛型函数，那么泛型方法呢？"><a href="#既然支持泛型函数，那么泛型方法呢？" class="headerlink" title="既然支持泛型函数，那么泛型方法呢？"></a>既然支持泛型函数，那么泛型方法呢？</h2><p>既然函数都支持泛型了，那你应该自然会想到，方法支不支持泛型？很不幸，目前Go的方法并不支持泛型，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不支持泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A)</span></span> Add[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">float64</span>](a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是因为receiver支持泛型， 所以如果想在方法中使用泛型的话，目前唯一的办法就是曲线救国，迂回地通过receiver使用类型形参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法可以使用类型定义中的形参 T </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A[T])</span></span> Add(a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">var</span> a A[<span class="type">int</span>]</span><br><span class="line">a.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa A[<span class="type">float32</span>]</span><br><span class="line">aa.Add(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>讲完了泛型类型、泛型receiver、泛型函数后，Go的泛型算是介绍完一半多了。在这里我们做一个概念的小结：</p>
<ul>
<li>Go的泛型(或者或类型形参)目前可使用在3个地方<ul>
<li>泛型类型 - 类型定义中带类型形参的类型</li>
<li>泛型receiver - 泛型类型的receiver</li>
<li>泛型函数 - 带类型形参的函数</li>
</ul>
</li>
<li>为了实现泛型，Go引入了一些新的概念：<ul>
<li>类型形参</li>
<li>类型形参列表</li>
<li>类型实参</li>
<li>类型约束</li>
<li>实例化 - 泛型类型不能直接使用，要使用的话必须传入类型实参进行实例化</li>
</ul>
</li>
</ul>
<p>什么，这文章已经很长很复杂了，才讲了一半？<br>是的，Go这次1.18引入泛型为语言增加了较大的复杂度，目前还只是新概念的介绍，下面后半段将介绍Go引入泛型后对接口做出的重大调整。<br>那么做好心理准备，我们出发吧。</p>
<h1 id="变得复杂的接口"><a href="#变得复杂的接口" class="headerlink" title="变得复杂的接口"></a>变得复杂的接口</h1><p>有时候使用泛型编程时，我们会书写长长的类型约束，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个可以容纳所有int,uint以及浮点类型的泛型切片</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span> | <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span> | <span class="type">uint64</span> | <span class="type">float32</span> | <span class="type">float64</span>] []T</span><br></pre></td></tr></table></figure>

<p>理所当然，这种写法是我们无法忍受也难以维护的，而Go支持将类型约束单独拿出来定义到接口中，从而让代码更容易维护：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntUintFloat <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span> | <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span> | <span class="type">uint64</span> | <span class="type">float32</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T IntUintFloat] []T</span><br></pre></td></tr></table></figure>
<p>这段代码把类型约束给单独拿出来，写入了接口类型 <code>IntUintFloat</code> 当中。需要指定类型约束的时候直接使用接口 <code>IntUintFloat</code> 即可。<br>不过这样的代码依旧不好维护，而接口和接口、接口和普通类型之间也是可以通过 | 进行组合：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">float32</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int | Uint | Float] []T  <span class="comment">// 使用 &#x27;|&#x27; 将多个接口类型组合</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们分别定义了 <code>Int, Uint, Float</code> 三个接口类型，并最终在 <code>Slice[T]</code> 的类型约束中通过使用 <code>|</code> 将它们组合到一起。<br>同时，在接口里也能直接组合其他接口，所以还可以像下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span> &#123;</span><br><span class="line">    Int | Uint | Float | <span class="type">string</span> <span class="comment">// 组合了三个接口类型并额外增加了一个 string 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T SliceElement] []T </span><br></pre></td></tr></table></figure>

<h2 id="指定底层类型"><a href="#指定底层类型" class="headerlink" title="~:指定底层类型"></a><code>~</code>:指定底层类型</h2><p>上面定义的 Slie[T] 虽然可以达到目的，但是有一个缺点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 Slice[<span class="type">int</span>] <span class="comment">// 正确 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt] <span class="comment">// ✗ 错误。MyInt类型底层类型是int但并不是int类型，不符合 Slice[T] 的类型约束</span></span><br></pre></td></tr></table></figure>
<p>这里发生错误的原因是，泛型类型 <code>Slice[T]</code> 允许的是 <code>int</code> 作为类型实参，而不是 <code>MyInt</code> （虽然 <code>MyInt</code> 类型底层类型是 <code>int</code> ，但它依旧不是 <code>int</code> 类型）。<br>为了从根本上解决这个问题，Go新增了一个符号 <code>~</code> ，在类型约束中使用类似 <code>~int</code> 这种写法的话，就代表着不光是 <code>int</code> ，所有以 <code>int</code> 为底层类型的类型也都可用于实例化。</p>
<p>使用 <code>~</code> 对代码进行改写之后如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int | Uint | Float] []T </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Slice[<span class="type">int</span>] <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]  <span class="comment">// MyInt底层类型是int，所以可以用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMyInt MyInt</span><br><span class="line"><span class="keyword">var</span> s3 Slice[MyMyInt]  <span class="comment">// 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat32 <span class="type">float32</span>  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s4 Slice[MyFloat32]</span><br></pre></td></tr></table></figure>
<p>限制：使用 ~ 时有一定的限制：</p>
<ul>
<li>~后面的类型不能为接口</li>
<li>~后面的类型必须为基本类型<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~[]<span class="type">byte</span>  <span class="comment">// 正确</span></span><br><span class="line">    ~MyInt   <span class="comment">// 错误，~后的类型必须为基本类型</span></span><br><span class="line">    ~<span class="type">error</span>   <span class="comment">// 错误，~后的类型不能为接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="从方法集-Method-set-到类型集-Type-set"><a href="#从方法集-Method-set-到类型集-Type-set" class="headerlink" title="从方法集(Method set)到类型集(Type set)"></a>从方法集(Method set)到类型集(Type set)</h2><p>上面的例子中，我们学习到了一种接口的全新写法，而这种写法在Go1.18之前是不存在的。如果你比较敏锐的话，一定会隐约认识到这种写法的改变这也一定意味着Go语言中 接口(interface) 这个概念发生了非常大的变化。<br>是的，在Go1.18之前，Go官方对 ·接口(interface)· 的定义是：接口是一个方法集(method set)</p>
<blockquote>
<p>An interface type specifies a method set called its interface</p>
</blockquote>
<p>就如下面这个代码一样， ReadWriter 接口定义了一个接口(方法集)，这个集合中包含了 Read() 和 Write() 这两个方法。<br>所有同时定义了这两种方法的类型被视为实现了这一接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，我们如果换一个角度来重新思考上面这个接口的话，会发现接口的定义实际上还能这样理解：</p>
<blockquote>
<p>我们可以把 <code>ReaderWriter</code> 接口看成代表了一个 <strong>类型的集合</strong> ，所有实现了 <code>Read() Writer()</code> 这两个方法的类型都在接口代表的类型集合当中</p>
</blockquote>
<p>通过换个角度看待接口，在我们眼中接口的定义就从 <code>方法集(method set)</code> 变为了 <code>类型集(type set)</code> 。<br>而Go1.18开始就是依据这一点将接口的定义正式更改为了 <code>类型集(Type set)</code></p>
<blockquote>
<p>An interface type defines a type set (一个接口类型定义了一个类型集)</p>
</blockquote>
<p>你或许会觉得，这不就是改了下概念上的定义实际上没什么用吗？是的，如果接口功能没变化的话确实如此。<br>但是还记得下面这种用接口来简化类型约束的写法吗：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Float] []T </span><br></pre></td></tr></table></figure>
<p>这就体现出了为什么要更改接口的定义了。用 类型集 的概念重新理解上面的代码的话就是：</p>
<blockquote>
<p>接口类型 Float 代表了一个 类型集合， 所有以 float32 或 float64 为底层类型的类型，都在这一类型集之中</p>
</blockquote>
<p>而 <code>type Slice[T Float] []T</code> 中， <code>类型约束</code> 的真正意思是：</p>
<blockquote>
<p>类型约束 指定了类型形参可接受的类型集合，只有属于这个集合中的类型才能替换形参用于实例化</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s Slice[<span class="type">int</span>]      <span class="comment">// int 属于类型集 Float ，所以int可以作为类型实参</span></span><br><span class="line"><span class="keyword">var</span> s Slice[<span class="keyword">chan</span> <span class="type">int</span>] <span class="comment">// chan int 类型不在类型集 Float 中，所以错误</span></span><br></pre></td></tr></table></figure>

<h3 id="接口实现-implement-定义的变化"><a href="#接口实现-implement-定义的变化" class="headerlink" title="接口实现(implement)定义的变化"></a>接口实现(implement)定义的变化</h3><p>既然接口定义发生了变化，那么从Go1.18开始 <code>接口实现(implement)</code> 的定义自然也发生了变化：<br>当满足以下条件时，我们可以说 <strong>类型 T 实现了接口 I ( type T implements interface I)</strong> ：</p>
<ul>
<li>T 不是接口时：类型 T 是接口 I 代表的类型集中的一个成员 (T is an element of the type set of I)</li>
<li>T 是接口时： T 接口代表的类型集是 I 代表的类型集的子集(Type set of T is a subset of the type set of I)</li>
</ul>
<h3 id="类型的并集"><a href="#类型的并集" class="headerlink" title="类型的并集"></a>类型的并集</h3><p>并集我们已经很熟悉了，之前一直使用的 | 符号就是求类型的并集( <code>union</code> )</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型集 Uint 是 ~uint 和 ~uint8 等类型的并集</span></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;  </span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型的交集"><a href="#类型的交集" class="headerlink" title="类型的交集"></a>类型的交集</h3><p>接口可以不止书写一行，如果一个接口有多行类型定义，那么取它们之间的 交集</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AllInt <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> | ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123; <span class="comment">// 接口A代表的类型集是 AllInt 和 Uint 的交集</span></span><br><span class="line">    AllInt</span><br><span class="line">    Uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">interface</span> &#123; <span class="comment">// 接口B代表的类型集是 AllInt 和 ~int 的交集</span></span><br><span class="line">    AllInt</span><br><span class="line">    ~<span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子中</p>
<ul>
<li>接口 A 代表的是 AllInt 与 Uint 的 <strong>交集</strong> ，即 <code>~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64</code> </li>
<li>接口 B 代表的则是 AllInt 和 <del>int 的 <strong>交集</strong> ，即 &#96;</del>int&#96;</li>
</ul>
<p>除了上面的交集，下面也是一种交集：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> C <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，~int 和 int 的交集只有int一种类型，所以接口C代表的类型集中只有int一种类型</p>
<h3 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集</h3><p>当多个类型的交集如下面 Bad 这样为空的时候， Bad 这个接口代表的类型集为一个空集：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bad <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">    <span class="type">float32</span> </span><br><span class="line">&#125; <span class="comment">// 类型 int 和 float32 没有相交的类型，所以接口 Bad 代表的类型集为空</span></span><br></pre></td></tr></table></figure>
<p>没有任何一种类型属于空集。虽然 Bad 这样的写法是可以编译的，但实际上并没有什么意义</p>
<h3 id="空接口和-any"><a href="#空接口和-any" class="headerlink" title="空接口和 any"></a>空接口和 any</h3><p>上面说了空集，接下来说一个特殊的类型集——<code>空接口 interface&#123;&#125;</code> 。<br>因为，Go1.18开始接口的定义发生了改变，所以 <code>interface&#123;&#125;</code> 的定义也发生了一些变更：</p>
<blockquote>
<p>空接口代表了所有类型的集合</p>
</blockquote>
<p>所以，对于Go1.18之后的空接口应该这样理解：</p>
<ul>
<li>虽然空接口内没有写入任何的类型，但它代表的是所有类型的集合，而非一个 <strong>空集</strong></li>
<li>类型约束中指定 <strong>空接口</strong> 的意思是指定了一个包含所有类型的类型集，并不是类型约束限定了只能使用 <strong>空接口</strong> 来做类型形参<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空接口代表所有类型的集合。写入类型约束意味着所有类型都可拿来做类型实参</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="keyword">interface</span>&#123;&#125;] []T</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 Slice[<span class="type">int</span>]    <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>]  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s3 Slice[<span class="keyword">chan</span> <span class="type">int</span>]  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s4 Slice[<span class="keyword">interface</span>&#123;&#125;]  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
因为空接口是一个包含了所有类型的类型集，所以我们经常会用到它。<br>于是，Go1.18开始提供了一个和空接口 <code>interface&#123;&#125;</code> 等价的新关键词 <code>any</code> ，用来使代码更简单：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T any] []T <span class="comment">// 代码等价于 type Slice[T interface&#123;&#125;] []T</span></span><br></pre></td></tr></table></figure>
实际上 <code>any</code> 的定义就位于Go语言的 <code>builtin.go</code> 文件中（参考如下）， <code>any</code> 实际上就是 <code>interaface&#123;&#125;</code> 的别名(alias)，两者完全等价<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// any is an alias for interface&#123;&#125; and is equivalent to interface&#123;&#125; in all ways.</span></span><br><span class="line"><span class="keyword">type</span> any = <span class="keyword">interface</span>&#123;&#125; </span><br></pre></td></tr></table></figure>
所以从 Go 1.18 开始，所有可以用到空接口的地方其实都可以直接替换为any，如：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []any <span class="comment">// 等价于 var s []interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]any <span class="comment">// 等价于 var m map[string]interface&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyPrint</span><span class="params">(value any)</span></span>&#123;</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果你高兴的话，项目迁移到 Go1.18 之后可以使用下面这行命令直接把整个项目中的空接口全都替换成 <code>any</code>。<br>当然因为并不强制，所以到底是用 <code>interface&#123;&#125;</code> 还是 <code>any</code> 全看自己喜好<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gofmt -w -r <span class="string">&#x27;interface&#123;&#125; -&gt; any&#x27;</span> ./...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Go语言项目中就曾经有人提出过把Go语言中所有 interface{} 替换成 any 的 <a href="https://github.com/golang/go/issues/49884">issue</a>，然后因为影响范围过大过而且影响因素不确定，理所当然被驳回了</p>
</blockquote>
</li>
</ul>
<h3 id="comparable-可比较-和-可排序-ordered"><a href="#comparable-可比较-和-可排序-ordered" class="headerlink" title="comparable(可比较) 和 可排序(ordered)"></a>comparable(可比较) 和 可排序(ordered)</h3><p>对于一些数据类型，我们需要在类型约束中限制只接受能 <code>!=</code> 和 <code>==</code> 对比的类型，如map：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误。因为 map 中键的类型必须是可进行 != 和 == 比较的类型</span></span><br><span class="line"><span class="keyword">type</span> MyMap[KEY any, VALUE any] <span class="keyword">map</span>[KEY]VALUE </span><br></pre></td></tr></table></figure>
<p>所以Go直接内置了一个叫 <code>comparable</code> 的接口，它代表了所有可用 <code>!=</code> 以及 <code>==</code> 对比的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMap[KEY comparable, VALUE any] <span class="keyword">map</span>[KEY]VALUE <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p><code>comparable</code> 比较容易引起误解的一点是很多人容易把他与可排序搞混淆。<br>可比较指的是 可以执行 <code>!=</code> <code>==</code> 操作的类型，并没确保这个类型可以执行大小比较（ <code>&gt;,&lt;,&lt;=,&gt;=</code> ）。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OhMyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b OhMyStruct</span><br><span class="line"></span><br><span class="line">a == b <span class="comment">// 正确。结构体可使用 == 进行比较</span></span><br><span class="line">a != b <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">a &gt; b <span class="comment">// 错误。结构体不可比大小</span></span><br></pre></td></tr></table></figure>
<p>而可进行大小比较的类型被称为 <code>Orderd</code> 。<br>目前Go语言并没有像 <code>comparable</code> 这样直接内置对应的关键词，所以想要的话需要自己来定义相关接口，比如我们可以参考Go官方包<code>golang.org/x/exp/constraints</code> 如何定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ordered 代表所有可比大小排序的类型</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">    Integer | Float | ~<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Signed | Unsigned</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里虽然可以直接使用官方包 golang.org&#x2F;x&#x2F;exp&#x2F;constraints ，但因为这个包属于实验性质的 x 包，今后可能会发生非常大变动，所以并不推荐直接使用</p>
</blockquote>
<h2 id="接口两种类型"><a href="#接口两种类型" class="headerlink" title="接口两种类型"></a>接口两种类型</h2><p>我们接下来再观察一个例子，这个例子是阐述接口是类型集最好的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">string</span> | ~[]<span class="type">rune</span></span><br><span class="line"></span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最开始看到这一例子你一定有点懵不太理解它代表的意思，但是没关系，我们用类型集的概念就能比较轻松理解这个接口的意思：</p>
<blockquote>
<p>接口类型 ReadWriter 代表了一个类型集合，所有以 string 或 []rune 为底层类型，并且实现了 Read() Write() 这两个方法的类型都在 ReadWriter 代表的类型集当中</p>
</blockquote>
<p>如下面代码中，<code>StringReadWriter</code> 存在于接口 <code>ReadWriter</code> 代表的类型集中，而 <code>BytesReadWriter</code> 因为底层类型是 <code>[]byte</code>（既不是<code>string</code>也是不<code>[]rune</code>） ，所以它不属于 <code>ReadWriter</code> 代表的类型集</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型 StringReadWriter 实现了接口 Readwriter</span></span><br><span class="line"><span class="keyword">type</span> StringReadWriter <span class="type">string</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringReadWriter)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringReadWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  类型BytesReadWriter 没有实现接口 Readwriter</span></span><br><span class="line"><span class="keyword">type</span> BytesReadWriter []<span class="type">byte</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s BytesReadWriter)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s BytesReadWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你一定会说，啊等等，这接口也变得太复杂了把，那我定义一个 ReadWriter 类型的接口变量，然后接口变量赋值的时候不光要考虑到方法的实现，还必须考虑到具体底层类型？<br>心智负担也太大了吧。是的，为了解决这个问题也为了保持Go语言的兼容性，Go1.18开始将接口分为了两种类型</p>
<ul>
<li>基本接口(Basic interface)</li>
<li>一般接口(General interface)</li>
</ul>
<h3 id="基本接口-Basic-interface"><a href="#基本接口-Basic-interface" class="headerlink" title="基本接口(Basic interface)"></a>基本接口(Basic interface)</h3><p>接口定义中如果只有方法的话，那么这种接口被称为基本接口(Basic interface)。<br>这种接口就是Go1.18之前的接口，用法也基本和Go1.18之前保持一致。基本接口大致可以用于如下几个地方：</p>
<h4 id="最常用的，定义接口变量并赋值"><a href="#最常用的，定义接口变量并赋值" class="headerlink" title="最常用的，定义接口变量并赋值"></a>最常用的，定义接口变量并赋值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">interface</span> &#123; <span class="comment">// 接口中只有方法，所以是基本接口</span></span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法和 Go1.18之前保持一致</span></span><br><span class="line"><span class="keyword">var</span> err MyError = fmt.Errorf(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="基本接口因为也代表了一个类型集，所以也可用在类型约束中"><a href="#基本接口因为也代表了一个类型集，所以也可用在类型约束中" class="headerlink" title="基本接口因为也代表了一个类型集，所以也可用在类型约束中"></a>基本接口因为也代表了一个类型集，所以也可用在类型约束中</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.Reader 和 io.Writer 都是基本接口，也可以用在类型约束中</span></span><br><span class="line"><span class="keyword">type</span> MySlice[T io.Reader | io.Writer]  []Slice</span><br></pre></td></tr></table></figure>

<h3 id="一般接口-General-interface"><a href="#一般接口-General-interface" class="headerlink" title="一般接口(General interface)"></a>一般接口(General interface)</h3><p>如果接口内不光只有方法，还有类型的话，这种接口被称为 <strong>一般接口(General interface)</strong> ，如下例子都是一般接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123; <span class="comment">// 接口 Uint 中有类型，所以是一般接口</span></span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;  <span class="comment">// ReadWriter 接口既有方法也有类型，所以是一般接口</span></span><br><span class="line">    ~<span class="type">string</span> | ~[]<span class="type">rune</span></span><br><span class="line"></span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般接口类型不能用来定义变量，只能用于泛型的类型约束中。所以以下的用法是错误的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uintInf Uint <span class="comment">// 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义</span></span><br></pre></td></tr></table></figure>
<p>这一限制保证了一般接口的使用被限定在了泛型之中，不会影响到Go1.18之前的代码，同时也极大减少了书写代码时的心智负担</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>所有类型的定义中都可以使用类型形参，所以接口定义自然也可以使用类型形参，观察下面这两个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DataProcessor[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(oriData T) (newData T)</span><br><span class="line">    Save(data T) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataProcessor2[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | ~<span class="keyword">struct</span>&#123; Data <span class="keyword">interface</span>&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">    Process(data T) (newData T)</span><br><span class="line">    Save(data T) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为引入了类型形参，所以这两个接口是泛型类型。<br>而泛型类型要使用的话必须传入类型实参实例化才有意义。<br>所以我们来尝试实例化一下这两个接口。因为 T 的类型约束是 any，所以可以随便挑一个类型来当实参(比如string)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">DataProcessor[<span class="type">string</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化之后的接口定义相当于如下所示：</span></span><br><span class="line"><span class="keyword">type</span> DataProcessor[<span class="type">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(oriData <span class="type">string</span>) (newData <span class="type">string</span>)</span><br><span class="line">    Save(data <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过实例化之后就好理解了， <code>DataProcessor[string]</code> 因为只有方法，所以它实际上就是个 <strong>基本接口(Basic interface)</strong> ，这个接口包含两个能处理string类型的方法。<br>像下面这样实现了这两个能处理string类型的方法就算实现了这个接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CSVProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，方法中 oriData 等的类型是 string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CSVProcessor)</span></span> Process(oriData <span class="type">string</span>) (newData <span class="type">string</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CSVProcessor)</span></span> Save(oriData <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CSVProcessor实现了接口 DataProcessor[string] ，所以可赋值</span></span><br><span class="line"><span class="keyword">var</span> processor DataProcessor[<span class="type">string</span>] = CSVProcessor&#123;&#125;  </span><br><span class="line">processor.Process(<span class="string">&quot;name,age\nbob,12\njack,30&quot;</span>)</span><br><span class="line">processor.Save(<span class="string">&quot;name,age\nbob,13\njack,31&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误。CSVProcessor没有实现接口 DataProcessor[int]</span></span><br><span class="line"><span class="keyword">var</span> processor2 DataProcessor[<span class="type">int</span>] = CSVProcessor&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>再用同样的方法实例化 DataProcessor2[T] ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">DataProcessor2[<span class="type">string</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化后的接口定义可视为</span></span><br><span class="line"><span class="keyword">type</span> DataProcessor2[T <span class="type">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | ~<span class="keyword">struct</span>&#123; Data <span class="keyword">interface</span>&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">    Process(data <span class="type">string</span>) (newData <span class="type">string</span>)</span><br><span class="line">    Save(data <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DataProcessor2[string]</code> 因为带有类型并集所以它是 <strong>一般接口(General interface)</strong> ，所以实例化之后的这个接口代表的意思是：</p>
<ul>
<li>只有实现了 <code>Process(string) string</code> 和 <code>Save(string) error</code> 这两个方法，并且以 <code>int</code> 或 <code>struct&#123; Data interface&#123;&#125; &#125;</code> 为底层类型的类型才算实现了这个接口</li>
<li><code>一般接口(General interface)</code> 不能用于变量定义只能用于类型约束，所以接口 <code>DataProcessor2[string]</code> 只是定义了一个用于类型约束的类型集<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XMLProcessor 虽然实现了接口 DataProcessor2[string] 的两个方法，但是因为它的底层类型是 []byte，所以依旧是未实现 DataProcessor2[string]</span></span><br><span class="line"><span class="keyword">type</span> XMLProcessor []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c XMLProcessor)</span></span> Process(oriData <span class="type">string</span>) (newData <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c XMLProcessor)</span></span> Save(oriData <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JsonProcessor 实现了接口 DataProcessor2[string] 的两个方法，同时底层类型是 struct&#123; Data interface&#123;&#125; &#125;。所以实现了接口 DataProcessor2[string]</span></span><br><span class="line"><span class="keyword">type</span> JsonProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c JsonProcessor)</span></span> Process(oriData <span class="type">string</span>) (newData <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c JsonProcessor)</span></span> Save(oriData <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误。DataProcessor2[string]是一般接口不能用于创建变量</span></span><br><span class="line"><span class="keyword">var</span> processor DataProcessor2[<span class="type">string</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，实例化之后的 DataProcessor2[string] 可用于泛型的类型约束</span></span><br><span class="line"><span class="keyword">type</span> ProcessorList[T DataProcessor2[<span class="type">string</span>]] []T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，接口可以并入其他接口</span></span><br><span class="line"><span class="keyword">type</span> StringProcessor <span class="keyword">interface</span> &#123;</span><br><span class="line">    DataProcessor2[<span class="type">string</span>]</span><br><span class="line"></span><br><span class="line">    PrintString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，带方法的一般接口不能作为类型并集的成员(参考6.5 接口定义的种种限制规则</span></span><br><span class="line"><span class="keyword">type</span> StringProcessor <span class="keyword">interface</span> &#123;</span><br><span class="line">    DataProcessor2[<span class="type">string</span>] | DataProcessor2[[]<span class="type">byte</span>]</span><br><span class="line"></span><br><span class="line">    PrintString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口定义的种种限制规则"><a href="#接口定义的种种限制规则" class="headerlink" title="接口定义的种种限制规则"></a>接口定义的种种限制规则</h2><p>Go1.18从开始，在定义类型集(接口)的时候增加了非常多十分琐碎的限制规则，其中很多规则都在之前的内容中介绍过了，但剩下还有一些规则因为找不到好的地方介绍，所以在这里统一介绍下：</p>
<h3 id="用-连接多个类型的时候，类型之间不能有相交的部分-即必须是不交集"><a href="#用-连接多个类型的时候，类型之间不能有相交的部分-即必须是不交集" class="headerlink" title="用 | 连接多个类型的时候，类型之间不能有相交的部分(即必须是不交集):"></a>用 <code>|</code> 连接多个类型的时候，类型之间不能有相交的部分(即必须是不交集):</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，MyInt的底层类型是int,和 ~int 有相交的部分</span></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | MyInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是相交的类型中是接口的话，则不受这一限制：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | <span class="keyword">interface</span>&#123; MyInt &#125;  <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span>&#123; ~<span class="type">int</span> &#125; | MyInt <span class="comment">// 也正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span>&#123; ~<span class="type">int</span> &#125; | <span class="keyword">interface</span>&#123; MyInt &#125;  <span class="comment">// 也正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型的并集中不能有类型形参"><a href="#类型的并集中不能有类型形参" class="headerlink" title="类型的并集中不能有类型形参"></a>类型的并集中不能有类型形参</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInf[T ~<span class="type">int</span> | ~<span class="type">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | T  <span class="comment">// 错误。T是类型形参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInf2[T ~<span class="type">int</span> | ~<span class="type">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    T  <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口不能直接或间接地并入自己"><a href="#接口不能直接或间接地并入自己" class="headerlink" title="接口不能直接或间接地并入自己"></a>接口不能直接或间接地并入自己</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bad <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bad <span class="comment">// 错误，接口不能直接并入自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad2 <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bad1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad1 <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bad2 <span class="comment">// 错误，接口Bad1通过Bad2间接并入了自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">string</span> | Bad3 <span class="comment">// 错误，通过类型的并集并入了自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的并集成员个数大于一的时候不能直接或间接并入-comparable-接口"><a href="#接口的并集成员个数大于一的时候不能直接或间接并入-comparable-接口" class="headerlink" title="接口的并集成员个数大于一的时候不能直接或间接并入 comparable 接口"></a>接口的并集成员个数大于一的时候不能直接或间接并入 comparable 接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OK <span class="keyword">interface</span> &#123;</span><br><span class="line">    comparable <span class="comment">// 正确。只有一个类型的时候可以使用 comparable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad1 <span class="keyword">interface</span> &#123;</span><br><span class="line">    []<span class="type">int</span> | comparable <span class="comment">// 错误，类型并集不能直接并入 comparable 接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CmpInf <span class="keyword">interface</span> &#123;</span><br><span class="line">    comparable</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad2 <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">chan</span> <span class="type">int</span> | CmpInf  <span class="comment">// 错误，类型并集通过 CmpInf 间接并入了comparable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">chan</span> <span class="type">int</span> | <span class="keyword">interface</span>&#123;comparable&#125;  <span class="comment">// 理所当然，这样也是不行的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带方法的接口-无论是基本接口还是一般接口-，都不能写入接口的并集中："><a href="#带方法的接口-无论是基本接口还是一般接口-，都不能写入接口的并集中：" class="headerlink" title="带方法的接口(无论是基本接口还是一般接口)，都不能写入接口的并集中："></a>带方法的接口(无论是基本接口还是一般接口)，都不能写入接口的并集中：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">string</span> | <span class="type">error</span> <span class="comment">// 错误，error是带方法的接口(一般接口) 不能写入并集中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataProcessor[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">string</span> | ~[]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">    Process(data T) (newData T)</span><br><span class="line">    Save(data T) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，实例化之后的 DataProcessor[string] 是带方法的一般接口，不能写入类型并集</span></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">string</span> | DataProcessor[<span class="type">string</span>] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">string</span> | DataProcessor[T]  <span class="comment">// 也不行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，终于是从头到位把Go1.18的泛型给介绍完毕了。<br>因为Go这次引入泛型带入了挺大的复杂度，也增加了挺多比较零散琐碎的规则限制。<br>所以写这篇文章断断续续花了我差不多一星期时间。<br>泛型虽然很受期待，但实际上推荐的使用场景也并没有那么广泛，对于泛型的使用，我们应该遵守下面的规则：</p>
<blockquote>
<p>泛型并不取代Go1.18之前用接口+反射实现的动态类型，在下面情景的时候非常适合使用泛型：当你需要针对不同类型书写同样的逻辑，使用泛型来简化代码是最好的 (比如你想写个队列，写个链表、栈、堆之类的数据结构）</p>
</blockquote>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>slice</tag>
        <tag>go1.18</tag>
        <tag>specification</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（一）- K8S介绍</title>
    <url>/2022/03/06/k8s-study-notes-1/</url>
    <content><![CDATA[<h1 id="应用部署方式的演变"><a href="#应用部署方式的演变" class="headerlink" title="应用部署方式的演变"></a>应用部署方式的演变</h1><h2 id="传统部署"><a href="#传统部署" class="headerlink" title="传统部署"></a>传统部署</h2><blockquote>
<p>互联网早期，会直接将应用部署在物理机上</p>
</blockquote>
<ul>
<li>优点：简单，不需要其他的技术参与。</li>
<li>缺点：不能为应用程序定义资源的使用边界，很难合理的分配计算机资源，而且程序之间容易产生影响。</li>
</ul>
<h2 id="虚拟化部署"><a href="#虚拟化部署" class="headerlink" title="虚拟化部署"></a>虚拟化部署</h2><blockquote>
<p>可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p>
</blockquote>
<ul>
<li>优点：程序环境不会相互产生影响，提供了一定程序上的安全性。</li>
<li>缺点：增加了操作系统，浪费了部分资源。</li>
</ul>
<h2 id="容器化部署"><a href="#容器化部署" class="headerlink" title="容器化部署"></a>容器化部署</h2><blockquote>
<p>和虚拟化类似，但是共享了操作系统 </p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以保证每个容器拥有自己的文件系统、CPU 、内存和进程空间等</li>
<li>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</li>
<li>容器化的应用程序可以跨云服务商、跨 Linux 操作系统发行版进行部署</li>
</ul>
<h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h3><ul>
<li>一旦容器故障停机了，怎么让另外一个容器立刻启动去替补停机的容器</li>
<li>当并发访问量变大的时候，怎么做到横向扩展容器数量</li>
<li>其实就是<code>容器编排问题</code>……</li>
</ul>
<h3 id="由问题而产生的编排工具"><a href="#由问题而产生的编排工具" class="headerlink" title="由问题而产生的编排工具"></a>由问题而产生的编排工具</h3><ul>
<li><code>Swarm</code>：Docker 自己的容器编排工具</li>
<li><code>Mesos</code>：Apache 的一个资源统一管控的工具，需要和 Marathon 结合</li>
<li><code>Kubernetes</code>：Google 开源的容器编排工具</li>
</ul>
<h1 id="K8S组件"><a href="#K8S组件" class="headerlink" title="K8S组件"></a>K8S组件</h1><blockquote>
<p>一个 kubernetes 集群主要由控制节点（master）、工作节点（node）构成，每个节点上都会安装不同的组件<br><img src="/1.png" alt="1"></p>
</blockquote>
<h2 id="控制节点（master）"><a href="#控制节点（master）" class="headerlink" title="控制节点（master）"></a>控制节点（master）</h2><ul>
<li>API Server：集群操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制。</li>
<li>Scheduler：负责集群资源调度，按照预定的调度策略将 Pod 调度到相应的 node 节点上。</li>
<li>ControllerManager：负责维护集群的状态，比如程序部署安排、故障检测、自动扩展和滚动更新等。</li>
<li>Etcd：负责存储集群中各种资源对象的信息。</li>
</ul>
<h2 id="工作节点（node）"><a href="#工作节点（node）" class="headerlink" title="工作节点（node）"></a>工作节点（node）</h2><ul>
<li>Kubelet：负责维护容器的生命周期，即通过控制 Docker ，来创建、更新、销毁容器。</li>
<li>KubeProxy：负责提供集群内部的服务发现和负载均衡。</li>
<li>Docker：负责节点上容器的各种操作。</li>
</ul>
<h2 id="组件调用事例"><a href="#组件调用事例" class="headerlink" title="组件调用事例"></a>组件调用事例</h2><blockquote>
<p>以部署一个 Nginx 服务来说明 Kubernetes 系统各个组件调用关系</p>
</blockquote>
<ol>
<li>首先需要明确，一旦 Kubernetes 环境启动之后，master 和 node 都会将自身的信息存储到etcd数据库中</li>
<li>一个Nginx服务的安装请求首先会被发送到 master 节点上的 API Server 组件。</li>
<li>API Server 组件会调用 Scheduler 组件来决定到底应该把这个服务安装到那个 node 节点上。此时，它会从 etcd 中读取各个 node 节点的信息，然后按照一定的算法进行选择，并将结果告知 API Server。</li>
<li>API Server 调用 Controller-Manager 去调用 Node 节点安装 Nginx 服务。</li>
<li>Kubelet 接收到指令后，会通知 Docker ，然后由 Docker 来启动一个 Nginx 的 Pod 。Pod 是 Kubernetes 的最小操作单元，容器必须跑在 Pod 中。</li>
<li>一个 Nginx 服务就运行了，如果需要访问 Nginx ，就需要通过 kube-proxy 来对 Pod 产生访问的代理，这样，外界用户就可以访问集群中的 Nginx 服务了。</li>
</ol>
<h1 id="K8S概念"><a href="#K8S概念" class="headerlink" title="K8S概念"></a>K8S概念</h1><ul>
<li>Master：集群控制节点，每个集群要求至少有一个 Master 节点来负责集群的管控。</li>
<li>Node：工作负载节点，由 Master 分配容器到这些 Node 工作节点上，然后 Node 节点上的 Docker 负责容器的运行。</li>
<li>Pod：Kubernetes 的最小控制单元，容器都是运行在 Pod 中的，一个 Pod 中可以有一个或多个容器。</li>
<li>Controller：控制器，通过它来实现对 Pod 的管理，比如启动 Pod 、停止 Pod 、伸缩 Pod 的数量等等。</li>
<li>Service：Pod 对外服务的统一入口，其下面可以维护同一类的多个 Pod 。</li>
<li>Label：标签，用于对 Pod 进行分类，同一类 Pod 会拥有相同的标签。</li>
<li>NameSpace：命名空间，用来隔离 Pod 的运行环境。</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（十）- K8S Pod详解 - 服务质量Qos</title>
    <url>/2022/03/24/k8s-study-notes-10/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Kubernetes 使用 QoS 类来决定 Pod 的调度和驱逐策略。<br>kubernetes 创建Pod的时候就会指定QoS。<br>QoS分为如下的三类：</p>
<ul>
<li>① Guaranteed</li>
<li>② Burstable</li>
<li>③ BestEffort</li>
</ul>
<h1 id="Qos之Guaranteed"><a href="#Qos之Guaranteed" class="headerlink" title="Qos之Guaranteed"></a>Qos之Guaranteed</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>对于 QoS 类为 Guaranteed 的 Pod：</p>
<ul>
<li>Pod 中的每个容器，包含初始化容器，必须指定内存请求和内存限制，并且两者要相等。</li>
<li>Pod 中的每个容器，包含初始化容器，必须指定 CPU 请求和 CPU 限制，并且两者要相等。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建qos-demo.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">qos-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">qos-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">qos-demo-ctr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;200Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;700m&quot;</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;200Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;700m&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f qos-demo.yaml </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod qos-demo -n qos-example -o yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">kubectl delete -f qos-demo.yaml</span><br></pre></td></tr></table></figure>

<h1 id="Qos之Burstable"><a href="#Qos之Burstable" class="headerlink" title="Qos之Burstable"></a>Qos之Burstable</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>如果满足下面条件，将会指定 Pod 的 QoS 类为 Burstable：</p>
<ul>
<li>Pod 不符合 Guaranteed QoS 类的标准。</li>
<li>Pod 中至少一个容器具有内存或 CPU 请求，但是值不相等。</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>创建qos-demo-2.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">qos-demo-2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">qos-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">qos-demo-2-ctr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;200Mi&quot;</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;100Mi&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f qos-demo-2.yaml </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod qos-demo-2 -n qos-example -o yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">kubectl delete -f qos-demo2.yaml</span><br></pre></td></tr></table></figure>

<h1 id="Qos之BestEffort"><a href="#Qos之BestEffort" class="headerlink" title="Qos之BestEffort"></a>Qos之BestEffort</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>对于 QoS 类为 BestEffort 的 Pod，Pod 中的容器必须没有设置内存和 CPU 限制或请求。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>创建qos-demo-3.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">qos-demo-3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">qos-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">qos-demo-3-ctr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f qos-demo-3.yaml </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">kubectl get pod qos-demo-3 -n qos-example -o yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">kubectl delete -f qos-demo3.yaml</span><br></pre></td></tr></table></figure>

<h1 id="Qos的应用"><a href="#Qos的应用" class="headerlink" title="Qos的应用"></a>Qos的应用</h1><p>一旦出现OOM，kubernetes为了保证服务的可用，会先删除QoS为BestEffort的Pod，然后删除QoS为Burstable的Pod，最后删除QoS为Guaranteed 的Pod。</p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（十一）- K8S Pod控制器详解</title>
    <url>/2022/03/27/k8s-study-notes-11/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>在kubernetes中，按照Pod的创建方式可以将其分为两类：<ul>
<li>自主式Pod：kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建。 </li>
<li>控制器创建Pod：通过Pod控制器创建的Pod，这种Pod删除之后还会自动重建。</li>
</ul>
</li>
<li>Pod控制器：Pod控制器是管理Pod的中间层，使用了Pod控制器之后，我们只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它就会创建出满足条件的Pod并确保每一个Pod处于用户期望的状态，如果Pod在运行中出现故障，控制器会基于指定的策略重启或重建Pod。</li>
<li>在kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些：<ul>
<li>ReplicaSet：保证指定数量的Pod运行，并支持Pod数量变更。</li>
<li>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、版本回退。</li>
<li>Horizontal Pod Autoscaler：可以根据集群负载自动调整Pod的数量，实现削峰填谷。</li>
<li>DaemonSet：在集群中的指定Node上都运行一个副本，一般用于守护进程类的任务。</li>
<li>Job：它创建出来的Pod只要完成任务就立即退出，用于执行一次性任务。</li>
<li>CronJob：它创建的Pod会周期性的执行，用于执行周期性的任务。</li>
<li>StatefulSet：管理有状态的应用。</li>
</ul>
</li>
</ul>
<h1 id="ReplicaSet（RS）"><a href="#ReplicaSet（RS）" class="headerlink" title="ReplicaSet（RS）"></a>ReplicaSet（RS）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ReplicaSet的主要作用是保证一定数量的Pod能够正常运行，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。<br>同时它还支持对Pod数量的扩缩容。<br><img src="/1.png" alt="1"></p>
<p>ReplicaSet的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号 </span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span> <span class="comment"># 类型 </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据 </span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签 </span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">rs</span> </span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述 </span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量 </span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些po</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则 </span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span> </span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则 </span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125; </span><br><span class="line"><span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本 </span></span><br><span class="line">  <span class="attr">metadata:</span> </span><br><span class="line">    <span class="attr">labels:</span> </span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span> </span><br><span class="line">  <span class="attr">spec:</span> </span><br><span class="line">    <span class="attr">containers:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> </span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>在这里，需要新了解的配置项就是spec下面几个选项:</p>
<ul>
<li>replicas：指定副本数量，其实就是当然rs创建出来的Pod的数量，默认为1.</li>
<li>selector：选择器，它的作用是建立Pod控制器和Pod之间的关联关系，采用了Label Selector机制（在Pod模块上定义Label，在控制器上定义选择器，就可以表明当前控制器能管理哪些Pod了）。</li>
<li>template：模板，就是当前控制器创建Pod所使用的模板，里面其实就是前面学过的Pod的定义。</li>
</ul>
<h2 id="创建ReplicaSet"><a href="#创建ReplicaSet" class="headerlink" title="创建ReplicaSet"></a>创建ReplicaSet</h2><p>创建pc-replicaset.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-replicaset</span> <span class="comment"># rs名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名类型</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详细描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器可以管理哪些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模块 当副本数据不足的时候，会根据下面的模板创建Pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器所监听的端口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">kubectl create -f pc-replicaset.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get rs pc-replicaset -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前控制器创建出来的Pod（控制器创建出来的Pod的名称是在控制器名称后面拼接了-xxx随机码）</span></span><br><span class="line">kubectl get pod -n dev</span><br></pre></td></tr></table></figure>

<h2 id="扩缩容"><a href="#扩缩容" class="headerlink" title="扩缩容"></a>扩缩容</h2><p>编辑rs的副本数量，修改spec:replicas:6即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl edit rs pc-replicaset -n dev</span><br></pre></td></tr></table></figure>

<p>使用scale命令实现扩缩容，后面加上–replicas&#x3D;n直接指定目标数量即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl scale rs pc-replicaset --replicas=2 -n dev</span><br></pre></td></tr></table></figure>

<h2 id="删除ReplicaSet"><a href="#删除ReplicaSet" class="headerlink" title="删除ReplicaSet"></a>删除ReplicaSet</h2><p>使用kubectl delete rs 命令会删除ReplicaSet和其管理的Pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在kubernetes删除ReplicaSet前，会将ReplicaSet的replicas调整为0，等到所有的Pod被删除后，再执行ReplicaSet对象的删除</span></span><br><span class="line">kubectl delete rs pc-replicaset -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果希望仅仅删除ReplicaSet对象（保留Pod），只需要在使用kubectl delete rs命令的时候添加--cascade=<span class="literal">false</span>选项（不推荐）：</span></span><br><span class="line">kubectl delete rs pc-replicaset -n dev --cascade=false</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用yaml直接删除（推荐）：</span></span><br><span class="line">kubectl delete -f pc-replicaset.yaml</span><br></pre></td></tr></table></figure>

<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>为了更好的解决服务编排的问题，kubernetes在v1.2版本开始，引入了Deployment控制器。<br>值得一提的是，Deployment控制器并不直接管理Pod，而是通过管理ReplicaSet来间接管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。<br>所以Deployment的功能比ReplicaSet强大。<br><img src="/2.png" alt="2"></p>
<p>Deployment的主要功能如下：</p>
<ul>
<li>支持ReplicaSet的所有功能</li>
<li>支持发布的停止、继续</li>
<li>支持版本滚动更新和版本回退</li>
</ul>
<p>Deployment的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号 </span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型 </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据 </span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># deployment名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签 </span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">deploy</span> </span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述 </span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量 </span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本，默认为10 </span></span><br><span class="line">  <span class="attr">paused:</span> <span class="literal">false</span> <span class="comment"># 暂停部署，默认是false </span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span> <span class="comment"># 部署超时时间（s），默认是600 </span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略 </span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略 </span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新 </span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数 maxUnavailable: 30% # 最大不可用状态的    Pod 的最大值，可以为百分比，也可以为整数 </span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod </span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则 </span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span> </span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则 </span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125; </span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本 </span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span> </span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span> </span><br><span class="line">    <span class="attr">spec:</span> </span><br><span class="line">      <span class="attr">containers:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> </span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h2 id="创建Deployment"><a href="#创建Deployment" class="headerlink" title="创建Deployment"></a>创建Deployment</h2><p>创建pc-deployment.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span> <span class="comment"># deployment的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名类型</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详细描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器可以管理哪些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模块 当副本数据不足的时候，会根据下面的模板创建Pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器所监听的端口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">kubectl create -f pc-deployment.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">UP-TO-DATE 最新版本的Pod数量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AVAILABLE 当前可用的Pod数量</span></span><br><span class="line">kubectl get deploy pc-deployment -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ReplicaSet：</span></span><br><span class="line">kubectl get rs -n dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">kubectl get pod -n dev</span><br></pre></td></tr></table></figure>

<h2 id="扩散容"><a href="#扩散容" class="headerlink" title="扩散容"></a>扩散容</h2><p>编辑Deployment的副本数量，修改spec:replicas:4即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl edit deployment pc-deployment -n dev</span><br></pre></td></tr></table></figure>

<p>使用scale命令实现扩缩容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl scale deploy pc-deployment --replicas=5 -n dev</span><br></pre></td></tr></table></figure>

<h2 id="镜像更新"><a href="#镜像更新" class="headerlink" title="镜像更新"></a>镜像更新</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p>Deployment支持两种镜像更新的策略：重建更新和滚动更新（默认），可以通过strategy选项进行配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">strategy:</span> <span class="string">指定新的Pod替代旧的Pod的策略，支持两个属性</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">指定策略类型，支持两种策略</span></span><br><span class="line">    <span class="string">Recreate：在创建出新的Pod之前会先杀掉所有已经存在的Pod</span></span><br><span class="line">    <span class="string">RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本的Pod</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">rollingUpdate：当type为RollingUpdate的时候生效，用于为rollingUpdate设置参数，支持两个属性：</span></span><br><span class="line">    <span class="string">maxUnavailable：用来指定在升级过程中不可用的Pod的最大数量，默认为25%。</span></span><br><span class="line">    <span class="string">maxSurge：</span> <span class="string">用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。</span></span><br></pre></td></tr></table></figure>

<h3 id="重建更新"><a href="#重建更新" class="headerlink" title="重建更新"></a>重建更新</h3><p>编辑pc-deployment.yaml文件，在spec节点下添加更新策略</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span> <span class="comment"># deployment的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名类型</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详细描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 镜像更新策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span> <span class="comment"># Recreate：在创建出新的Pod之前会先杀掉所有已经存在的Pod</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器可以管理哪些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模块 当副本数据不足的时候，会根据下面的模板创建Pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器所监听的端口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新</span></span><br><span class="line">kubectl apply -f pc-deployment.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">镜像升级</span></span><br><span class="line">kubectl set image deployment pc-deployment nginx=nginx:1.17.2 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod -n dev -w</span><br></pre></td></tr></table></figure>

<h3 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h3><p>编辑pc-deployment.yaml文件，在spec节点下添加更新策略：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span> <span class="comment"># deployment的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名类型</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详细描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 镜像更新策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本的Pod</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器可以管理哪些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模块 当副本数据不足的时候，会根据下面的模板创建Pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器所监听的端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新</span></span><br><span class="line">kubectl apply -f pc-deployment.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">镜像升级</span></span><br><span class="line">kubectl set image deployment pc-deployment nginx=nginx:1.17.3 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod -n dev -w</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看rs，发现原来的rs依旧存在，只是Pod的数量变为0，而后又产生了一个rs，Pod的数量变为3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实这就是deployment能够进行版本回退的奥妙所在</span></span><br><span class="line">kubectl get rs -n dev</span><br></pre></td></tr></table></figure>
<p>滚动更新的过程:<br><img src="/3.png" alt="3"></p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>Deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 版本升级相关功能</span></span><br><span class="line"><span class="string">kubetl</span> <span class="string">rollout</span> <span class="string">参数</span> <span class="string">deploy</span> <span class="string">xx</span>  <span class="comment"># 支持下面的选择</span></span><br><span class="line"><span class="comment"># status 显示当前升级的状态</span></span><br><span class="line"><span class="comment"># history 显示升级历史记录</span></span><br><span class="line"><span class="comment"># pause 暂停版本升级过程</span></span><br><span class="line"><span class="comment"># resume 继续已经暂停的版本升级过程</span></span><br><span class="line"><span class="comment"># restart 重启版本升级过程</span></span><br><span class="line"><span class="comment"># undo 回滚到上一级版本 （可以使用--to-revision回滚到指定的版本）</span></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前升级版本的状态</span></span><br><span class="line">kubectl rollout status deployment pc-deployment -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看升级历史记录</span></span><br><span class="line">kubectl rollout history deployment pc-deployment -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">版本回退</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以使用-to-revision=1回退到1版本，如果省略这个选项，就是回退到上个版本，即2版本</span></span><br><span class="line">kubectl rollout undo deployment pc-deployment --to-revision=1 -n dev</span><br></pre></td></tr></table></figure>

<h2 id="删除Deployment"><a href="#删除Deployment" class="headerlink" title="删除Deployment"></a>删除Deployment</h2><p>删除Deployment，其下的ReplicaSet和Pod也会一起被删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl delete -f pc-deployment.yaml</span><br></pre></td></tr></table></figure>

<h1 id="Horizontal-Pod-Autoscaler-（HPA）"><a href="#Horizontal-Pod-Autoscaler-（HPA）" class="headerlink" title="Horizontal Pod Autoscaler （HPA）"></a>Horizontal Pod Autoscaler （HPA）</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>我们已经可以通过手动执行kubectl scale命令实现Pod的扩缩容，但是这显然不符合kubernetes的定位目标–自动化和智能化。<br>kubernetes期望可以通过监测Pod的使用情况，实现Pod数量的自动调整，于是就产生了HPA这种控制器。</p>
<p>HPA可以获取每个Pod的利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。<br>其实HPA和之前的Deployment一样，也属于一种kubernetes资源对象，它通过追踪分析目标Pod的负载变化情况，来确定是否需要针对性的调整目标Pod的副本数。<br><img src="/4.png" alt="4"></p>
<h2 id="安装metrics-server"><a href="#安装metrics-server" class="headerlink" title="安装metrics-server"></a>安装metrics-server</h2><blockquote>
<p>HPA需要通过监控数据进行计算是否需要扩所容<br>获取metrics-server：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.4.1/components.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">spec.template.spec.containers.args 添加</span> </span><br><span class="line">- --kubelet-insecure-tls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改国内image</span></span><br><span class="line">registry.aliyuncs.com/google_containers/metrics-server:v0.4.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">kubectl apply -f components.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get deployment metrics-server -n kube-system</span><br></pre></td></tr></table></figure>

<h2 id="准备Deployment和Service"><a href="#准备Deployment和Service" class="headerlink" title="准备Deployment和Service"></a>准备Deployment和Service</h2><p>创建Deployment, nginx.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># deployment的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名类型</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详细描述</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器可以管理哪些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模块 当副本数据不足的时候，会根据下面的模板创建Pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器所监听的端口</span></span><br><span class="line">          <span class="attr">resources:</span> <span class="comment"># 资源限制</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;100m&quot;</span> <span class="comment"># 100m表示100millicpu，即0.1个CPU</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f nginx.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod,deploy -n dev</span><br></pre></td></tr></table></figure>

<p>创建Service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx --name=nginx --type=NodePort --port=80 --target-port=80 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get svc -n dev</span><br></pre></td></tr></table></figure>

<h2 id="部署HPA"><a href="#部署HPA" class="headerlink" title="部署HPA"></a>部署HPA</h2><p>创建pc-hpa.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-hpa</span> <span class="comment"># deployment的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名类型</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span> <span class="comment"># 最小Pod数量</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span> <span class="comment"># 最大Pod数量</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">3</span> <span class="comment"># CPU使用率指标</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>  <span class="comment"># 指定要控制的Nginx的信息</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建hpa</span></span><br><span class="line">kubectl create -f pc-hpa.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get hpa -n dev</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不断访问nginx服务，让cpu使用率高于3%</span></span><br><span class="line">while true;do curl 172.16.7.200:30370 &gt; /dev/null;sleep 0.01s;done</span><br></pre></td></tr></table></figure>

<p>cpu使用率上升，副本数量口容到3<br><img src="/5.png" alt="5"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看deployment</span> </span><br><span class="line">kubectl get deploy -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看详情</span></span><br><span class="line">kubectl describe deploy nginx -n dev</span><br></pre></td></tr></table></figure>
<p><img src="/6.png" alt="6"><br><img src="/7.png" alt="7"></p>
<h1 id="DaemonSet（DS）"><a href="#DaemonSet（DS）" class="headerlink" title="DaemonSet（DS）"></a>DaemonSet（DS）</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>DaemonSet类型的控制器可以保证集群中的每一台（或指定）节点上都运行一个副本，一般适用于日志收集、节点监控等场景。<br>也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。<br><img src="/8.png" alt="8"><br>DaemonSet控制器的特点：</p>
<ul>
<li>每向集群中添加一个节点的时候，指定的Pod副本也将添加到该节点上。</li>
<li>当节点从集群中移除的时候，Pod也会被垃圾回收。</li>
</ul>
<p>DaemonSet的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment">#命名空间</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">daemonset</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">updateStrategy:</span> <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 最大不可用状态的Pod的最大值，可用为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理那些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建Pod模板</span></span><br><span class="line">     <span class="attr">metadata:</span></span><br><span class="line">       <span class="attr">labels:</span></span><br><span class="line">         <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">     <span class="attr">spec:</span></span><br><span class="line">       <span class="attr">containers:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">           <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">           <span class="attr">ports:</span></span><br><span class="line">             <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h2 id="创建DaemonSet"><a href="#创建DaemonSet" class="headerlink" title="创建DaemonSet"></a>创建DaemonSet</h2><p>创建pc-daemonset.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-damonset</span> <span class="comment"># 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment">#命名空间</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理那些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建Pod模板</span></span><br><span class="line">     <span class="attr">metadata:</span></span><br><span class="line">       <span class="attr">labels:</span></span><br><span class="line">         <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">     <span class="attr">spec:</span></span><br><span class="line">       <span class="attr">containers:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">           <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">           <span class="attr">ports:</span></span><br><span class="line">             <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pc-daemonset.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span> </span><br><span class="line">kubectl get ds -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">kubectl delete ds pc-damonset -n dev</span><br></pre></td></tr></table></figure>

<h1 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h2><p>Job主要用于负责批量处理短暂的一次性任务<br>Job可以保证指定数量的Pod执行完成<br>Job的特点：</p>
<ul>
<li>当Job创建的Pod执行成功结束时，Job将记录成功结束的Pod数量。</li>
<li>当成功结束的Pod达到指定的数量时，Job将完成执行。</li>
</ul>
<p><img src="/9.png" alt="9"><br>Job的资源清单:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="comment"># 名称</span></span><br><span class="line">  <span class="attr">namespace:</span>  <span class="comment">#命名空间</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment"># 标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">job</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">1</span> <span class="comment"># 指定Job需要成功运行Pod的总次数，默认为1</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">1</span> <span class="comment"># 指定Job在任一时刻应该并发运行Pod的数量，默认为1</span></span><br><span class="line">  <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span> <span class="comment"># 指定Job可以运行的时间期限，超过时间还没结束，系统将会尝试进行终止</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">6</span> <span class="comment"># 指定Job失败后进行重试的次数，默认为6</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span> <span class="comment"># 是否可以使用selector选择器选择Pod，默认为false</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理那些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">counter-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建Pod模板</span></span><br><span class="line">     <span class="attr">metadata:</span></span><br><span class="line">       <span class="attr">labels:</span></span><br><span class="line">         <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">     <span class="attr">spec:</span></span><br><span class="line">       <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略只能设置为Never或OnFailure</span></span><br><span class="line">       <span class="attr">containers:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">           <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">           <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1;do echo $i;sleep 20;done&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>关于模板中的重启策略的说明：</p>
<ul>
<li>如果设置为OnFailure，则Job会在Pod出现故障的时候重启容器，而不是创建Pod，failed次数不变。</li>
<li>如果设置为Never，则Job会在Pod出现故障的时候创建新的Pod，并且故障Pod不会消失，也不会重启，failed次数+1。</li>
<li>如果指定为Always的话，就意味着一直重启，意味着Pod任务会重复执行，这和Job的定义冲突，所以不能设置为Always。</li>
</ul>
<p>创建pc-job.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-job</span> <span class="comment"># 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment">#命名空间</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span> <span class="comment"># 是否可以使用selector选择器选择Pod，默认为false</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理那些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建Pod模板</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略只能设置为Never或OnFailure</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">          <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1;do echo $i;sleep 3;done&quot;</span> ]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pc-job.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get job -n dev -w</span><br><span class="line">kubectl get pod -n dev -w</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">kubectl delete -f pc-job.yaml</span><br></pre></td></tr></table></figure>

<h1 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h1><p>CronJob控制器以Job控制器为其管控对象，并借助它管理Pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，<br>但CronJob可以以类似Linux操作系统的周期性任务作业计划的方式控制器运行时间点及重复运行的方式，换言之，CronJob可以在特定的时间点反复去执行Job任务。<br><img src="/10.png" alt="10"><br>CronJob的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="comment"># 名称</span></span><br><span class="line">  <span class="attr">namespace:</span>  <span class="comment">#命名空间</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="comment"># cron格式的作业调度运行时间点，用于控制任务任务时间执行</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="comment"># 并发执行策略</span></span><br><span class="line">  <span class="attr">failedJobsHistoryLimit:</span> <span class="comment"># 为失败的任务执行保留的历史记录数，默认为1</span></span><br><span class="line">  <span class="attr">successfulJobsHistoryLimit:</span> <span class="comment"># 为成功的任务执行保留的历史记录数，默认为3</span></span><br><span class="line">  <span class="attr">jobTemplate:</span> <span class="comment"># job控制器模板，用于为cronjob控制器生成job对象，下面其实就是job的定义</span></span><br><span class="line">    <span class="attr">metadata:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">completions:</span> <span class="number">1</span> <span class="comment"># 指定Job需要成功运行Pod的总次数，默认为1</span></span><br><span class="line">      <span class="attr">parallelism:</span> <span class="number">1</span> <span class="comment"># 指定Job在任一时刻应该并发运行Pod的数量，默认为1</span></span><br><span class="line">      <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span> <span class="comment"># 指定Job可以运行的时间期限，超过时间还没结束，系统将会尝试进行终止</span></span><br><span class="line">      <span class="attr">backoffLimit:</span> <span class="number">6</span> <span class="comment"># 指定Job失败后进行重试的次数，默认为6</span></span><br><span class="line">      <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建Pod模板</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略只能设置为Never或OnFailure</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">              <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1;do echo $i;sleep 20;done&quot;</span> ]</span><br></pre></td></tr></table></figure>
<p>schedule：cron表达式，用于指定任务的执行时间。</p>
<ul>
<li>*&#x2F;1  *  *  *  *：表示分钟  小时  日  月份  星期。</li>
<li>分钟的值从0到59。</li>
<li>小时的值从0到23。</li>
<li>日的值从1到31。</li>
<li>月的值从1到12。</li>
<li>星期的值从0到6，0表示星期日。</li>
<li>多个时间可以用逗号隔开，范围可以用连字符给出：* 可以作为通配符，&#x2F;表示每…</li>
</ul>
<p>concurrencyPolicy：并发执行策略</p>
<ul>
<li>Allow：运行Job并发运行（默认）。</li>
<li>Forbid：禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行。</li>
<li>Replace：替换，取消当前正在运行的作业并使用新作业替换它。</li>
</ul>
<p>创建pc-cronjob.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-cronjob</span> <span class="comment"># 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span>  <span class="comment">#命名空间</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * * &quot;</span> <span class="comment"># cron格式的作业调度运行时间点，用于控制任务任务时间执行</span></span><br><span class="line">  <span class="attr">jobTemplate:</span> <span class="comment"># job控制器模板，用于为cronjob控制器生成job对象，下面其实就是job的定义</span></span><br><span class="line">    <span class="attr">metadata:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建Pod模板</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略只能设置为Never或OnFailure</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">              <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1;do echo $i;sleep 2;done&quot;</span> ]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">kubectl create -f pc-cronjob.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get cronjob -n dev -w</span><br><span class="line">kubectl get job -n dev -w</span><br><span class="line">kubectl get pod -n dev -w</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">kubectl delete -f pc-cronjob.yaml</span><br></pre></td></tr></table></figure>

<h1 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>无状态应用：</p>
<ul>
<li>认为Pod都是一样的。</li>
<li>没有顺序要求。</li>
<li>不用考虑在哪个Node节点上运行。</li>
<li>随意进行伸缩和扩展。</li>
</ul>
<p>有状态应用：</p>
<ul>
<li>有顺序的要求。</li>
<li>认为每个Pod都是不一样的。</li>
<li>需要考虑在哪个Node节点上运行。</li>
<li>需要按照顺序进行伸缩和扩展。</li>
<li>让每个Pod都是独立的，保持Pod启动顺序和唯一性。</li>
</ul>
<p>StatefulSet是Kubernetes提供的管理有状态应用的负载管理控制器</p>
<p>StatefulSet部署需要HeadLinessService（无头服务）</p>
<blockquote>
<p>为什么需要HeadLinessService（无头服务）？</p>
<ul>
<li>在用Deployment时，每一个Pod名称是没有顺序的，是随机字符串，因此是Pod名称是无序的，但是在StatefulSet中要求必须是有序 ，每一个Pod不能被随意取代，Pod重建后pod名称还是一样的。</li>
<li>而Pod IP是变化的，所以是以Pod名称来识别。Pod名称是Pod唯一性的标识符，必须持久稳定有效。这时候要用到无头服务，它可以给每个Pod一个唯一的名称 。</li>
</ul>
</blockquote>
<p>StatefulSet常用来部署RabbitMQ集群、Zookeeper集群、MySQL集群、Eureka集群等。</p>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>创建pc-stateful.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># Pod的端口</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-statefulset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pc-stateful.yaml</span><br><span class="line"></span><br><span class="line">kubectl get statefulset pc-statefulset -n dev -o wide</span><br><span class="line">kubectl get pod -n dev -o wide</span><br><span class="line"></span><br><span class="line">kubectl delete -f pc-stateful.yaml</span><br></pre></td></tr></table></figure>

<h2 id="Deployment和StatefulSet的区别"><a href="#Deployment和StatefulSet的区别" class="headerlink" title="Deployment和StatefulSet的区别"></a>Deployment和StatefulSet的区别</h2><ul>
<li>Deployment和StatefulSet的区别：Deployment没有唯一标识而StatefulSet有唯一标识。</li>
<li>StatefulSet的唯一标识是根据主机名+一定规则生成的。</li>
<li>StatefulSet的唯一标识是主机名.无头Service名称.命名空间.svc.cluster.local</li>
</ul>
<h2 id="StatefulSet的金丝雀发布"><a href="#StatefulSet的金丝雀发布" class="headerlink" title="StatefulSet的金丝雀发布"></a>StatefulSet的金丝雀发布</h2><p>StatefulSet支持两种更新策略：OnDelete和RollingUpdate（默认），其中OnDelete表示删除之后才更新，RollingUpdate表示滚动更新。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">updateStrategy:</span></span><br><span class="line">  <span class="attr">rollingUpdate:</span> <span class="comment"># 如果更新的策略是OnDelete，那么rollingUpdate就失效</span></span><br><span class="line">    <span class="attr">partition:</span> <span class="number">2</span> <span class="comment"># 表示从第2个分区开始更新，默认是0</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="string">/OnDelete</span> <span class="comment"># 滚动更新</span></span><br></pre></td></tr></table></figure>

<p>示例：pc-statefulset.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># Pod的端口</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-statefulset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">			</span><br><span class="line">  <span class="attr">updateStrategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">partition:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span>  			</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（十二）- K8S Service详解</title>
    <url>/2022/03/28/k8s-study-notes-12/</url>
    <content><![CDATA[<blockquote>
<p>主要介绍kubernetes的流量负载组件：Service和Ingress。</p>
</blockquote>
<h1 id="Service介绍"><a href="#Service介绍" class="headerlink" title="Service介绍"></a>Service介绍</h1><p>在kubernetes中，Pod是应用程序的载体，我们可以通过Pod的IP来访问应用程序，但是Pod的IP地址不是固定的，这就意味着不方便直接采用Pod的IP对服务进行访问。<br>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个Pod进行聚合，并且提供一个统一的入口地址，通过访问Service的入口地址就能访问到后面的Pod服务。<br><img src="/1.png" alt="1"></p>
<p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行了一个kube-proxy的服务进程。<br>当创建Service的时候会通过API Server向etcd写入创建的Service的信息，而kube-proxy会基于监听的机制发现这种Service的变化，然后它会将最新的Service信息转换为对应的访问规则。<br><img src="/2.png" alt="2"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.97.97.97:80 是service提供的访问入口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。</span></span><br><span class="line">[root@k8s-node1 ~]# ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta prompt_"> -&gt; </span><span class="language-bash">RemoteAddress:Port  Forward Weight ActiveConn InActConn</span></span><br><span class="line"> TCP 10.97.97.97:80 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.39:80   Masq  1  0  0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.1.40:80   Masq  1  0  0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">10.244.2.33:80   Masq  1  0  0</span></span><br></pre></td></tr></table></figure>
<h2 id="kube-proxy目前支持三种工作模式："><a href="#kube-proxy目前支持三种工作模式：" class="headerlink" title="kube-proxy目前支持三种工作模式："></a>kube-proxy目前支持三种工作模式：</h2><h3 id="userspace模式"><a href="#userspace模式" class="headerlink" title="userspace模式"></a>userspace模式</h3><p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法（负载均衡算法）选择一个提供服务的Pod并和其建立连接，以便将请求转发到Pod上。<br>该模式下，kube-proxy充当了一个四层负载均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理的时候会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率非常低下。<br><img src="/3.png" alt="3"></p>
<h3 id="iptables模式"><a href="#iptables模式" class="headerlink" title="iptables模式"></a>iptables模式</h3><p>iptables模式下，kube-proxy为Service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod的IP上。<br>该模式下kube-proxy不承担四层负载均衡器的角色，只负责创建iptables规则。<br>该模式的优点在于较userspace模式效率更高，但是不能提供灵活的LB策略，当后端Pod不可用的时候无法进行重试。<br><img src="/4.png" alt="4"></p>
<h3 id="ipvs模式"><a href="#ipvs模式" class="headerlink" title="ipvs模式"></a>ipvs模式</h3><p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。<br>ipvs相对iptables转发效率更高，除此之外，ipvs支持更多的LB算法。<br><img src="/5.png" alt="5"><br>开启ipvs（必须安装ipvs内核模块，否则会降级为iptables）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改mode为ipvs</span></span><br><span class="line">kubectl edit cm kube-proxy -n kube-system</span><br></pre></td></tr></table></figure>
<p><img src="/6.png" alt="6"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除老得kube-proxy的pod</span></span><br><span class="line">kubectl delete pod -l k8s-app=kube-proxy -n kube-system</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试ipvs模块是否开启成功</span></span><br><span class="line">ipvsadm -Ln</span><br></pre></td></tr></table></figure>

<h1 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h1><p>Service的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment"># 版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 标签选择器，用于确定当前Service代理那些Pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># Service的类型，指定Service的访问方式</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="comment"># 虚拟服务的IP地址</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="comment"># session亲和性，支持ClientIP、None两个选项，默认值为None</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="comment"># 端口信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># Service端口</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 协议</span></span><br><span class="line">      <span class="attr">targetPort :</span> <span class="comment"># Pod端口</span></span><br><span class="line">      <span class="attr">nodePort:</span>  <span class="comment"># 主机端口</span></span><br></pre></td></tr></table></figure>
<p>spec.type的说明：</p>
<ul>
<li>ClusterIP：默认值，它是kubernetes系统自动分配的虚拟IP，只能在集群内部访问。</li>
<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务。</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境的支持。</li>
<li>ExternalName：把集群外部的服务引入集群内部，直接使用。</li>
</ul>
<h1 id="Service使用"><a href="#Service使用" class="headerlink" title="Service使用"></a>Service使用</h1><h2 id="实验环境准备"><a href="#实验环境准备" class="headerlink" title="实验环境准备"></a>实验环境准备</h2><p>在使用Service之前，首先利用Deployment创建出3个Pod，注意要为Pod设置app&#x3D;nginx-pod的标签。<br>创建deployment.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f deployment.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pod -n dev -o wide --show-labels</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了方便后面的测试，修改三台Nginx的index.html</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pod只有一个用户容器，可以不用加-c nginx</span></span><br><span class="line">kubectl exec -it pc-deployment-7d7dd5499b-j28f4 -n dev /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器内</span></span><br><span class="line">root@pc-deployment-7d7dd5499b-j28f4:/# echo &quot;10.244.169.149&quot; &gt; /usr/share/nginx/html/index.html &amp;&amp; exit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看修改是否生效</span></span><br><span class="line">curl 10.244.169.149</span><br></pre></td></tr></table></figure>

<h2 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h2><h3 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h3><p>创建service-clusterip.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-clusterip</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="comment"># service的IP地址，如果不写，默认会生成一个</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># Pod的端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f service-clusterip.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get svc -n dev -o wide</span><br><span class="line">kubectl describe svc service-clusterip -n dev</span><br></pre></td></tr></table></figure>
<p><img src="/7.png" alt="7"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ipvs的映射规则</span></span><br><span class="line">ipvsadm -Ln</span><br></pre></td></tr></table></figure>
<p><img src="/8.png" alt="8"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">多次访问，查看效果</span></span><br><span class="line">curl 10.100.157.35</span><br><span class="line">curl 10.100.157.35</span><br><span class="line">curl 10.100.157.35</span><br></pre></td></tr></table></figure>

<h2 id="负载分发策略"><a href="#负载分发策略" class="headerlink" title="负载分发策略"></a>负载分发策略</h2><p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略： </p>
<ul>
<li>如果不定义，默认使用kube-proxy的策略，比如随机、轮询等。</li>
<li>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上，这对于传统基于Session的认证项目来说很友好，此模式可以在spec中添加sessionAffinity: ClientIP。<br>ipvs的映射规则，rr表示轮询。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证当前轮训策略</span></span><br><span class="line">while true;do curl 10.100.157.35; sleep 2; done;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>修改分发策略</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-clusterip</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.100</span><span class="number">.157</span><span class="number">.35</span> <span class="comment"># service的IP地址，如果不写，默认会生成一个</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">ClientIP</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># Pod的端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service-clusterip.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新验证轮训策略</span></span><br><span class="line">while true;do curl 10.100.157.35; sleep 2; done;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除service</span></span><br><span class="line">kubectl delete -f service-clusterip.yaml</span><br></pre></td></tr></table></figure>

<h2 id="Headliness"><a href="#Headliness" class="headerlink" title="Headliness"></a>Headliness</h2><p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，<br>针对这种情况，kubernetes提供了HeadLinesss Service，这类Service不会分配Cluster IP，如果想要访问Service，只能通过Service的域名进行查询。</p>
<p>创建service-headliness.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># Pod的端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f service-headliness.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get svc service-headliness -n dev -o wide</span><br><span class="line">kubectl describe svc service-headliness -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">kubectl delete -f service-headliness.yaml</span><br></pre></td></tr></table></figure>


<h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p>在之前的案例中，创建的Service的IP地址只能在集群内部才可以访问，如果希望Service暴露给集群外部使用，那么就需要使用到另外一种类型的Service，称为NodePort类型的Service。<br>NodePort的工作原理就是将Service的端口映射到Node的一个端口上，然后就可以通过NodeIP:NodePort来访问Service了。<br><img src="/9.png" alt="9"></p>
<p>创建service-nodeport.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-nodeport</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># Service类型为NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># Pod的端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30002</span> <span class="comment"># 指定绑定的node的端口（默认取值范围是30000~32767），如果不指定，会默认分配</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f service-nodeport.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get svc service-nodeport -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问</span></span><br><span class="line">curl 172.16.7.200:30002</span><br><span class="line">curl 172.16.7.201:30002</span><br><span class="line">curl 172.16.7.202:30002</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">kubectl delete -f service-nodeport.yaml</span><br></pre></td></tr></table></figure>

<h2 id="NodeBalancer"><a href="#NodeBalancer" class="headerlink" title="NodeBalancer"></a>NodeBalancer</h2><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境的支持，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。<br><img src="/10.png" alt="10"></p>
<h2 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h2><p>ExternalName类型的Service用于引入集群外部的服务，它通过externalName属性指定一个服务的地址，然后在集群内部访问此Service就可以访问到外部的服务了。<br><img src="/11.png" alt="11"></p>
<p>创建service-externalname.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-externalname</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span> <span class="comment"># Service类型为ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">www.baidu.com</span> <span class="comment"># 改成IP地址也可以</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f service-externalname.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">域名解析</span></span><br><span class="line">dig @10.96.0.10 service-externalname.dev.svc.cluster.local</span><br><span class="line"></span><br><span class="line">kubectl delete -f service-externalname.yaml</span><br></pre></td></tr></table></figure>

<h1 id="Ingress介绍"><a href="#Ingress介绍" class="headerlink" title="Ingress介绍"></a>Ingress介绍</h1><p>我们已经知道，Service对集群之外暴露服务的主要方式有两种：NodePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p>
<ul>
<li>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显。</li>
<li>LoadBalancer的缺点是每个Service都需要一个LB，浪费，麻烦，并且需要kubernetes之外的设备的支持。</li>
</ul>
<p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求，工作机制大致如下图所示：<br><img src="/12.png" alt="12"><br>实际上，Ingress相当于一个七层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，<br>可以理解为Ingress里面建立了诸多映射规则，Ingress Controller通过监听这些配置规则并转化为Nginx的反向代理配置，然后对外提供服务。</p>
<ul>
<li>Ingress：kubernetes中的一个对象，作用是定义请求如何转发到Service的规则。</li>
<li>Ingress Controller：具体实现反向代理及负载均衡的程序，对Ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现的方式有很多，比如Nginx，Contour，Haproxy等。</li>
</ul>
<p>Ingress（以Nginx）的工作原理如下：</p>
<ol>
<li>用户编写Ingress规则，说明那个域名对应kubernetes集群中的那个Service。 </li>
<li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx的反向代理配置。 </li>
<li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新。 </li>
<li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求规则。<br><img src="/13.png" alt="13"></li>
</ol>
<h1 id="Ingress使用"><a href="#Ingress使用" class="headerlink" title="Ingress使用"></a>Ingress使用</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="搭建Ingress环境"><a href="#搭建Ingress环境" class="headerlink" title="搭建Ingress环境"></a>搭建Ingress环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ingress-controller</span><br><span class="line">cd ingress-controller</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取ingress-nginx，本次使用的是0.30版本</span></span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml</span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f ./</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod -n ingress-nginx</span><br><span class="line">kubectl get svc -n ingress-nginx</span><br></pre></td></tr></table></figure>

<h3 id="准备Service和Pod"><a href="#准备Service和Pod" class="headerlink" title="准备Service和Pod"></a>准备Service和Pod</h3><p>为了后面的实验比较方便，创建如下图所示的模型：<br><img src="/14.png" alt="14"><br>创建tomcat-nginx.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tomcat:8.5-jre10-slim</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f tomcat-nginx.yaml</span><br><span class="line"></span><br><span class="line">kubectl get svc,pod -n dev</span><br></pre></td></tr></table></figure>

<h2 id="Http代理"><a href="#Http代理" class="headerlink" title="Http代理"></a>Http代理</h2><p>创建ingress-http.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-http</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.123456.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.123456.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f ingress-http.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get ingress ingress-http -n dev</span><br><span class="line">kubectl describe ingress ingress-http -n dev</span><br><span class="line">kubectl get svc -n ingress-nginx</span><br></pre></td></tr></table></figure>

<p>在本机的hosts文件中添加如下的规则（172.16.7.200为Master节点的IP地址）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.16.7.200 nginx.123456.com</span><br><span class="line">172.16.7.200 tomcat.123456.com</span><br></pre></td></tr></table></figure>

<p>访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://nginx.123456.com:30096</span><br><span class="line">http://tomcat.123456.com:30096</span><br></pre></td></tr></table></figure>

<h2 id="Https代理"><a href="#Https代理" class="headerlink" title="Https代理"></a>Https代理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成证书</span></span><br><span class="line">openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/C=CN/ST=BJ/L=BJ/O=nginx/CN=123456.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建密钥</span></span><br><span class="line">kubectl create secret tls tls-secret --key tls.key --cert tls.crt</span><br></pre></td></tr></table></figure>

<p>创建ingress-https.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-https</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx.123456.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcat.123456.com</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-secret</span> <span class="comment"># 指定秘钥</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.123456.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.123456.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f ingress-https.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get ingress ingress-https -n dev</span><br><span class="line">kubectl describe ingress ingress-https -n dev</span><br></pre></td></tr></table></figure>

<p>访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://nginx.123456.com:31356</span><br><span class="line">https://tomcat.123456.com:31356</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（十三）- K8S 数据存储</title>
    <url>/2022/04/04/k8s-study-notes-13/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在前面已经提到，容器的生命周期可能很短，会被频繁的创建和销毁。<br>那么容器在销毁的时候，保存在容器中的数据也会被清除。<br>这种结果对用户来说，在某些情况下是不乐意看到的。<br>为了持久化保存容器中的数据，kubernetes引入了Volume的概念。</p>
<p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。<br>Volume的生命周期不和Pod中的单个容器的生命周期有关，当容器终止或者重启的时候，Volume中的数据也不会丢失。</p>
<p>kubernetes的Volume支持多种类型，比较常见的有下面的几个：</p>
<ul>
<li>简单存储：EmptyDir、HostPath、NFS。</li>
<li>高级存储：PV、PVC。</li>
<li>配置存储：ConfigMap、Secret。</li>
</ul>
<h1 id="基本存储"><a href="#基本存储" class="headerlink" title="基本存储"></a>基本存储</h1><h2 id="EmptyDir"><a href="#EmptyDir" class="headerlink" title="EmptyDir"></a>EmptyDir</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。</li>
<li>EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时，EmptyDir中的数据也会被永久删除。</li>
</ul>
<p>EmptyDir的用途如下：</p>
<ul>
<li>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</li>
<li>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li>
</ul>
<p>接下来，通过一个容器之间的共享案例来使用描述一个EmptyDir。<br>在一个Pod中准备两个容器nginx和busybox，然后声明一个volume分别挂载到两个容器的目录中，然后nginx容器负责向volume中写日志，busybox中通过命令将日志内容读到控制台。<br><img src="/1.png" alt="1"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>创建volume-emptydir.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-emptydir</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">volumeMounts:</span> <span class="comment"># 将logs-volume挂载到nginx容器中对应的目录，该目录为/var/log/nginx</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] <span class="comment"># 初始命令，动态读取指定文件</span></span><br><span class="line">      <span class="attr">volumeMounts:</span> <span class="comment"># 将logs-volume挂载到busybox容器中的对应目录，该目录为/logs</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 声明volume，name为logs-volume，类型为emptyDir</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f volume-emptydir.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod volume-emptydir -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">kubectl logs -f volume-emptydir -n dev -c busybox</span><br></pre></td></tr></table></figure>
<p>这时访问nginx服务，上面的日志就有输出</p>
<h2 id="HostPath"><a href="#HostPath" class="headerlink" title="HostPath"></a>HostPath</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>我们已经知道EmptyDir中的数据不会被持久化，它会随着Pod的结束而销毁，如果想要简单的将数据持久化到主机中，可以选择HostPath。<br>HostPath就是将Node主机中的一个实际目录挂载到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依旧可以保存在Node主机上。<br><img src="/2.png" alt="2"></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>创建volume-hostpath.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-hostpath</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">volumeMounts:</span> <span class="comment"># 将logs-volume挂载到nginx容器中对应的目录，该目录为/var/log/nginx</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] <span class="comment"># 初始命令，动态读取指定文件</span></span><br><span class="line">      <span class="attr">volumeMounts:</span> <span class="comment"># 将logs-volume挂载到busybox容器中的对应目录，该目录为/logs</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 声明volume，name为logs-volume，类型为hostPath</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/root/logs</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span> <span class="comment"># 目录存在就使用，不存在就先创建再使用</span></span><br></pre></td></tr></table></figure>
<p>type的值的说明：</p>
<ul>
<li>DirectoryOrCreate：目录存在就使用，不存在就先创建后使用。</li>
<li>Directory：目录必须存在。</li>
<li>FileOrCreate：文件存在就使用，不存在就先创建后使用。</li>
<li>File：文件必须存在。</li>
<li>Socket：unix套接字必须存在。</li>
<li>CharDevice：字符设备必须存在。</li>
<li>BlockDevice：块设备必须存在。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f volume-hostpath.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pod volume-hostpath -n dev -o wide</span><br></pre></td></tr></table></figure>
<p>在相应的node节点上可以看的容器内的日志。<br>同样的道理，如果在此目录中创建文件，到容器中也是可以看到的。</p>
<h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>HostPath虽然可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到别的Node节点上，又会出现问题，此时需要准备单独的网络存储系统，比较常用的是NFS和CIFS。<br>NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样，无论Pod在节点上怎么转移，只要Node和NFS的对接没有问题，数据就可以成功访问。<br><img src="/3.png" alt="3"></p>
<h3 id="搭建NFS服务器"><a href="#搭建NFS服务器" class="headerlink" title="搭建NFS服务器"></a>搭建NFS服务器</h3><p>首先需要准备NFS服务器，这里为了简单，直接在Master节点做NFS服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y nfs-utils rpcbind</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> -pv /root/data/nfs</span></span><br><span class="line">mkdir -pv /root/data/nfs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将共享目录以读写权限暴露给192.168.18.0/24网段中的所有主机</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/root/data/nfs 192.168.18.0/24(rw,no_root_squash)</span></span><br><span class="line">vim /etc/exports</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改权限</span></span><br><span class="line">chmod 777 -R /root/data/nfs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载配置</span></span><br><span class="line">exportfs -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动nfs服务</span></span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl enable rpcbind</span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl enable nfs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Master节点测试是否挂载成功</span></span><br><span class="line">showmount -e 192.168.18.100</span><br></pre></td></tr></table></figure>

<p>在Node节点上都安装NFS服务器，目的是为了Node节点可以驱动NFS设备。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Node节点上安装NFS服务，不需要启动</span></span><br><span class="line">yum -y install nfs-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Node节点测试是否挂载成功</span></span><br><span class="line">showmount -e 192.168.18.100</span><br></pre></td></tr></table></figure>
<p>高可用备份方式，在所有节点执行如下的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t  nfs 192.168.18.100:/root/data/nfs /mnt</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-nfs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">volumeMounts:</span> <span class="comment"># 将logs-volume挂载到nginx容器中对应的目录，该目录为/var/log/nginx</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] <span class="comment"># 初始命令，动态读取指定文件</span></span><br><span class="line">      <span class="attr">volumeMounts:</span> <span class="comment"># 将logs-volume挂载到busybox容器中的对应目录，该目录为/logs</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 声明volume</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.18</span><span class="number">.100</span> <span class="comment"># NFS服务器地址</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/root/data/nfs</span> <span class="comment"># 共享文件路径</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f volume-nfs.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod volume-nfs -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nfs服务器上共享目录</span></span><br><span class="line">ls /root/data/nfs</span><br></pre></td></tr></table></figure>

<h1 id="高级存储"><a href="#高级存储" class="headerlink" title="高级存储"></a>高级存储</h1><h2 id="PV和PVC概述"><a href="#PV和PVC概述" class="headerlink" title="PV和PVC概述"></a>PV和PVC概述</h2><p>前面我们已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。<br>由于kubernetes支持的存储系统有很多，要求客户全部掌握，显然不现实。<br>为了能够屏蔽底层存储实现的细节，方便用户使用，kubernetes引入了PV和PVC两种资源对象。</p>
<p>PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。<br>一般情况下PV由kubernetes管理员进行创建和配置，它和底层具体的共享存储技术有关，并通过插件完成和共享存储的对接。</p>
<p>PVC（Persistent Volume Claim）是持久化卷声明的意思，是用户对于存储需求的一种声明。<br>换言之，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。<br><img src="/4.png" alt="4"><br>使用了PV和PVC之后，工作可以得到进一步的提升</p>
<ul>
<li>存储：存储工程师维护</li>
<li>PV：kubernetes管理员维护</li>
<li>PVC：kubernetes用户维护</li>
</ul>
<h2 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h2><h3 id="PV的资源清单文件"><a href="#PV的资源清单文件" class="headerlink" title="PV的资源清单文件"></a>PV的资源清单文件</h3><p>PV是存储资源的抽象，下面是PV的资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 存储类型，和底层正则的存储对应</span></span><br><span class="line">    <span class="attr">path:</span></span><br><span class="line">    <span class="attr">server:</span></span><br><span class="line">  <span class="attr">capacity:</span> <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="comment"># 回收策略</span></span><br></pre></td></tr></table></figure>
<p>pv的关键配置参数说明：</p>
<ul>
<li>存储类型：底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置有所不同</li>
<li>存储能力（capacity）：目前只支持存储空间的设置（storage&#x3D;1Gi），不过未来可能会加入IOPS、吞吐量等指标的配置</li>
<li>访问模式（accessModes），用来描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：<ul>
<li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li>
<li>ReadOnlyMany（ROX）：只读权限，可以被多个节点挂载</li>
<li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</li>
<li>需要注意的是，底层不同的存储类型可能支持的访问模式不同</li>
</ul>
</li>
<li>回收策略（ persistentVolumeReclaimPolicy），当PV不再被使用之后，对其的处理方式，目前支持三种策略：<ul>
<li>Retain（保留）：保留数据，需要管理员手动清理数据</li>
<li>Recycle（回收）：清除PV中的数据，效果相当于rm -rf &#x2F;volume&#x2F;*</li>
<li>Delete（删除）：和PV相连的后端存储完成volume的删除操作，常见于云服务器厂商的存储服务</li>
<li>需要注意的是，底层不同的存储类型可能支持的回收策略不同</li>
</ul>
</li>
<li>存储类别（storageClassName）：PV可以通过storageClassName参数指定一个存储类别<ul>
<li>具有特定类型的PV只能和请求了该类别的PVC进行绑定</li>
<li>未设定类别的PV只能和不请求任何类别的PVC进行绑定</li>
</ul>
</li>
<li>状态（status）：一个PV的生命周期，可能会处于4种不同的阶段<ul>
<li>Available（可用）：表示可用状态，还未被任何PVC绑定</li>
<li>Bound（已绑定）：表示PV已经被PVC绑定</li>
<li>Released（已释放）：表示PVC被删除，但是资源还没有被集群重新释放</li>
<li>Failed（失败）：表示该PV的自动回收失败</li>
</ul>
</li>
</ul>
<h3 id="准备NFS环境"><a href="#准备NFS环境" class="headerlink" title="准备NFS环境"></a>准备NFS环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建目录</span></span><br><span class="line">mkdir -pv /root/data/&#123;pv1,pv2,pv3&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">授权</span></span><br><span class="line">chmod 777 -R /root/data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改/etc/exports文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/root/data/pv1     192.168.18.0/24(rw,no_root_squash)</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/root/data/pv2     192.168.18.0/24(rw,no_root_squash)</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/root/data/pv3     192.168.18.0/24(rw,no_root_squash)</span></span><br><span class="line">vim /etc/exports</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启nfs服务</span></span><br><span class="line">systemctl restart nfs</span><br></pre></td></tr></table></figure>

<h3 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h3><p>创建pv.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 存储类型吗，和底层正则的存储对应</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv1</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.18</span><span class="number">.100</span></span><br><span class="line">  <span class="attr">capacity:</span> <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span> <span class="comment"># 回收策略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 存储类型吗，和底层正则的存储对应</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv2</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.18</span><span class="number">.100</span></span><br><span class="line">  <span class="attr">capacity:</span> <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span> <span class="comment"># 回收策略</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv3</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 存储类型吗，和底层正则的存储对应</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv3</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.18</span><span class="number">.100</span></span><br><span class="line">  <span class="attr">capacity:</span> <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span> <span class="comment"># 回收策略</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pv.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看PV</span></span><br><span class="line">kubectl get pv -o wide</span><br></pre></td></tr></table></figure>

<h2 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h2><h3 id="PVC的资源清单文件"><a href="#PVC的资源清单文件" class="headerlink" title="PVC的资源清单文件"></a>PVC的资源清单文件</h3><p>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息，下面是PVC的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访客模式</span></span><br><span class="line">    <span class="bullet">-</span> </span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 采用标签对PV选择</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="comment"># 请求空间</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br></pre></td></tr></table></figure>
<p>PVC的关键配置参数说明：</p>
<ul>
<li>访客模式（accessModes）：用于描述用户应用对存储资源的访问权限</li>
<li>用于描述用户应用对存储资源的访问权限：<ul>
<li>选择条件（selector）：通过Label Selector的设置，可使PVC对于系统中已存在的PV进行筛选</li>
<li>存储类别（storageClassName）：PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</li>
<li>资源请求（resources）：描述对存储资源的请求</li>
</ul>
</li>
</ul>
<h3 id="创建PVC"><a href="#创建PVC" class="headerlink" title="创建PVC"></a>创建PVC</h3><p>创建pvc.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访客模式</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="comment"># 请求空间</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访客模式</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="comment"># 请求空间</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访客模式</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="comment"># 请求空间</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pvc.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看PVC</span></span><br><span class="line">kubectl get pvc -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看PV</span></span><br><span class="line">kubectl get pv -o wide</span><br></pre></td></tr></table></figure>

<h3 id="创建Pod使用PVC"><a href="#创建Pod使用PVC" class="headerlink" title="创建Pod使用PVC"></a>创建Pod使用PVC</h3><p>创建pvc-pod.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod1 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc1</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod1 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc2</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pvc-pod.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">kubectl get pod -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod使用PVC后查看PVC</span></span><br><span class="line">kubectl get pvc -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod使用PVC后查看PV</span></span><br><span class="line">kubectl get pv -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nfs中的文件存储</span></span><br><span class="line">ls /root/data/pv1/out.txt</span><br><span class="line">ls /root/data/pv2/out.txt</span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="/5.png" alt="5"><br>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循如下的生命周期。</p>
<ul>
<li>资源供应：管理员手动创建底层存储和PV</li>
<li>资源绑定:<ul>
<li>用户创建PVC，kubernetes负责根据PVC声明去寻找PV，并绑定在用户定义好PVC之后，系统将根据PVC对存储资源的请求在以存在的PV中选择一个满足条件的<ul>
<li>一旦找到，就将该PV和用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了</li>
<li>如果找不到，PVC就会无限期的处于Pending状态，直到系统管理员创建一个符合其要求的PV</li>
</ul>
</li>
<li>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再和其他的PVC进行绑定了</li>
</ul>
</li>
<li>资源使用：用户可以在Pod中像volume一样使用PVC，Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用</li>
<li>资源释放:<ul>
<li>用户删除PVC来释放PV</li>
<li>当存储资源使用完毕后，用户可以删除PVC，和该PVC绑定的PV将会标记为“已释放”，但是还不能立刻和其他的PVC进行绑定。通过之前PVC写入的数据可能还留在存储设备上，只有在清除之后该PV才能再次使用。</li>
</ul>
</li>
<li>资源回收:<ul>
<li>kubernetes根据PV设置的回收策略进行资源的回收</li>
<li>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用</li>
</ul>
</li>
</ul>
<h2 id="创建PVC后一直绑定不了PV的原因"><a href="#创建PVC后一直绑定不了PV的原因" class="headerlink" title="创建PVC后一直绑定不了PV的原因"></a>创建PVC后一直绑定不了PV的原因</h2><ul>
<li>PVC的空间申请大小比PV的空间要大</li>
<li>PVC的storageClassName和PV的storageClassName不一致</li>
<li>PVC的accessModes和PV的accessModes不一致</li>
</ul>
<h1 id="配置存储"><a href="#配置存储" class="headerlink" title="配置存储"></a>配置存储</h1><h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>ConfigMap是一个比较特殊的存储卷，它的主要作用是用来存储配置信息的</p>
<h3 id="ConfigMap的资源清单文件"><a href="#ConfigMap的资源清单文件" class="headerlink" title="ConfigMap的资源清单文件"></a>ConfigMap的资源清单文件</h3><p>ConfigMap的资源清单文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configMap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">data:</span> <span class="comment"># &lt;map[string]string&gt;</span></span><br><span class="line">  <span class="string">xxx</span></span><br></pre></td></tr></table></figure>
<h3 id="创建ConfigMap"><a href="#创建ConfigMap" class="headerlink" title="创建ConfigMap"></a>创建ConfigMap</h3><p>创建configmap.yaml文件，内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">info:</span></span><br><span class="line">    <span class="string">username:admin</span></span><br><span class="line">    <span class="string">password:123456</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f configmap.yaml</span><br></pre></td></tr></table></figure>

<h3 id="创建Pod"><a href="#创建Pod" class="headerlink" title="创建Pod"></a>创建Pod</h3><p>创建pod-configmap.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/configmap/config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">configmap</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-configmap.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">kubectl get pod pod-configmap -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器，查看配置</span></span><br><span class="line">kubectl exec -it pod-configmap -n dev /bin/sh</span><br><span class="line">cd /configmap/config</span><br><span class="line">more info</span><br></pre></td></tr></table></figure>
<p>ConfigMap中的key映射为一个文件，value映射为文件中的内容。如果更新了ConfigMap中的内容，容器中的值也会动态更新。</p>
<h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象，它主要用来存储敏感信息，例如密码、密钥、证书等等</p>
<h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="built_in">base64</span>对数据进行编码</span></span><br><span class="line">echo -n &quot;admin&quot; | base64</span><br><span class="line">echo -n &quot;123456&quot; | base64</span><br></pre></td></tr></table></figure>
<h3 id="创建Secret"><a href="#创建Secret" class="headerlink" title="创建Secret"></a>创建Secret</h3><p>创建secret.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MTIzNDU2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f secret.yaml</span><br></pre></td></tr></table></figure>

<p>上面的方式是先手动将数据进行编码，其实也可以使用直接编写数据，将数据编码交给kubernetes</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">stringData:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>如果同时使用data和stringData，那么data会被忽略</p>
<h3 id="查看Secret详情"><a href="#查看Secret详情" class="headerlink" title="查看Secret详情"></a>查看Secret详情</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl describe secret secret -n dev</span><br></pre></td></tr></table></figure>

<h3 id="创建Pod-1"><a href="#创建Pod-1" class="headerlink" title="创建Pod"></a>创建Pod</h3><p>创建pod-secret.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/secret/config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-secret.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">kubectl get pod pod-secret -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器，查看secret信息，发现已经自动解码了</span></span><br><span class="line">kubectl exec -it pod-secret -n dev /bin/sh</span><br><span class="line">ls /secret/config</span><br><span class="line">more /secret/config/username</span><br><span class="line">more /secret/config/password</span><br></pre></td></tr></table></figure>

<h3 id="Secret的用途"><a href="#Secret的用途" class="headerlink" title="Secret的用途"></a>Secret的用途</h3><p>imagePullSecret：Pod拉取私有镜像仓库的时使用的账户密码，会传递给kubelet，然后kubelet就可以拉取有密码的仓库里面的镜像<br>创建一个ImagePullSecret：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry docker-harbor-registrykey --docker-server=192.168.18.119:85 \</span><br><span class="line">          --docker-username=admin --docker-password=Harbor12345 \</span><br><span class="line">          --docker-email=1900919313@qq.com</span><br><span class="line">     </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否创建成功</span>     </span><br><span class="line">kubectl get secret docker-harbor-registrykey</span><br></pre></td></tr></table></figure>
<p>新建redis.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">image:</span> <span class="number">192.168</span><span class="number">.18</span><span class="number">.119</span><span class="string">:85/yuncloud/redis</span> <span class="comment"># 这是Harbor的镜像私有仓库地址</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-harbor-registrykey</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f redis.yaml</span><br></pre></td></tr></table></figure>

<h2 id="ConfigMap高级"><a href="#ConfigMap高级" class="headerlink" title="ConfigMap高级"></a>ConfigMap高级</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>在ConfigMap基础中，我们已经可以实现创建ConfigMap了，但是如果实际工作中这样使用，就会显得很繁琐<br>注意事项：</p>
<ul>
<li>ConfigMap 在设计上不是用来保存大量数据的。在 ConfigMap 中保存的数据不可超过 1 MiB。</li>
<li>如果需要保存超出此尺寸限制的数据，需要考虑挂载存储卷或者使用独立的数据库或者文件服务。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法</span></span><br><span class="line">kubectl create configmap &lt;map-name&gt; &lt;data-source&gt;</span><br></pre></td></tr></table></figure>

<h3 id="从一个目录中创建ConfigMap"><a href="#从一个目录中创建ConfigMap" class="headerlink" title="从一个目录中创建ConfigMap"></a>从一个目录中创建ConfigMap</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -pv configure-pod-container/configmap/</span><br><span class="line"></span><br><span class="line">wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties</span><br><span class="line"></span><br><span class="line">wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties</span><br><span class="line"></span><br><span class="line">kubectl create configmap cm1 --from-file=configure-pod-container/configmap/</span><br><span class="line"></span><br><span class="line">kubectl get cm cm1 -o yaml</span><br></pre></td></tr></table></figure>

<h3 id="从一个文件中创建ConfigMap"><a href="#从一个文件中创建ConfigMap" class="headerlink" title="从一个文件中创建ConfigMap"></a>从一个文件中创建ConfigMap</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -pv configure-pod-container/configmap/</span><br><span class="line"></span><br><span class="line">wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下的key的名称是文件的名称</span></span><br><span class="line">kubectl create configmap cm2 --from-file=configure-pod-container/configmap/game.properties</span><br></pre></td></tr></table></figure>

<h3 id="从一个文件中创建ConfigMap，并自定义ConfigMap中key的名称"><a href="#从一个文件中创建ConfigMap，并自定义ConfigMap中key的名称" class="headerlink" title="从一个文件中创建ConfigMap，并自定义ConfigMap中key的名称"></a>从一个文件中创建ConfigMap，并自定义ConfigMap中key的名称</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -pv configure-pod-container/configmap/</span><br><span class="line"></span><br><span class="line">wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties</span><br><span class="line"></span><br><span class="line">kubectl create configmap cm3 --from-file=cm3=configure-pod-container/configmap/game.properties</span><br></pre></td></tr></table></figure>

<h3 id="从环境变量文件创建ConfigMap"><a href="#从环境变量文件创建ConfigMap" class="headerlink" title="从环境变量文件创建ConfigMap"></a>从环境变量文件创建ConfigMap</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim configure-pod-container/configmap/env-file.properties</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法规则:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  <span class="built_in">env</span> 文件中的每一行必须为 VAR = VAL 格式。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  以＃开头的行(即注释)将被忽略。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  空行将被忽略。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  引号没有特殊处理(即它们将成为 ConfigMap 值的一部分)</span></span><br><span class="line">enemies=aliens</span><br><span class="line">lives=3</span><br><span class="line">allowed=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl create cm cm4 --from-env-file=configure-pod-container/configmap/env-file.properties</span><br></pre></td></tr></table></figure>
<p>注意：当<code>--from-env-file</code>从多个数据源创建ConfigMap的时候，仅仅最后一个env文件有效。</p>
<h3 id="在命令行根据键值对创建ConfigMap"><a href="#在命令行根据键值对创建ConfigMap" class="headerlink" title="在命令行根据键值对创建ConfigMap"></a>在命令行根据键值对创建ConfigMap</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create configmap cm5 --from-literal=special.how=very --from-literal=special.type=charm</span><br></pre></td></tr></table></figure>

<h3 id="使用ConfigMap定义容器环境变量"><a href="#使用ConfigMap定义容器环境变量" class="headerlink" title="使用ConfigMap定义容器环境变量"></a>使用ConfigMap定义容器环境变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create configmap cm6 --from-literal=special.how=very --from-literal=special.type=charm</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim test-pod.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;env&quot;</span> ]</span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="comment"># 定义环境变量</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_LEVEL_KEY</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="comment"># ConfigMap的名称</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">cm6</span></span><br><span class="line">              <span class="comment"># ConfigMap的key</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">special.how</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f test-pod.yaml</span><br></pre></td></tr></table></figure>

<h3 id="将-ConfigMap-中的所有键值对配置为容器环境变量"><a href="#将-ConfigMap-中的所有键值对配置为容器环境变量" class="headerlink" title="将 ConfigMap 中的所有键值对配置为容器环境变量"></a>将 ConfigMap 中的所有键值对配置为容器环境变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create configmap cm7 --from-literal=special.how=very --from-literal=special.type=charm</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim test-pod.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;env&quot;</span> ]</span><br><span class="line">      <span class="attr">envFrom:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">cm7</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f test-pod.yaml</span><br></pre></td></tr></table></figure>

<h3 id="使用存储在-ConfigMap-中的数据填充容器"><a href="#使用存储在-ConfigMap-中的数据填充容器" class="headerlink" title="使用存储在 ConfigMap 中的数据填充容器"></a>使用存储在 ConfigMap 中的数据填充容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create configmap cm8 --from-literal=special.how=very --from-literal=special.type=charm</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim test-pod.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ls /etc/config/&quot;</span> ]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="comment"># configMap的名称</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cm8</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<h2 id="Secret高级"><a href="#Secret高级" class="headerlink" title="Secret高级"></a>Secret高级</h2><p>略（和ConfigMap高级类似）</p>
<h2 id="ConfigMap-amp-amp-Secret使用SubPath解决目录覆盖问题"><a href="#ConfigMap-amp-amp-Secret使用SubPath解决目录覆盖问题" class="headerlink" title="ConfigMap&amp;&amp;Secret使用SubPath解决目录覆盖问题"></a>ConfigMap&amp;&amp;Secret使用SubPath解决目录覆盖问题</h2><p>ConfigMap和Secret在进行目录挂载的时候会覆盖目录，我们可以使用SubPath解决这个问题</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个Pod</span></span><br><span class="line">kubectl run nginx --image=nginx:1.17.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将nginx.conf导出到本地</span></span><br><span class="line">kubectl exec -it nginx -- cat /etc/nginx/nginx.conf &gt; nginx.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建ConfigMap</span></span><br><span class="line">kubectl create cm nginx-conf --from-file=nginx.conf</span><br><span class="line"></span><br><span class="line">kubectl delete pod nginx</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim nginx.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 3600&quot;</span> ]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="comment"># configMap的名称</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx.yaml</span><br><span class="line"></span><br><span class="line">kubectl exec -it nginx -- ls /etc/nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim nginx.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">command:</span> [ <span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 3600&quot;</span> ]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx/nginx.conf</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">nginx.conf</span> <span class="comment"># subPath：要覆盖文件的相对路径</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="comment"># configMap的名称</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nginx.conf</span> <span class="comment"># key：ConfigMap中的key的名称</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">nginx.conf</span> <span class="comment"># 此处的path相当于 mv nginx.conf nginx.conf</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx.yaml</span><br><span class="line"></span><br><span class="line">kubectl exec -it nginx -- ls /etc/nginx</span><br></pre></td></tr></table></figure>

<h2 id="ConfigMap-amp-amp-Secret的热更新"><a href="#ConfigMap-amp-amp-Secret的热更新" class="headerlink" title="ConfigMap&amp;&amp;Secret的热更新"></a>ConfigMap&amp;&amp;Secret的热更新</h2><p>注意事项：</p>
<ul>
<li>如果ConfigMap和Secret是以subPath的形式挂载的，那么Pod是不会感知到ConfigMap和Secret的更新的</li>
<li>如果Pod的变量来自ConfigMap和Secret中定义的内容，那么ConfigMap和Secret更新后，也不会更新Pod中的变量</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（十四）- K8S的Helm</title>
    <url>/2022/04/04/k8s-study-notes-14/</url>
    <content><![CDATA[<blockquote>
<p>Helm v3版本</p>
</blockquote>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>kubernetes上的应用对象，都是由特定的资源描述组成，包括Deployment、Service等，都保存在各自文件中或者集中写在一个配置文件，然后通过kubectl apply -f 部署。<br>如果应用只由一个或几个这样的服务组成，上面的部署方式就足够了。<br>但是对于一个复杂的应用，会有很多类似上面的资源描述文件，例如微服务架构应用，组成应用的服务可能多达几十、上百个，如果有更新或回滚应用的需求，可能要修改和维护所涉及到大量的资源文件，而这种组织和管理应用的方式就显得力不从心了。<br>并且由于缺少对发布过的应用进行版本管理和控制，使得kubernetes上的应用维护和更新面临诸多的挑战，主要面临以下的问题：</p>
<ul>
<li>如何将这些服务作为一个整体管理？</li>
<li>这些资源文件如何高效复用？</li>
<li>应用级别的版本如何管理？</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Helm是一个kubernetes的包管理工具，就像Linux下的包管理器，如yum、apt等，可以很方便的将之前打包好的yaml文件部署到kubernetes上。<br>Helm有3个重要概念：</p>
<ul>
<li>helm：一个命令行客户端工具，主要用于kubernetes应用chart的创建、打包、发布和管理</li>
<li>chart：应用描述，一系列用于描述kubernetes资源相关文件的集合</li>
<li>release：基于chart的部署实体，一个chart被Helm运行后将会生成对应的一个release，将在kubernetes中创建出真实运行的资源对象</li>
</ul>
<h1 id="Helm-v3变化"><a href="#Helm-v3变化" class="headerlink" title="Helm v3变化"></a>Helm v3变化</h1><p>2019年11月13日，Helm团队发布Helm v3的第一个稳定版本<br>该版本主要变化如下：</p>
<ul>
<li>最明显的变化是Tiller删除<br><img src="/1.png" alt="1"></li>
<li>release名称可以在不同的命名空间重用</li>
<li>支持将chart推动到Docker镜像仓库中</li>
<li>使用JSONSchema验证chart values</li>
<li>其他</li>
</ul>
<h1 id="Helm-客户端"><a href="#Helm-客户端" class="headerlink" title="Helm 客户端"></a>Helm 客户端</h1><h2 id="部署Helm客户端"><a href="#部署Helm客户端" class="headerlink" title="部署Helm客户端"></a>部署Helm客户端</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载Helm</span></span><br><span class="line">wget https://get.helm.sh/helm-v3.2.1-linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压Helm到/usr/bin目录</span></span><br><span class="line">tar -zxvf helm-v3.2.1-linux-amd64.tar.gz</span><br><span class="line">cd linux-amd64/</span><br><span class="line">cp helm /usr/bin/</span><br></pre></td></tr></table></figure>

<h2 id="配置国内的chart仓库"><a href="#配置国内的chart仓库" class="headerlink" title="配置国内的chart仓库"></a>配置国内的chart仓库</h2><h3 id="仓库概述"><a href="#仓库概述" class="headerlink" title="仓库概述"></a>仓库概述</h3><ul>
<li>微软仓库：<a href="http://mirror.azure.cn/kubernetes/charts%EF%BC%8C%E6%8E%A8%E8%8D%90%EF%BC%8C%E5%9F%BA%E6%9C%AC%E4%B8%8A%E5%AE%98%E7%BD%91%E4%B8%8A%E7%9A%84chart%E8%BF%99%E9%87%8C%E9%83%BD%E6%9C%89">http://mirror.azure.cn/kubernetes/charts，推荐，基本上官网上的chart这里都有</a></li>
<li>阿里云仓库：<a href="https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts">https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</a></li>
<li>官方仓库：<a href="https://hub.kubeapps.com/charts/incubator%EF%BC%8C%E5%BC%BA%E7%83%88%E4%B8%8D%E6%8E%A8%E8%8D%90">https://hub.kubeapps.com/charts/incubator，强烈不推荐</a></li>
</ul>
<h3 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加仓库命令</span></span><br><span class="line">helm repo add 仓库名 仓库地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新仓库命令</span></span><br><span class="line">helm repo update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加并更新仓库</span></span><br><span class="line">helm repo add stable http://mirror.azure.cn/kubernetes/charts</span><br><span class="line">helm repo add aliyun https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure>

<h3 id="删除存储库"><a href="#删除存储库" class="headerlink" title="删除存储库"></a>删除存储库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo remove 仓库名</span><br></pre></td></tr></table></figure>

<h3 id="查看配置的存储库"><a href="#查看配置的存储库" class="headerlink" title="查看配置的存储库"></a>查看配置的存储库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm repo list</span><br></pre></td></tr></table></figure>

<h2 id="helm的常用命令"><a href="#helm的常用命令" class="headerlink" title="helm的常用命令"></a>helm的常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>创建一个chart并指定名字</td>
</tr>
<tr>
<td>dependency</td>
<td>管理chart依赖</td>
</tr>
<tr>
<td>get</td>
<td>下载一个release。可用的子命令：all、hooks、manifest、notes、values。</td>
</tr>
<tr>
<td>history</td>
<td>获取release历史</td>
</tr>
<tr>
<td>install</td>
<td>安装一个chart</td>
</tr>
<tr>
<td>list</td>
<td>列出release</td>
</tr>
<tr>
<td>package</td>
<td>将chart目录打包到chart存档文件中</td>
</tr>
<tr>
<td>pull</td>
<td>从远程仓库中下载chart并解压到本地。比如：helm install stable&#x2F;mysql –untar</td>
</tr>
<tr>
<td>repo</td>
<td>添加、列出、移除、更新和索引chart仓库。可用的子命令：add、index、list、remove、update</td>
</tr>
<tr>
<td>rollback</td>
<td>从之前的版本回退</td>
</tr>
<tr>
<td>search</td>
<td>根据关键字搜索chart。可用的子命令：all、chart、readme、values</td>
</tr>
<tr>
<td>show</td>
<td>查看chart的详细信息。可用的子命令：all、chart、readme、values</td>
</tr>
<tr>
<td>status</td>
<td>显示已命名版本的状态</td>
</tr>
<tr>
<td>template</td>
<td>本地呈现模板</td>
</tr>
<tr>
<td>uninstall</td>
<td>卸载一个release</td>
</tr>
<tr>
<td>upgrade</td>
<td>更新一个release</td>
</tr>
<tr>
<td>version</td>
<td>查看Helm客户端版本</td>
</tr>
</tbody></table>
<h1 id="Helm-基本使用"><a href="#Helm-基本使用" class="headerlink" title="Helm 基本使用"></a>Helm 基本使用</h1><h2 id="使用chart部署一个应用"><a href="#使用chart部署一个应用" class="headerlink" title="使用chart部署一个应用"></a>使用chart部署一个应用</h2><h3 id="根据关键字搜索chart"><a href="#根据关键字搜索chart" class="headerlink" title="根据关键字搜索chart"></a>根据关键字搜索chart</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法</span></span><br><span class="line">helm search repo|hub chart名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：查询名为weave的chart</span></span><br><span class="line">helm search repo weave</span><br></pre></td></tr></table></figure>

<h3 id="查看chart信息"><a href="#查看chart信息" class="headerlink" title="查看chart信息"></a>查看chart信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm show chart 仓库名/chart名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看名为stable的仓库中的名为mysql的chart</span></span><br><span class="line">helm show chart stable/mysql</span><br></pre></td></tr></table></figure>

<h3 id="安装chart，形成release"><a href="#安装chart，形成release" class="headerlink" title="安装chart，形成release"></a>安装chart，形成release</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法</span></span><br><span class="line">helm install 安装之后的名称 仓库名/chart的名称(即搜索之后的应用名称)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装stable/weave-scope，并将其命名为ui</span></span><br><span class="line">helm install ui stable/weave-scope</span><br></pre></td></tr></table></figure>

<h3 id="查看release列表"><a href="#查看release列表" class="headerlink" title="查看release列表"></a>查看release列表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm list</span><br></pre></td></tr></table></figure>

<h3 id="查看已命名release的状态"><a href="#查看已命名release的状态" class="headerlink" title="查看已命名release的状态"></a>查看已命名release的状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法</span></span><br><span class="line">helm status 安装之后的名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看安装chart的release为ui的状态</span></span><br><span class="line">helm status ui</span><br></pre></td></tr></table></figure>

<h3 id="查看Service，并将其改为NodePort"><a href="#查看Service，并将其改为NodePort" class="headerlink" title="查看Service，并将其改为NodePort"></a>查看Service，并将其改为NodePort</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法</span></span><br><span class="line">kubectl edit svc xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Service，并将其改为NodePort</span></span><br><span class="line">kubectl edit svc ui-weave-scope</span><br></pre></td></tr></table></figure>

<h2 id="安装前自定义chart配置选项"><a href="#安装前自定义chart配置选项" class="headerlink" title="安装前自定义chart配置选项"></a>安装前自定义chart配置选项</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>自定义选项是因为并不是所有的chart都能按照默认配置运行成功，可能会需要一些环境依赖，例如PV。<br>所以我们需要自定义chart配置选项，安装过程中有两种方法可以传递配置数据：</p>
<ul>
<li>–values（或-f）：指定带有覆盖的YAML文件。这里可以多次指定，最右边的文件优先。</li>
<li>–set：在命令行上指定替代。如果两种都用，那么–set的优先级高。</li>
</ul>
<h3 id="–values的使用（不推荐，太麻烦）"><a href="#–values的使用（不推荐，太麻烦）" class="headerlink" title="–values的使用（不推荐，太麻烦）"></a>–values的使用（不推荐，太麻烦）</h3><blockquote>
<p>安装可能报错，需要自己手动安装PV。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先将修改的变量写到一个文件中，并修改此文件</span></span><br><span class="line">helm show values stable/mysql &gt; config.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat config.yaml</span></span><br><span class="line"></span><br><span class="line">  <span class="string">--</span> <span class="string">修改部分</span></span><br><span class="line"><span class="attr">persistence:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">accessMode:</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">8Gi</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysqlUser:</span> <span class="string">&quot;k8s&quot;</span></span><br><span class="line"><span class="attr">mysqlPassword:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="attr">mysqlDatabase:</span> <span class="string">&quot;k8s&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用--values来替换默认的配置</span></span><br><span class="line">helm install -f config.yaml self-mysql stable/mysql</span><br></pre></td></tr></table></figure>

<h3 id="命令行替代变量（推荐）"><a href="#命令行替代变量（推荐）" class="headerlink" title="命令行替代变量（推荐）"></a>命令行替代变量（推荐）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以使用命令行替代变量</span></span><br><span class="line">helm install db --set persistence.storageClass=&quot;managed-nfs-storage&quot; stable/mysql</span><br></pre></td></tr></table></figure>

<h1 id="构建一个Helm-Chart"><a href="#构建一个Helm-Chart" class="headerlink" title="构建一个Helm Chart"></a>构建一个Helm Chart</h1><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用helm create创建chart</span></span><br><span class="line">helm create chart名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入自定义chart目录的templates目录中，修改其中的deployment.yaml和service.yaml等文件</span></span><br><span class="line">cd chart名称/templates</span><br></pre></td></tr></table></figure>
<p><img src="/2.png" alt="2"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过刚才创建的chart目录，将其部署</span></span><br><span class="line">helm install xxx chart名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包chart，让别人共享</span></span><br><span class="line">helm package chart名称</span><br></pre></td></tr></table></figure>

<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><blockquote>
<p>示例：本人是在root目录下操作的</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建chart</span></span><br><span class="line">helm create nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入chart目录，修改values.yaml文件，内容如下</span></span><br><span class="line"><span class="comment"># cd nginx</span></span><br><span class="line"><span class="comment"># vim values.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">tag:</span> <span class="number">1.17</span></span><br><span class="line"><span class="attr">serviceport:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">targetport:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">label:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入templates目录</span></span><br><span class="line">cd templates/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除templates目录中的所有文件和文件夹</span></span><br><span class="line">rm -rf *</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改deployment.yaml文件，内容如下</span></span><br><span class="line"><span class="comment"># vim deployment.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">.Release.Name</span> &#125;&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> &#123;&#123; <span class="string">.Values.replicas</span> &#125;&#125;</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> &#123;&#123; <span class="string">.Values.image</span> &#125;&#125;<span class="string">:&#123;&#123;</span> <span class="string">.Values.tag</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">name:</span> &#123;&#123; <span class="string">.Values.image</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改service.yaml文件，内容如下</span></span><br><span class="line"><span class="comment"># vim service.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span>   <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">name:</span>  &#123;&#123; <span class="string">.Release.Name</span> &#125;&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span>  <span class="attr">port:</span> &#123;&#123; <span class="string">.Values.serviceport</span> &#125;&#125;</span><br><span class="line">       <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">       <span class="attr">targetPort:</span> &#123;&#123; <span class="string">.Values.targetport</span> &#125;&#125;</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到chart目录的上一层目录</span></span><br><span class="line">cd ~</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装应用</span></span><br><span class="line">helm install nginx nginx/</span><br></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>Helm也提供了–dry-run和–debug调试参数，帮助你验证模板的正确性。<br>在执行helm install的时候带上这两个参数就可以把对应的values值和渲染的资源清单打印出来，而不是真正的做部署一个release。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install nginx nginx/ --dry-run --debug</span><br></pre></td></tr></table></figure>

<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>上面我们使用的<code>&#123;&#123; .Release.Name &#125;&#125;</code>将release的名称插入到模板中，这里的Release就是Helm的内置对象，下面是一些常用的内置对象：</p>
<table>
<thead>
<tr>
<th>内置对象</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Release.Name</td>
<td>release的名称</td>
</tr>
<tr>
<td>Release.Namespace</td>
<td>release的命名空间</td>
</tr>
<tr>
<td>Release.Service</td>
<td>release的服务的名称</td>
</tr>
<tr>
<td>Release.Revision</td>
<td>release的修订版本号，从1开始累加</td>
</tr>
</tbody></table>
<h2 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h2><p>Values对象是为Chart模板提供值，这个对象的值有4个来源</p>
<ul>
<li>chart包中的values.yaml文件</li>
<li>父chart包的values.yaml文件</li>
<li>通过helm install或者helm upgrade的-f或者–values参数传入的自定义的yaml文件</li>
<li>通过–set参数传入的值</li>
</ul>
<p>Chart的values.yaml提供的值可以被用户提供的values文件覆盖，而该文件同样可以被–set参数所覆盖，换言之，–set参数的优先级高</p>
<h2 id="升级、回滚和删除"><a href="#升级、回滚和删除" class="headerlink" title="升级、回滚和删除"></a>升级、回滚和删除</h2><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发布新版本的chart时，或者当我们需要更改发布的配置，可以使用helm upgrade命令</span></span><br><span class="line">helm upgrade --set imageTag=1.18 nginx nginx</span><br><span class="line"></span><br><span class="line">helm upgrade -f values.yaml nginx nginx</span><br></pre></td></tr></table></figure>
<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果在发布后没有达到预期的效果，则可以使用helm rollback回滚到之前的版本</span></span><br><span class="line">helm rollback nginx 1</span><br></pre></td></tr></table></figure>

<h3 id="卸载发行版本"><a href="#卸载发行版本" class="headerlink" title="卸载发行版本"></a>卸载发行版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载发行版本，可以使用helm uninstall命令</span></span><br><span class="line">helm uninstall nginx</span><br></pre></td></tr></table></figure>

<h3 id="卸载发行版本，可以使用helm-uninstall命令"><a href="#卸载发行版本，可以使用helm-uninstall命令" class="headerlink" title="卸载发行版本，可以使用helm uninstall命令"></a>卸载发行版本，可以使用helm uninstall命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看历史版本配置信息</span></span><br><span class="line">helm get all --revision 1 nginx</span><br></pre></td></tr></table></figure>

<h2 id="管道和函数"><a href="#管道和函数" class="headerlink" title="管道和函数"></a>管道和函数</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>在上面的案例中，其实是将值传递给模板引擎进行渲染，模板引擎还支持对拿到的数据进行二次处理<br>示例：从.Values中读取的值变成字符串，可以使用quote函数实现。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi templates/deployment.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br><span class="line"><span class="attr">app:</span> &#123;&#123; <span class="string">quote</span>  <span class="string">.Values.label.app</span>    &#125;&#125;</span><br><span class="line"><span class="comment"># 略</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install --dry-run nginx ../nginx/ app:&quot;nginx&quot;</span><br></pre></td></tr></table></figure>
<p>quote  .Values.label.app将后面的值作为参数传递过quote函数。<br>模板函数调用语法为：functionName arg1 arg2…</p>
<h3 id="default函数"><a href="#default函数" class="headerlink" title="default函数"></a>default函数</h3><p>default函数运行在模板中指定默认值，以防止该值会忽略掉。如果忘记定义，执行helm install的时候会因为缺少字段而无法创建资源，这时就可以定义一个默认值了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim templates/deployment.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">.Release.Name</span> &#125;&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> &#123;&#123; <span class="string">.Values.replicas</span> &#125;&#125;</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> &#123;&#123; <span class="string">.Values.image|</span> <span class="string">default</span> <span class="string">&quot;nginx&quot;</span> &#125;&#125;<span class="string">:&#123;&#123;</span> <span class="string">.Values.tag</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">name:</span> &#123;&#123; <span class="string">.Values.image</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缩进函数</span></span><br><span class="line">&#123;&#123; <span class="string">.Values.resources</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">12</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大写</span></span><br><span class="line">&#123;&#123; <span class="string">upper</span> <span class="string">.Values.resources</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首字母大写</span></span><br><span class="line">&#123;&#123; <span class="string">title</span> <span class="string">.Values.resources</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>流程控制是为模板提供了一种能力，满足更复杂的数据逻辑处理<br>Helm模板语言提供以下流程控制语句：</p>
<ul>
<li>if&#x2F;else条件块</li>
<li>with指定范围</li>
<li>range循环块</li>
</ul>
<h2 id="if-x2F-else"><a href="#if-x2F-else" class="headerlink" title="if&#x2F;else"></a>if&#x2F;else</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span>/else块是用于在模板有条件的包含文本块的方法，条件块的基本结构如下</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; if 条件表达式&#125;&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xxx</span></span><br><span class="line">&#123;&#123; else if 条件表达式&#125;&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xxx</span></span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xxx</span></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>条件判断：就是判断条件是否为真，如果值为以下几种情况则为false，否则为true:</p>
<ul>
<li>一个布尔类型的false</li>
<li>一个数字0</li>
<li>一个空的字符串</li>
<li>一个空的集合（map、slice、tuple、dict、array）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">.Release.Name</span> &#125;&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> &#123;&#123; <span class="string">.Values.replicas</span> &#125;&#125;</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> &#123;&#123; <span class="string">.Values.image|</span> <span class="string">default</span> <span class="string">&quot;nginx&quot;</span> &#125;&#125;<span class="string">:&#123;&#123;</span> <span class="string">.Values.tag</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">name:</span> &#123;&#123; <span class="string">.Values.image</span> &#125;&#125;</span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            &#123;&#123; <span class="string">if</span> <span class="string">eq</span> <span class="string">.Values.devops</span> <span class="string">&quot;k8s&quot;</span> &#125;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">            &#123;&#123; <span class="string">else</span> &#125;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;456&quot;</span></span><br><span class="line">            &#123;&#123; <span class="string">end</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还可以使用ne、lt、gt、and、or等运算符</p>
</blockquote>
<p>通过模板引擎渲染一下，会得到如下的结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install --dry-run nginx nginx</span><br></pre></td></tr></table></figure>

<p><img src="/3.png" alt="3"></p>
<p>可以看到渲染出来会有多余的空行，这是因为当模板引擎运行的时候，会将控制指令删除，所以之前占的位置也就空白了，需要使用<code>&#123;&#123;- if ...&#125;&#125;</code>的方式消除此空行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">.Release.Name</span> &#125;&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> &#123;&#123; <span class="string">.Values.replicas</span> &#125;&#125;</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> &#123;&#123; <span class="string">.Values.image|</span> <span class="string">default</span> <span class="string">&quot;nginx&quot;</span> &#125;&#125;<span class="string">:&#123;&#123;</span> <span class="string">.Values.tag</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">name:</span> &#123;&#123; <span class="string">.Values.image</span> &#125;&#125;</span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">eq</span> <span class="string">.Values.devops</span> <span class="string">&quot;k8s&quot;</span> &#125;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">else</span> &#125;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;456&quot;</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过模板引擎渲染一下，会得到如下的结果</span></span><br><span class="line">helm install --dry-run nginx nginx</span><br></pre></td></tr></table></figure>
<p><img src="/4.png" alt="4"><br>如果使用了<code>&#123;&#123;- if ... -&#125;&#125;</code>那么就需要谨慎了，比如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">.Release.Name</span> &#125;&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> &#123;&#123; <span class="string">.Values.replicas</span> &#125;&#125;</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> &#123;&#123; <span class="string">.Values.label</span> &#125;&#125;</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> &#123;&#123; <span class="string">.Values.image|</span> <span class="string">default</span> <span class="string">&quot;nginx&quot;</span> &#125;&#125;<span class="string">:&#123;&#123;</span> <span class="string">.Values.tag</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">name:</span> &#123;&#123; <span class="string">.Values.image</span> &#125;&#125;</span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">eq</span> <span class="string">.Values.devops</span> <span class="string">&quot;k8s&quot;</span> <span class="string">-</span>&#125;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">else</span> &#125;&#125;</span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name :</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;456&quot;</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>通过模板引擎渲染一下，会得到如下的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install --dry-run nginx nginx</span><br></pre></td></tr></table></figure>

<p>相当于下面这种格式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">NAME:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">LAST DEPLOYED:</span> <span class="string">Mon</span> <span class="string">Jan</span> <span class="number">11</span> <span class="number">20</span><span class="string">:46:10</span> <span class="number">2021</span></span><br><span class="line"><span class="attr">NAMESPACE:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">STATUS:</span> <span class="string">pending-install</span></span><br><span class="line"><span class="attr">REVISION:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">TEST SUITE:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">HOOKS:</span></span><br><span class="line"><span class="attr">MANIFEST:</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Source: nginx/templates/service.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span>   <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span> </span><br><span class="line">  <span class="attr">name:</span>  <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span>  <span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">       <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">       <span class="attr">targetPort:</span> <span class="number">80</span> </span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span> </span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Source: nginx/templates/deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">env: - name: hello value:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>当然不对，因为<code>&#123;&#123;- if ... -&#125;&#125;</code>删除了双方的换行符。</p>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>在Helm模板语言中，使用range关键字来进行循环操作<br>在values.yaml中添加一个变量列表</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="number">2</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>循环打印该列表</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>    &#123;&#123;   <span class="string">.Release.Name</span>    &#125;&#125; </span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">test:</span>    </span><br><span class="line">    &#123;&#123;<span class="bullet">-</span> <span class="string">range</span> <span class="string">.</span> <span class="string">Values.test</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;   <span class="string">.</span>    &#125;&#125;</span><br><span class="line">    &#123;&#123;<span class="bullet">-</span>   <span class="string">end</span>   &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with可以用来控制变量作用域<br>在前面我们使用<code>&#123;&#123; .Release.xxx &#125;&#125;</code>或者<code>&#123;&#123; .Values.xxx &#125;&#125;</code>，其中.就是表示对当前范围的引用，<code>.values</code>就是告诉模板在当前范围中查找<code>Values</code>对象的值。<br>with语句就可以用来控制变量的作用域范围，其语法和一个简单的if语句类似：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;&#123; with 条件表达式 &#125;&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xxx</span></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>with语句可以允许将当前范围的.设置为特定的对象，比如我们前面一直使用的.Values.label，我们可以使用with来将.范围指向.Values.label</p>
<p>示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># values.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="attr">team:</span> <span class="string">a</span></span><br><span class="line">  <span class="attr">gpu:</span>   <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span>   <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span>   <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">.Release.Name</span> &#125;&#125;<span class="string">-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.nodeSelector</span> &#125;&#125;</span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">team:</span> &#123;&#123;  <span class="string">.team</span> &#125;&#125;</span><br><span class="line">        <span class="attr">gpu:</span> &#123;&#123;  <span class="string">.gpu</span>  &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名模版"><a href="#命名模版" class="headerlink" title="命名模版"></a>命名模版</h2><p>需要复用代码的地方可以使用命名模板。<br>命名模板：使用define定义，template引入，在templates目录中默认下划线开头的文件为公共模板（比如_helpers.tpl）<br>示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _helpers.tpl</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;<span class="bullet">-</span>   <span class="string">define</span>   <span class="string">&quot;demo.fullname&quot;</span>   <span class="string">-</span>&#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">.Chart.Name</span> <span class="string">-</span>&#125;&#125;<span class="string">-&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">&#123;&#123;<span class="bullet">-</span>   <span class="string">end</span>   <span class="string">-</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span>   <span class="string">apps/v1</span> </span><br><span class="line"><span class="attr">kind:</span>   <span class="string">Deployment</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  &#123;&#123;   <span class="string">template&quot;demo.fullname&quot;</span>   <span class="string">.</span>    &#125;&#125;</span><br><span class="line"><span class="comment"># 其他略</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>template指令是将一个模板包含在另一个模板中的方法。但是，template函数不能用于Go模板管道，为了解决该问题，增加了include功能。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _helpers.tpl</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;<span class="bullet">-</span>   <span class="string">define</span>   <span class="string">&quot;demo.labels&quot;</span>    <span class="string">-</span>&#125;&#125;</span><br><span class="line"><span class="attr">app:</span>   &#123;&#123;   <span class="string">template&quot;demo.fullname&quot;</span>   <span class="string">.</span>   &#125;&#125;</span><br><span class="line"><span class="attr">chart:</span>   <span class="string">&quot;<span class="template-variable">&#123;&#123;   .Chart.Name   &#125;&#125;</span>-<span class="template-variable">&#123;&#123;    .Chart.Version   &#125;&#125;</span>&quot;</span> </span><br><span class="line"><span class="attr">release:</span>   <span class="string">&quot;<span class="template-variable">&#123;&#123;   .Release.Name   &#125;&#125;</span>&quot;</span></span><br><span class="line">&#123;&#123;<span class="bullet">-</span>   <span class="string">end</span>   <span class="string">-</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span>   <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span>   <span class="string">Deployment</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>    &#123;&#123;   <span class="string">include&quot;demo.fullname&quot;</span>   <span class="string">.</span>    &#125;&#125; </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    &#123;&#123;<span class="bullet">-</span>   <span class="string">include</span>   <span class="string">&quot;demo.labels&quot;</span>   <span class="string">.</span>    <span class="string">|</span>   <span class="string">nindent</span>   <span class="number">4</span>    &#125;&#125;</span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面包含一个名为demo.labels的模板，然后将值  . 传递给模板，最后将该模板的 输出传递给nindent函数</p>
</blockquote>
<h1 id="开发自己的chart"><a href="#开发自己的chart" class="headerlink" title="开发自己的chart"></a>开发自己的chart</h1><ul>
<li>创建模板</li>
<li>修改Chart.yaml，Values.yaml，添加常用的变量</li>
<li>在templates目录下创建部署镜像所需要的yaml文件，并使用变量引用yaml文件里面经常变动的字段</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（十五）- K8S的安全认证</title>
    <url>/2022/04/04/k8s-study-notes-15/</url>
    <content><![CDATA[<h1 id="访问控制概述"><a href="#访问控制概述" class="headerlink" title="访问控制概述"></a>访问控制概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对kubernetes的各种客户端进行认证和授权操作</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>在kubernetes集群中，客户端通常由两类</p>
<ul>
<li>User Account：一般是独立于kubernetes之外的其他服务管理的用户账号</li>
<li>Service Account：kubernetes管理的账号，用于为Pod的服务进程在访问kubernetes时提供身份标识。<br><img src="/1.png" alt="1"></li>
</ul>
<h2 id="认证、授权和准入控制"><a href="#认证、授权和准入控制" class="headerlink" title="认证、授权和准入控制"></a>认证、授权和准入控制</h2><p>API Server是访问和管理资源对象的唯一入口。<br>任何一个请求访问API Server，都要经过下面的三个流程</p>
<ul>
<li>Authentication（认证）：身份鉴别，只有正确的账号才能通过认证</li>
<li>Authorization（授权）：判断用户是否有权限对访问的资源执行特定的动作</li>
<li>Admission Control（注入控制）：用于补充授权机制以实现更加精细的访问控制功能<br><img src="/2.png" alt="2"></li>
</ul>
<h1 id="认证管理"><a href="#认证管理" class="headerlink" title="认证管理"></a>认证管理</h1><h2 id="kubernetes的客户端身份认证方式"><a href="#kubernetes的客户端身份认证方式" class="headerlink" title="kubernetes的客户端身份认证方式"></a>kubernetes的客户端身份认证方式</h2><p>kubernetes集群安全的关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式</p>
<ul>
<li>HTTP Base认证<ul>
<li>通过用户名+密码的方式进行认证</li>
<li>这种方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header的Authorization域里面发送给服务端。服务端收到后进行解码，获取用户名和密码，然后进行用户身份认证的过程</li>
</ul>
</li>
<li>HTTP Token认证<ul>
<li>通过一个Token来识别合法用户</li>
<li>这种认证方式是用一个很长的难以被模仿的字符串–Token来表明客户端身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求的时候，需要在HTTP的Header中放入Token，API Server接受到Token后会和服务器中保存的Token进行比对，然后进行用户身份认证的过程</li>
</ul>
</li>
<li>HTTPS证书认证<ul>
<li>基于CA根证书签名的双向数字证书认证方式</li>
<li>这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式</li>
</ul>
</li>
</ul>
<p><img src="/3.png" alt="3"></p>
<h2 id="HTTPS认证过程"><a href="#HTTPS认证过程" class="headerlink" title="HTTPS认证过程"></a>HTTPS认证过程</h2><ul>
<li>证书申请和下发：HTTPS通信双方的服务器向CA机构申请证书，CA机构发根证书、服务端证书及私钥给申请者</li>
<li>客户端和服务器的双向认证<ul>
<li>客户端向服务端发起请求，服务端下发自己的证书给客户端。客户端收到证书后，通过私钥解密证书，在证书中获取服务端的私钥。客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器</li>
<li>客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书。在证书中获取客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法</li>
</ul>
</li>
<li>服务器端和客户端进行通信<ul>
<li>服务器端和客户端协商好加密方案后，客户端会产生一个随机的私钥并加密，然后发送到服务器端</li>
<li>服务器端接收到这个私钥后，双方接下来通信的所有内容都通过该随机私钥加密</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kubernetes允许同时配置多种认证方式，只要其中任意一种方式认证通过即可</p>
<h1 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>授权发生在认证成功之后，通过认证就可以知道请求用户是谁，然后kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权<br>每个发送到API Server的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误</p>
<h2 id="API-Server目前支持的几种授权策略"><a href="#API-Server目前支持的几种授权策略" class="headerlink" title="API Server目前支持的几种授权策略"></a>API Server目前支持的几种授权策略</h2><ul>
<li>AlwaysDeny：表示拒绝所有请求，一般用于测试</li>
<li>AlwaysAllow：允许接收所有的请求，相当于集群不需要授权流程（kubernetes默认的策略）</li>
<li>ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li>
<li>Webhook：通过调用外部REST服务对用户进行授权</li>
<li>Node：是一种专用模式，用于对kubelet发出的请求进行访问控制 </li>
<li>RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）</li>
</ul>
<h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>RBAC（Role Based Access Control）：基于角色的访问控制，主要是在描述一件事情：给哪些对象授权了哪些权限<br>RBAC涉及到了下面几个概念：</p>
<ul>
<li>对象：User、Groups、ServiceAccount</li>
<li>角色：代表着一组定义在资源上的可操作的动作（权限）的集合</li>
<li>绑定：将定义好的角色和用户绑定在一起<br><img src="/4.png" alt="4"></li>
</ul>
<p>RBAC还引入了4个顶级资源对象</p>
<ul>
<li>Role、ClusterRole：角色，用于指定一组权限</li>
<li>RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限的集合）赋予给对象</li>
</ul>
<h3 id="Role、ClusterRole"><a href="#Role、ClusterRole" class="headerlink" title="Role、ClusterRole"></a>Role、ClusterRole</h3><p>一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）<br>Role的资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Role只能对命名空间的资源进行授权，需要指定namespace</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># 支持的API组列表，&quot;&quot;空字符串，表示核心API群</span></span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>] <span class="comment"># 支持的资源对象列表</span></span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>,<span class="string">&quot;watch&quot;</span>,<span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>ClusterRole的资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ClusterRole可以对集群范围内的资源、跨namespace的范围资源、非资源类型进行授权</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># 支持的API组列表，&quot;&quot;空字符串，表示核心API群</span></span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>] <span class="comment"># 支持的资源对象列表</span></span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>,<span class="string">&quot;watch&quot;</span>,<span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>rules中的参数说明：</p>
<ul>
<li>apiGroups：<ul>
<li>支持的API组列表。</li>
<li>“”,”apps”,”autoscaling”,”batch”</li>
</ul>
</li>
<li>resources：<ul>
<li>支持的资源对象列表。</li>
<li>“services”,”endpoints”,”pods”,”secrets”,”configmaps”,”crontabs”,”deployments”,”jobs”,”nodes”,”rolebindings”,”clusterroles”,”daemonsets”,”replicasets”,”statefulsets”,”horizontalpodautoscalers”,”replicationcontrollers”,”cronjobs”</li>
</ul>
</li>
<li>verbs：<ul>
<li>对资源对象的操作方法列表。</li>
<li>“get”, “list”, “watch”, “create”, “update”, “patch”, “delete”, “exec”</li>
</ul>
</li>
</ul>
<h3 id="RoleBinding、ClusterRoleBinding"><a href="#RoleBinding、ClusterRoleBinding" class="headerlink" title="RoleBinding、ClusterRoleBinding"></a>RoleBinding、ClusterRoleBinding</h3><p>角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是User、Group或者ServiceAccount<br>RoleBinding的资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RoleBinding可以将同一namespace中的subject对象绑定到某个Role下，则此Subject具有该Role定义的权限</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">xudaxian</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span>  </span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br></pre></td></tr></table></figure>
<p>ClusterRoleBinding的资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">xudaxian</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br></pre></td></tr></table></figure>

<h3 id="RoleBinding引用ClusterRole进行授权"><a href="#RoleBinding引用ClusterRole进行授权" class="headerlink" title="RoleBinding引用ClusterRole进行授权"></a>RoleBinding引用ClusterRole进行授权</h3><p>RoleBinding可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权<br>一种很常用的做法是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。<br>这样可以大幅度提高授权管理工作效率，也使得各个命名空间下的基础性授权规则和使用体验保持一致。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding</span></span><br><span class="line"><span class="comment"># 所以xudaxian只能读取dev命名空间中的资源</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">xudaxian</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br></pre></td></tr></table></figure>

<h2 id="RBAC实战"><a href="#RBAC实战" class="headerlink" title="RBAC实战"></a>RBAC实战</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>创建一个只能管理dev命名空间下Pods资源的账号</p>
<h3 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建证书</span></span><br><span class="line">cd /etc/kubernetes/pki/</span><br><span class="line">(umask 077;openssl genrsa -out devman.key 2048)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用API Server的证书去签署证书</span></span><br><span class="line">openssl req -new -key devman.key -out devman.csr -subj &quot;/CN=devman/O=devgroup&quot;  # 签名申请：申请的用户是devman，组是devgroup</span><br><span class="line">openssl x509 -req -in devman.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out devman.crt -days 3650  # 签署证书</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置集群、用户、上下文信息</span></span><br><span class="line">kubectl config set-cluster kubernetes --embed-certs=true --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.18.100:6443</span><br><span class="line">kubectl config set-credentials devman --embed-certs=true --client-certificate=/etc/kubernetes/pki/devman.crt --client-key=/etc/kubernetes/pki/devman.key</span><br><span class="line">kubectl config set-context devman@kubernetes --cluster=kubernetes --user=devman</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换账号到devman</span></span><br><span class="line">kubectl config use-context devman@kubernetes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看dev下的Pod，发现没有权限</span></span><br><span class="line">kubectl get pods -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到admin账户</span></span><br><span class="line">kubectl config use-context kubernetes-admin@kubernetes</span><br></pre></td></tr></table></figure>

<h3 id="创建Role和RoleBinding，为devman授权"><a href="#创建Role和RoleBinding，为devman授权" class="headerlink" title="创建Role和RoleBinding，为devman授权"></a>创建Role和RoleBinding，为devman授权</h3><p>创建dev-role.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-role</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># 支持的API组列表，&quot;&quot;空字符串，表示核心API群</span></span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>] <span class="comment"># 支持的资源对象列表</span></span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>,<span class="string">&quot;watch&quot;</span>,<span class="string">&quot;list&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding</span> </span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">devman</span></span><br><span class="line">    <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span> </span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Role和RoleBinding</span></span><br><span class="line">kubectl create -f dev-role.yaml</span><br></pre></td></tr></table></figure>

<h3 id="切换账户，再次验证"><a href="#切换账户，再次验证" class="headerlink" title="切换账户，再次验证"></a>切换账户，再次验证</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换账户到devman</span></span><br><span class="line">kubectl config use-context devman@kubernetes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次查看</span></span><br><span class="line">kubectl get pod -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切回admin账户</span></span><br><span class="line">kubectl config use-context kubernetes-admin@kubernetes</span><br></pre></td></tr></table></figure>

<h1 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>通过了前面的认证和授权之后，还需要经过准入控制通过之后，API Server才会处理这个请求<br>准入控制是一个可配置的控制器列表，可以通过在API Server上通过命令行设置选择执行哪些注入控制器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds</span><br></pre></td></tr></table></figure>
<p>只有当所有的注入控制器都检查通过之后，API Server才会执行该请求，否则返回拒绝。</p>
<h2 id="当前可配置的Admission-Control（准入控制）"><a href="#当前可配置的Admission-Control（准入控制）" class="headerlink" title="当前可配置的Admission Control（准入控制）"></a>当前可配置的Admission Control（准入控制）</h2><ul>
<li>AlwaysAdmit：允许所有请求。</li>
<li>AlwaysDeny：禁止所有请求，一般用于测试。</li>
<li>AlwaysPullImages：在启动容器之前总去下载镜像。</li>
<li>DenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求。</li>
<li>ImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。</li>
<li>Service Account：实现ServiceAccount实现了自动化。</li>
<li>SecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效。</li>
<li>ResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标。</li>
<li>LimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制。</li>
<li>InitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置。</li>
<li>NamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒 绝。当删除一个namespace时，系统将会删除该namespace中所有对象。</li>
<li>DefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节。</li>
<li>DefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min。</li>
<li>PodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的 PodSecurityPolicy对Pod的安全策略进行控制</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（二）- K8S集群搭建（v1.18.0）</title>
    <url>/2022/03/06/k8s-study-notes-2/</url>
    <content><![CDATA[<h1 id="环境规划"><a href="#环境规划" class="headerlink" title="环境规划"></a>环境规划</h1><h2 id="集群类型"><a href="#集群类型" class="headerlink" title="集群类型"></a>集群类型</h2><blockquote>
<p>Kubernetes集群大致分为两类：一主多从和多主多从<br>本次搭建主要以学习为主，将使用一主多从的集群类型<br><img src="/1.png" alt="1"></p>
</blockquote>
<ul>
<li>一主多从：一个Master节点和多台Node节点，搭建简单，但是有单机故障风险，适合用于测试环境。</li>
<li>多主多从：多台Master和多台Node节点，搭建麻烦，安全性高，适合用于生产环境。</li>
</ul>
<h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><blockquote>
<p>kubernetes有多种部署方式，目前主流的方式有kubeadm、minikube、二进制包<br>我们需要安装kubernetes的集群环境，但是又不想过于麻烦，所以选择kubeadm方式</p>
</blockquote>
<ul>
<li>minikube：一个用于快速搭建单节点的kubernetes工具</li>
<li>kubeadm：一个用于快速搭建kubernetes集群的工具</li>
<li>二进制包：从官网上下载每个组件的二进制包，依次去安装，此方式对于理解kubernetes组件更加有效</li>
</ul>
<h2 id="主机规划"><a href="#主机规划" class="headerlink" title="主机规划"></a>主机规划</h2><table>
<thead>
<tr>
<th>节点类型</th>
<th>IP</th>
<th>OS</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>Master</td>
<td>192.168.200.100</td>
<td>CentOS 7.9</td>
<td>2C2G + 50G</td>
</tr>
<tr>
<td>Node 1</td>
<td>192.168.200.101</td>
<td>CentOS 7.9</td>
<td>2C2G + 50G</td>
</tr>
<tr>
<td>Node 2</td>
<td>192.168.200.102</td>
<td>CentOS 7.9</td>
<td>2C2G + 50G</td>
</tr>
</tbody></table>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><blockquote>
<p>本次环境搭建需要三台CentOS服务器（一主二从），然后在每台服务器中分别安装Docker（18.06.3）、kubeadm（1.18.0）、kubectl（1.18.0）和kubelet（1.18.0）。<br>没有特殊说明，就是三台机器都需要执行。<br>本文使用虚拟机进行环境搭建，虚拟机安装配置，请自行学习完成。</p>
</blockquote>
<h2 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h2><h3 id="确定操作系统版本"><a href="#确定操作系统版本" class="headerlink" title="确定操作系统版本"></a>确定操作系统版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>

<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">getenforce</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时关闭，重启后失效</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启后生效</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 SELINUX 为 disabled</span></span><br><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure>

<h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.200.100</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.200.101</span></span><br><span class="line">hostnamectl set-hostname k8s-node1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.200.102</span></span><br><span class="line">hostnamectl set-hostname k8s-node2</span><br></pre></td></tr></table></figure>

<h3 id="修改主机名解析"><a href="#修改主机名解析" class="headerlink" title="修改主机名解析"></a>修改主机名解析</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.200.100 k8s-master</span><br><span class="line">192.168.200.101 k8s-node1</span><br><span class="line">192.168.200.102 k8s-node2</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><blockquote>
<p>kubernetes要求集群中的节点时间必须精确一致，所以在每个节点上添加时间同步</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate ntp.aliyun.com</span><br></pre></td></tr></table></figure>

<h3 id="关闭swap分区"><a href="#关闭swap分区" class="headerlink" title="关闭swap分区"></a>关闭swap分区</h3><blockquote>
<p>swap分区会在系统资源不够的情况下，将磁盘作为内存使用，然而磁盘的读写性能远不及内存<br>所以k8s是要求每个节点都禁用swap分区</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时关闭</span></span><br><span class="line">swapoff -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注释掉swap分区即可</span></span><br><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure>

<h3 id="将桥接的IPv4流量传递到iptables的链"><a href="#将桥接的IPv4流量传递到iptables的链" class="headerlink" title="将桥接的IPv4流量传递到iptables的链"></a>将桥接的IPv4流量传递到iptables的链</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">vm.swappiness = 0</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载br_netfilter模块</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否加载</span></span><br><span class="line">lsmod | grep br_netfilter</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="开启ipvs"><a href="#开启ipvs" class="headerlink" title="开启ipvs"></a>开启ipvs</h3><blockquote>
<p>在kubernetes中service有两种代理模型，一种是基于iptables，另一种是基于ipvs的。ipvs的性能要高于iptables的，但是如果要使用它，需要手动载入ipvs模块</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install ipset ipvsadm</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">授权、运行、检查是否加载</span></span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">bash /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>

<h3 id="重启一下三台机器"><a href="#重启一下三台机器" class="headerlink" title="重启一下三台机器"></a>重启一下三台机器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="安装docker，kubeadm，kubelet，kubectl"><a href="#安装docker，kubeadm，kubelet，kubectl" class="headerlink" title="安装docker，kubeadm，kubelet，kubectl"></a>安装docker，kubeadm，kubelet，kubectl</h2><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum -y install docker-ce-18.06.3.ce-3.el7</span><br><span class="line"></span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure>

<h3 id="设置docker镜像加速器"><a href="#设置docker镜像加速器" class="headerlink" title="设置docker镜像加速器"></a>设置docker镜像加速器</h3><blockquote>
<p><a href="https://ps5u5ikq.mirror.aliyuncs.com/">https://ps5u5ikq.mirror.aliyuncs.com</a> 是我申请的，都可以用，也可以自己去阿里云申请</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://ps5u5ikq.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="添加阿里云yum源"><a href="#添加阿里云yum源" class="headerlink" title="添加阿里云yum源"></a>添加阿里云yum源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="安装kubeadm、kubelet和kubectl"><a href="#安装kubeadm、kubelet和kubectl" class="headerlink" title="安装kubeadm、kubelet和kubectl"></a>安装kubeadm、kubelet和kubectl</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由于版本更新频繁，这里指定版本号部署</span></span><br><span class="line">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br></pre></td></tr></table></figure>

<p>为了实现Docker使用的cgroup drvier和kubelet使用的cgroup drver一致，建议修改”&#x2F;etc&#x2F;sysconfig&#x2F;kubelet”文件的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">KUBELET_EXTRA_ARGS=<span class="string">&quot;--cgroup-driver=systemd&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">KUBE_PROXY_MODE=<span class="string">&quot;ipvs&quot;</span></span></span><br><span class="line">vim /etc/sysconfig/kubelet</span><br><span class="line"></span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>

<h2 id="查看K8S所需镜像"><a href="#查看K8S所需镜像" class="headerlink" title="查看K8S所需镜像"></a>查看K8S所需镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm config images list</span><br></pre></td></tr></table></figure>

<h2 id="部署master节点"><a href="#部署master节点" class="headerlink" title="部署master节点"></a>部署master节点</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里需要指定阿里云镜像仓库地址</span></span><br><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.200.100 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.18.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<p>根据提示消息，在Master节点配置kube config</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>

<h2 id="部署node节点"><a href="#部署node节点" class="headerlink" title="部署node节点"></a>部署node节点</h2><p>根据提示，在192.168.200.101和192.168.200.102上添加如下的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.200.100:6443 --token bbzspl.kqudl7akg824xzu1 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:811c7a9f9d8d1582342a0c30469a3d62927a11b55e9af3c186ad4b662ebd9a58</span><br></pre></td></tr></table></figure>

<p>默认的token有效期为2小时，当过期之后，该token就不能用了，这时可以使用如下的命令创建token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm token create --print-join-command</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成一个永不过期的token</span></span><br><span class="line">kubeadm token create --ttl 0 --print-join-command</span><br></pre></td></tr></table></figure>

<p>查看node是否加入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里应该还没有部署CNI网络插件，所有node都是not ready的状态</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<h2 id="部署CNI网络插件"><a href="#部署CNI网络插件" class="headerlink" title="部署CNI网络插件"></a>部署CNI网络插件</h2><blockquote>
<p>kubernetes支持多种网络插件，比如flannel、calico、canal等，任选一种即可，我们这里选择使用calico</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/bob-zou/bob-zou.github.io/master/asserts/calico.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>

<p>查看部署CNI网络插件进度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>

<p>等待部署完成再次查看 node状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集群健康状况</span></span><br><span class="line">kubectl get cs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群信息</span></span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure>

<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><blockquote>
<p>在Kubernetes集群中部署一个Nginx程序，测试下集群是否正常工作</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署Nginx</span></span><br><span class="line">kubectl create deployment nginx --image=nginx:1.14-alpine</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暴露端口</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看服务状态</span></span><br><span class="line">kubectl get pods,svc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问nginx</span></span><br><span class="line">curl 192.168.200.100:30305</span><br></pre></td></tr></table></figure>

<h1 id="kubernetes中kubectl命令自动补全"><a href="#kubernetes中kubectl命令自动补全" class="headerlink" title="kubernetes中kubectl命令自动补全"></a>kubernetes中kubectl命令自动补全</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y bash-completion</span><br><span class="line"></span><br><span class="line">echo &quot;source /usr/share/bash-completion/bash_completion&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（三）- K8S资源管理</title>
    <url>/2022/03/06/k8s-study-notes-3/</url>
    <content><![CDATA[<h1 id="资源管理介绍"><a href="#资源管理介绍" class="headerlink" title="资源管理介绍"></a>资源管理介绍</h1><blockquote>
<p>在Kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理Kubernetes。<br>学习kubernetes的核心，就是学习如何对集群中的Pod、Pod控制器、Service、存储等各种资源进行操作。</p>
</blockquote>
<ul>
<li>Kubernetes的本质就是一个集群系统，用户可以在集群中部署各种服务。所谓的部署服务，其实就是在Kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</li>
<li>Kubernetes的最小管理单元是<code>Pod</code>而不是容器，所以只能将容器放在<code>Pod</code>中，而Kubernetes一般也不会直接管理<code>Pod</code>，而是通过<code>Pod控制器</code>来管理<code>Pod</code>的.</li>
<li><code>Pod</code>提供服务之后，就需要考虑如何访问<code>Pod</code>中的服务，Kubernetes提供了<code>Service</code>资源实现这个功能。</li>
<li>当然，如果<code>Pod</code>中程序的数据需要持久化，Kubernetes还提供了各种<code>存储</code>系统。<br><img src="/1.png" alt="1"></li>
</ul>
<h1 id="资源管理方式"><a href="#资源管理方式" class="headerlink" title="资源管理方式"></a>资源管理方式</h1><ul>
<li>命令式对象管理：直接使用命令去操作kubernetes的资源<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl run nginx-pod --image=nginx:1.17.1 --port=80</span><br></pre></td></tr></table></figure></li>
<li>命令式对象配置：通过命令配置和配置文件去操作kubernetes的资源<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create/patch -f nginx-pod.yaml</span><br></pre></td></tr></table></figure></li>
<li>声明式对象配置：通过apply命令和配置文件去操作kubernetes的资源<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-pod.yaml</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>管理方式</th>
<th>操作</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>命令式对象管理</td>
<td>对象</td>
<td>测试</td>
<td>简单</td>
<td>只能操作活动对象，无法审计、跟踪</td>
</tr>
<tr>
<td>命令式对象配置</td>
<td>文件</td>
<td>开发</td>
<td>可以审计，追踪</td>
<td>项目大的时候，配置文件多，操作麻烦</td>
</tr>
<tr>
<td>声明式对象配置</td>
<td>目录</td>
<td>开发</td>
<td>支持目录操作</td>
<td>意外情况下难以调试</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="命令式对象管理"><a href="#命令式对象管理" class="headerlink" title="命令式对象管理"></a>命令式对象管理</h2><h3 id="kubectl命令"><a href="#kubectl命令" class="headerlink" title="kubectl命令"></a>kubectl命令</h3><blockquote>
<p>kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署。</p>
</blockquote>
<h4 id="命令的语法如下"><a href="#命令的语法如下" class="headerlink" title="命令的语法如下"></a>命令的语法如下</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl [command] [type] [name] [flags]</span><br></pre></td></tr></table></figure>
<ul>
<li>command：指定要对资源执行的操作，比如create、get、delete</li>
<li>type：指定资源的类型，比如deployment、pod、service</li>
<li>name：指定资源的名称，名称大小写敏感</li>
<li>flags：指定额外的可选参数</li>
</ul>
<h4 id="操作（command）"><a href="#操作（command）" class="headerlink" title="操作（command）"></a>操作（command）</h4><blockquote>
<p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令</p>
</blockquote>
<h5 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>翻译</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>创建</td>
<td>创建一个资源</td>
</tr>
<tr>
<td>edit</td>
<td>编辑</td>
<td>编辑一个资源</td>
</tr>
<tr>
<td>get</td>
<td>获取</td>
<td>获取一个资源</td>
</tr>
<tr>
<td>patch</td>
<td>更新</td>
<td>更新一个资源</td>
</tr>
<tr>
<td>delete</td>
<td>删除</td>
<td>删除一个资源</td>
</tr>
<tr>
<td>explain</td>
<td>解释</td>
<td>展示资源文档</td>
</tr>
</tbody></table>
<h5 id="运行和调试"><a href="#运行和调试" class="headerlink" title="运行和调试"></a>运行和调试</h5><table>
<thead>
<tr>
<th>命令</th>
<th>翻译</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>run</td>
<td>运行</td>
<td>在集群中运行一个指定的镜像</td>
</tr>
<tr>
<td>expose</td>
<td>暴露</td>
<td>暴露资源为Service</td>
</tr>
<tr>
<td>describe</td>
<td>描述</td>
<td>显示资源内部信息</td>
</tr>
<tr>
<td>logs</td>
<td>日志</td>
<td>输出容器在Pod中的日志</td>
</tr>
<tr>
<td>attach</td>
<td>追加</td>
<td>进入运行中的容器</td>
</tr>
<tr>
<td>exec</td>
<td>执行</td>
<td>执行容器中的一个命令</td>
</tr>
<tr>
<td>cp</td>
<td>负责</td>
<td>在Pod内外复制文件</td>
</tr>
<tr>
<td>rollout</td>
<td>回滚</td>
<td>管理资源的发布</td>
</tr>
<tr>
<td>scale</td>
<td>扩缩容</td>
<td>扩（缩）容Pod的数量</td>
</tr>
<tr>
<td>autocale</td>
<td>自动扩缩容</td>
<td>自动调整Pod的数量</td>
</tr>
</tbody></table>
<h5 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>翻译</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>apply</td>
<td>应用</td>
<td>通过文件对资源进行配置</td>
</tr>
<tr>
<td>label</td>
<td>标签</td>
<td>更新资源上的标签</td>
</tr>
</tbody></table>
<h5 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>翻译</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cluster-info</td>
<td>集群信息</td>
<td>显示集群信息</td>
</tr>
<tr>
<td>version</td>
<td>版本</td>
<td>显示当前Client和Server的版本</td>
</tr>
</tbody></table>
<h4 id="资源类型（type）"><a href="#资源类型（type）" class="headerlink" title="资源类型（type）"></a>资源类型（type）</h4><blockquote>
<p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl api-resources</span><br></pre></td></tr></table></figure>
<p>下面列举一下常用的资源</p>
<h5 id="集群级别资源"><a href="#集群级别资源" class="headerlink" title="集群级别资源"></a>集群级别资源</h5><table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>nodes</td>
<td>no</td>
<td>集群组成部分</td>
</tr>
<tr>
<td>namespaces</td>
<td>ns</td>
<td>隔离Pod</td>
</tr>
</tbody></table>
<h5 id="Pod资源"><a href="#Pod资源" class="headerlink" title="Pod资源"></a>Pod资源</h5><table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Pods</td>
<td>po</td>
<td>装载容器</td>
</tr>
</tbody></table>
<h5 id="Pod资源控制器"><a href="#Pod资源控制器" class="headerlink" title="Pod资源控制器"></a>Pod资源控制器</h5><table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>replicationcontrollers</td>
<td>rc</td>
<td>控制Pod资源</td>
</tr>
<tr>
<td>replicasets</td>
<td>rs</td>
<td>控制Pod资源</td>
</tr>
<tr>
<td>deployments</td>
<td>deploy</td>
<td>控制Pod资源</td>
</tr>
<tr>
<td>daemonsets</td>
<td>ds</td>
<td>控制Pod资源</td>
</tr>
<tr>
<td>jobs</td>
<td></td>
<td>控制Pod资源</td>
</tr>
<tr>
<td>cronjobs</td>
<td>cj</td>
<td>控制Pod资源</td>
</tr>
<tr>
<td>horizontalpodautoscalers</td>
<td>hpa</td>
<td>控制Pod资源</td>
</tr>
<tr>
<td>statefulsets</td>
<td>sts</td>
<td>控制Pod资源</td>
</tr>
</tbody></table>
<h5 id="服务发现资源"><a href="#服务发现资源" class="headerlink" title="服务发现资源"></a>服务发现资源</h5><table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>services</td>
<td>svc</td>
<td>统一Pod对外接口</td>
</tr>
<tr>
<td>ingress</td>
<td>ing</td>
<td>统一Pod对外接口</td>
</tr>
</tbody></table>
<h5 id="存储资源"><a href="#存储资源" class="headerlink" title="存储资源"></a>存储资源</h5><table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>volumeattachments</td>
<td></td>
<td>存储</td>
</tr>
<tr>
<td>persistentvolumes</td>
<td>pv</td>
<td>存储</td>
</tr>
<tr>
<td>persistentvolumeclaims</td>
<td>pvc</td>
<td>存储</td>
</tr>
</tbody></table>
<h5 id="配置资源"><a href="#配置资源" class="headerlink" title="配置资源"></a>配置资源</h5><table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>configmaps</td>
<td>cm</td>
<td>配置</td>
</tr>
<tr>
<td>secrets</td>
<td></td>
<td>配置</td>
</tr>
</tbody></table>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create ns dev</span><br><span class="line">kubectl run nginx --image=nginx:1.17.1 -n dev</span><br><span class="line">kubectl get pods -n dev</span><br><span class="line">kubectl delete pod nginx -n dev</span><br><span class="line">kubectl delete ns dev</span><br></pre></td></tr></table></figure>

<h2 id="命令式对象配置"><a href="#命令式对象配置" class="headerlink" title="命令式对象配置"></a>命令式对象配置</h2><blockquote>
<p>通过命令配置和配置文件去操作kubernetes的资源<br>命令式对象配置的方式操作资源，可以简单的认为：命令+yaml配置文件（里面是命令需要的各种参数）</p>
</blockquote>
<p>新建一个 nginxpod.yaml 文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginxpod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-containers</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">kubectl create -f nginxpod.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get -f nginxpod.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">kubectl delete -f nginxpod.yaml</span><br></pre></td></tr></table></figure>

<h2 id="声明式对象配置"><a href="#声明式对象配置" class="headerlink" title="声明式对象配置"></a>声明式对象配置</h2><blockquote>
<p>通过apply命令和配置文件去操作kubernetes的资源。<br>声明式对象配置和命令式对象配置类似，只不过它只有一个apply命令。<br>apply相当于create和patch。<br>声明式对象配置就是使用apply描述一个资源的最终状态（在yaml中定义状态）</p>
</blockquote>
<p>我们继续使用上面 nginxpod.yaml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginxpod.yaml</span><br></pre></td></tr></table></figure>

<h2 id="使用方式推荐"><a href="#使用方式推荐" class="headerlink" title="使用方式推荐"></a>使用方式推荐</h2><ul>
<li>创建和更新资源使用声明式对象配置：kubectl apply -f xxx.yaml。 </li>
<li>删除资源使用命令式对象配置：kubectl delete -f xxx.yaml。 </li>
<li>查询资源使用命令式对象管理：kubectl get(describe) 资源名称。</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（四）- 实战入门</title>
    <url>/2022/03/06/k8s-study-notes-4/</url>
    <content><![CDATA[<blockquote>
<p>介绍如何在kubernetes集群中部署一个Nginx服务，并且能够对其访问</p>
</blockquote>
<h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Namespace是kubernetes系统中一种非常重要的资源，它的主要作用是用来实现<code>多套系统的资源隔离</code>或者<code>多租户的资源隔离</code></li>
<li>默认情况下，kubernetes集群中的所有Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那么此时就可以将两个Pod划分到不同的Namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的“组”，以方便不同的组的资源进行隔离使用和管理</li>
<li>可以通过kubernetes的授权机制，将不同的Namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理</li>
</ul>
<h2 id="默认的几个namespace"><a href="#默认的几个namespace" class="headerlink" title="默认的几个namespace"></a>默认的几个namespace</h2><ul>
<li>default：所有未指定的Namespace的对象都会被分配在default命名空间。</li>
<li>kube-node-lease：集群节点之间的心跳维护，v1.13开始引入。</li>
<li>kube-public：此命名空间的资源可以被所有人访问（包括未认证用户）。</li>
<li>kube-system：所有由kubernetes系统创建的资源都处于这个命名空间。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个ns dev</span> </span><br><span class="line">kubectl create ns dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ns</span></span><br><span class="line">kubectl get ns dev -o wide</span><br><span class="line">kubectl get ns dev -o json</span><br><span class="line">kubectl get ns dev -o yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ns详情</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里会显示出命名空间的资源限制（包括每个组件的资源限制）</span></span><br><span class="line">kubectl describe ns dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除ns dev</span></span><br><span class="line">kubectl delete ns dev</span><br></pre></td></tr></table></figure>

<h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。</li>
<li>Pod可以认为是容器的封装，一个Pod中可以存在一个或多个容器。</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个pod</span></span><br><span class="line">kubectl run nginx --image=nginx:1.17.1 --port=80 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询名称为dev的namespace下的所有Pod的基本信息</span></span><br><span class="line">kubectl get pod nginx -n dev</span><br><span class="line">kubectl get pod nginx -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod的详细信息</span></span><br><span class="line">kubectl describe pod nginx -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除Nginx的Pod</span></span><br><span class="line">kubectl delete pod nginx -n dev</span><br></pre></td></tr></table></figure>

<h1 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Label是kubernetes的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</li>
<li>Label的特点<ul>
<li>一个Label会以key&#x2F;value键值对的形式附加到各种对象上，如Node、Pod、Service等</li>
<li>一个资源对象可以定义任意数量的Label，同一个Label也可以被添加到任意数量的资源对象上去</li>
<li>Label通常在资源对象定义时确定，当然也可以在对象创建后动态的添加或删除</li>
</ul>
</li>
<li>可以通过Label实现资源的多纬度分组，以便灵活、方便地进行资源分配、调度、配置和部署等管理工作</li>
<li>标签定义完毕之后，还要考虑到标签的选择，这就要用到Label Selector，即<ul>
<li>Label用于给某个资源对象定义标识</li>
<li>Label Selector用于查询和筛选拥有某些标签的资源对象</li>
</ul>
</li>
<li>当前有两种Label Selector<ul>
<li>基于等式的Label Selector<ul>
<li>name&#x3D;slave：选择所有包含Label中的key&#x3D;“name”并且value&#x3D;“slave”的对象</li>
<li>env!&#x3D;production：选择所有包含Label中的key&#x3D;“env”并且value!&#x3D;“production”的对象</li>
</ul>
</li>
<li>基于集合的Label Selector<ul>
<li>name in (master,slave)：选择所有包含Label中的key&#x3D;“name”并且value&#x3D;“master”或value&#x3D;“slave”的对象</li>
<li>name not in (master,slave)：选择所有包含Label中的key&#x3D;“name”并且value!&#x3D;“master”和value!&#x3D;“slave”的对象</li>
</ul>
</li>
<li>标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号（,）进行分隔即可<ul>
<li>name&#x3D;salve,env!&#x3D;production</li>
<li>name not in (master,slave),env!&#x3D;production</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为Nginx的Pod打上标签</span></span><br><span class="line">kubectl label pod nginx version=1.0 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为Nginx的Pod更新标签</span></span><br><span class="line">kubectl label pod nginx version=2.0 -n dev --overwrite</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示Nginx的Pod的标签</span></span><br><span class="line">kubectl get pod nginx -n dev --show-labels</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">筛选版本号是2.0的在名称为dev的namespace下的Pod</span></span><br><span class="line">kubectl get pod -l version=2.0 -n dev --show-labels</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除名称为dev的namespace下的Nginx的Pod上的标签</span></span><br><span class="line">kubectl label pod nginx version- -n dev</span><br></pre></td></tr></table></figure>

<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul>
<li>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。</li>
<li>Pod控制器用于Pod的管理，确保Pod资源符合预期的状态，当Pod的资源出现故障的时候，会尝试进行重启或重建Pod。</li>
<li>在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。</li>
</ul>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在名称为<span class="built_in">test</span>的命名空间下创建名为nginx的deployment</span></span><br><span class="line">kubectl create deployment nginx --image=nginx:1.17.1 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在名称为<span class="built_in">test</span>的命名空间下根据名为nginx的deployment创建4个Pod</span></span><br><span class="line">kubectl scale deployment nginx --replicas=4 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看名为dev的namespace下的名为nginx的deployment的详细信息</span></span><br><span class="line">kubectl describe deployment nginx -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除名为dev的namespace下的名为nginx的deployment</span></span><br><span class="line">kubectl delete deployment nginx -n dev</span><br></pre></td></tr></table></figure>

<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul>
<li>我们已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务，虽然每个Pod都会分配一个单独的Pod的IP地址，但是却存在如下的问题<ul>
<li>Pod的IP会随着Pod的重建产生变化</li>
<li>Pod的IP仅仅是集群内部可见的虚拟的IP，外部无法访问</li>
</ul>
</li>
<li>这样对于访问这个服务带来了难度，因此，kubernetes设计了Service来解决这个问题。</li>
<li>Service可以看做是一组同类的Pod对外的访问接口，借助Service，应用可以方便的实现服务发现和负载均衡。<br><img src="/1.png" alt="1"></li>
</ul>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><h3 id="集群内部访问"><a href="#集群内部访问" class="headerlink" title="集群内部访问"></a>集群内部访问</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暴露名为dev的namespace下的名为nginx的deployment，并设置服务名为svc-nginx1</span></span><br><span class="line">kubectl expose deployment nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看名为dev的命名空间的所有Service</span></span><br><span class="line">kubectl get service -n dev</span><br></pre></td></tr></table></figure>

<h3 id="集群外部访问"><a href="#集群外部访问" class="headerlink" title="集群外部访问"></a>集群外部访问</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暴露名为dev的namespace下的名为nginx的deployment，并设置服务名为svc-nginx2</span></span><br><span class="line">kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看名为dev的命名空间的所有Service</span></span><br><span class="line">kubectl get service -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除服务</span></span><br><span class="line">kubectl delete service svc-nginx1 -n dev</span><br><span class="line">kubectl delete service svc-nginx2 -n dev</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（五）- K8S Pod详解 - Pod介绍</title>
    <url>/2022/03/09/k8s-study-notes-5/</url>
    <content><![CDATA[<h2 id="每个Pod中都包含一个或者多个容器，这些容器可以分为两类"><a href="#每个Pod中都包含一个或者多个容器，这些容器可以分为两类" class="headerlink" title="每个Pod中都包含一个或者多个容器，这些容器可以分为两类"></a>每个Pod中都包含一个或者多个容器，这些容器可以分为两类</h2><ul>
<li>用户程序所在的容器，数量可多可少</li>
<li>Pause容器，这是每个Pod都会有的一个根容器，它的作用有两个<ul>
<li>可以以它为依据，评估整个Pod的健康状况</li>
<li>可以在根容器上设置IP地址，其它容器都共享此IP（Pod的IP），以实现Pod内部的网络通信（这里是Pod内部的通讯，Pod之间的通讯采用虚拟二层网络技术来实现，我们当前环境使用的是Calico）</li>
</ul>
</li>
</ul>
<h2 id="Pod-定义"><a href="#Pod-定义" class="headerlink" title="Pod 定义"></a>Pod 定义</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>     <span class="comment">#必选，版本号，例如v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       　 <span class="comment">#必选，资源类型，例如 Pod</span></span><br><span class="line"><span class="attr">metadata:</span>       　 <span class="comment">#必选，元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#必选，Pod名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">string</span>  <span class="comment">#Pod所属的命名空间,默认为&quot;default&quot;</span></span><br><span class="line">  <span class="attr">labels:</span>       　　  <span class="comment">#自定义标签列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　          </span><br><span class="line"><span class="attr">spec:</span>  <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line">  <span class="attr">containers:</span>  <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>   <span class="comment">#必选，容器名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span>  <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> [ <span class="string">Always|Never|IfNotPresent</span> ]  <span class="comment">#获取镜像的策略 </span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">string</span>]   <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">string</span>]      <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">string</span>  <span class="comment">#容器的工作目录</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>       <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">string</span> <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="string">boolean</span> <span class="comment">#是否为只读模式</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>        <span class="comment">#端口的名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="string">int</span>  <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="string">int</span>       <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">string</span>    <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="attr">env:</span>   <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>  <span class="comment">#环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">string</span> <span class="comment">#环境变量的值</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment">#资源限制的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>     <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>  <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment">#资源请求的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span> <span class="comment">#内存请求,容器启动的初始可用数量</span></span><br><span class="line">    <span class="attr">lifecycle:</span> <span class="comment">#生命周期钩子</span></span><br><span class="line">		<span class="attr">postStart:</span> <span class="comment">#容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span></span><br><span class="line">		<span class="attr">preStop:</span> <span class="comment">#容器终止前执行此钩子,无论结果如何,容器都会终止</span></span><br><span class="line">    <span class="attr">livenessProbe:</span>  <span class="comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span></span><br><span class="line">      <span class="attr">exec:</span>       　 <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">string</span>]  <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line">      <span class="attr">httpGet:</span>       <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">HttpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">tcpSocket:</span>     <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line">         <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">       <span class="attr">initialDelaySeconds:</span> <span class="number">0</span>       <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line">       <span class="attr">timeoutSeconds:</span> <span class="number">0</span>    　　    <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line">       <span class="attr">periodSeconds:</span> <span class="number">0</span>     　　    <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line">       <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">securityContext:</span></span><br><span class="line">         <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">OnFailure</span>]  <span class="comment">#Pod的重启策略</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">&lt;string&gt;</span> <span class="comment">#设置NodeName表示将该Pod调度到指定到名称的node节点上</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="string">obeject</span> <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span> <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>   <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line">  <span class="attr">volumes:</span>   <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>    <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;       <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line">    <span class="attr">hostPath:</span> <span class="string">string</span>   <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">string</span>      　　        <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line">    <span class="attr">secret:</span>       　　　<span class="comment">#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span></span><br><span class="line">      <span class="attr">scretname:</span> <span class="string">string</span>  </span><br><span class="line">      <span class="attr">items:</span>     </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">configMap:</span>         <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某种资源可以配置的一级配置</span></span><br><span class="line">kubectl explain 资源类型 </span><br><span class="line">kubectl explain pod</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看属性的子属性</span></span><br><span class="line">kubectl explain 资源类型.属性</span><br><span class="line">kubectl explain pod.metadata</span><br></pre></td></tr></table></figure>

<p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5个部分：</p>
<ul>
<li>apiVersion   <string>：版本，有kubernetes内部定义，版本号必须用kubectl api-versions查询</li>
<li>kind <string>：类型，有kubernetes内部定义，类型必须用kubectl api-resources查询</li>
<li>metadata   <Object>：元数据，主要是资源标识和说明，常用的有name、namespace、labels等</li>
<li>spec <Object>：描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</li>
<li>spec <Object>：描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</li>
</ul>
<p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性：</p>
<ul>
<li>containers   &lt;[]Object&gt;：容器列表，用于定义容器的详细信息</li>
<li>nodeName <String>：根据nodeName的值将Pod调度到指定的Node节点上</li>
<li>nodeSelector   &lt;map[]&gt; ：根据NodeSelector中定义的信息选择该Pod调度到包含这些Label的Node上</li>
<li>hostNetwork  <boolean>：是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li>
<li>volumes      &lt;[]Object&gt; ：存储卷，用于定义Pod上面挂载的存储信息</li>
<li>restartPolicy	<string>：重启策略，表示Pod在遇到故障的时候的处理策略</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（六）- K8S Pod详解 - Pod的配置</title>
    <url>/2022/03/10/k8s-study-notes-6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本小节主要来研究pod.spec.containers属性，这也是Pod配置中最为关键的一项配置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod.spec.containers的可选配置项</span></span><br><span class="line">kubectl explain pod.spec.containers</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回的重要属性</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回的重要属性</span></span><br><span class="line">KIND:    Pod</span><br><span class="line">VERSION: v1</span><br><span class="line">RESOURCE: containers &lt;[]Object&gt;  # 数组，代表可以有多个容器FIELDS:</span><br><span class="line">  name &lt;string&gt; # 容器名称</span><br><span class="line">  image &lt;string&gt; # 容器需要的镜像地址</span><br><span class="line">  imagePullPolicy &lt;string&gt; # 镜像拉取策略 </span><br><span class="line">  command &lt;[]string&gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">  args  &lt;[]string&gt; # 容器的启动命令需要的参数列表 </span><br><span class="line">  env   &lt;[]Object&gt; # 容器环境变量的配置</span><br><span class="line">  ports  &lt;[]Object&gt;  # 容器需要暴露的端口号列表</span><br><span class="line">  resources &lt;Object&gt; # 资源限制和资源请求的设置</span><br></pre></td></tr></table></figure>

<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="创建pod-base-yaml文件"><a href="#创建pod-base-yaml文件" class="headerlink" title="创建pod-base.yaml文件"></a>创建pod-base.yaml文件</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-base</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span> <span class="comment"># 容器需要的镜像地址</span></span><br></pre></td></tr></table></figure>
<p>上面定义了一个比较简单的Pod的配置，里面有两个容器：</p>
<ul>
<li>nginx：用的是1.17.1版本的nginx镜像创建（nginx是一个轻量级的web容器）。</li>
<li>busybox：用的是1.30版本的busybox镜像创建（busybox是一个小巧的linux命令集合）</li>
</ul>
<h3 id="创建POD"><a href="#创建POD" class="headerlink" title="创建POD"></a>创建POD</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-base.yaml</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看POD</span></span><br><span class="line">kubectl get pod pod-base -n dev</span><br><span class="line"></span><br><span class="line">kubectl describe pod pod-base -n dev</span><br></pre></td></tr></table></figure>
<p><img src="/1.png" alt="1"></p>
<ul>
<li>1&#x2F;2: 表示2个容器1个就绪，一个未就绪</li>
<li>RESTARTS：表示容器重启的次数</li>
</ul>
<h2 id="镜像拉取策略"><a href="#镜像拉取策略" class="headerlink" title="镜像拉取策略"></a>镜像拉取策略</h2><h3 id="创建pod-imagepullpolicy-yaml"><a href="#创建pod-imagepullpolicy-yaml" class="headerlink" title="创建pod-imagepullpolicy.yaml"></a>创建pod-imagepullpolicy.yaml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-imagepullpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">Always</span> <span class="comment"># 用于设置镜像的拉取策略</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span> <span class="comment"># 容器需要的镜像地址</span></span><br></pre></td></tr></table></figure>
<p>imagePullPolicy: 用于设置镜像拉取的策略，kubernetes支持配置三种拉取策略</p>
<blockquote>
<p>如果镜像tag为具体的版本号，默认策略是IfNotPresent。<br>如果镜像tag为latest（最终版本），默认策略是Always</p>
</blockquote>
<ul>
<li>Always：总是从远程仓库拉取镜像（一直远程下载）。 </li>
<li>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就用本地，本地没有就使用远程下载）。 </li>
<li>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错（一直使用本地，没有就报错）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-imagepullpolicy.yaml</span><br><span class="line"></span><br><span class="line">kubectl describe pod pod-imagepullpolicy -n dev</span><br></pre></td></tr></table></figure>

<h2 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h2><blockquote>
<p>在前面的案例中，一直有一个问题没有解决，就是busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障的呢？<br>原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command的配置。</p>
</blockquote>
<h3 id="创建pod-command-yaml文件"><a href="#创建pod-command-yaml文件" class="headerlink" title="创建pod-command.yaml文件"></a>创建pod-command.yaml文件</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-command</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 设置镜像拉取策略</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt;sleep 3;done;&quot;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>command：用于在Pod中的容器初始化完毕之后执行一个命令。 这里稍微解释下command中的命令的意思：</p>
</blockquote>
<ul>
<li>“&#x2F;bin&#x2F;sh”,”-c”：使用sh执行命令。</li>
<li>touch &#x2F;tmp&#x2F;hello.txt：创建一个&#x2F;tmp&#x2F;hello.txt的文件。</li>
<li>while true;do &#x2F;bin&#x2F;echo $(date +%T) &gt;&gt; &#x2F;tmp&#x2F;hello.txt;sleep 3;done：每隔3秒，向文件写入当前时间</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-command.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pod pod-command -n dev</span><br><span class="line">kubectl describe pod pod-command -n dev</span><br></pre></td></tr></table></figure>

<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl exec -it pod-command -n dev /bin/sh</span><br><span class="line">kubectl exec -it pod-command -n dev -c nginx /bin/sh</span><br><span class="line">kubectl exec -it pod-command -n dev -c busybox /bin/sh</span><br></pre></td></tr></table></figure>

<h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><blockquote>
<p>通过上面发现command已经可以完成启动命令和传递参数的功能，为什么还要提供一个args选项，用于传递参数？<br>其实和Docker有点关系，kubernetes中的command和args两个参数其实是为了实现覆盖Dockerfile中的ENTRYPOINT的功能：</p>
</blockquote>
<ul>
<li>如果command和args均没有写，那么用Dockerfile的配置</li>
<li>如果command写了，但是args没有写，那么Dockerfile默认的配置会被忽略，执行注入的command。</li>
<li>如果command没有写，但是args写了，那么Dockerfile中配置的ENTRYPOINT命令会被执行，使用当前args的参数。</li>
<li>如果command和args都写了，那么Dockerfile中的配置会被忽略，执行command并追加上args参数。</li>
</ul>
<h2 id="环境变量（不推荐）"><a href="#环境变量（不推荐）" class="headerlink" title="环境变量（不推荐）"></a>环境变量（不推荐）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 设置镜像拉取策略</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt;sleep 3;done;&quot;</span>]</span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="端口设置"><a href="#端口设置" class="headerlink" title="端口设置"></a>端口设置</h2><blockquote>
<p>访问Pod中的容器中的程序使用的是PodIp:containerPort。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ports支持的子选项</span></span><br><span class="line">kubectl explain pod.spec.containers.ports</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">KIND:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">VERSION:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">RESOURCE:</span> <span class="string">ports</span> <span class="string">&lt;[]Object&gt;</span></span><br><span class="line"><span class="attr">FIELDS:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span> <span class="comment"># 端口名称，如果指定，必须保证name在pod中是唯一的</span></span><br><span class="line">  <span class="string">containerPort</span> <span class="string">&lt;integer&gt;</span> <span class="comment"># 容器要监听的端口(0&lt;x&lt;65536)</span></span><br><span class="line">  <span class="string">hostPort</span> <span class="string">&lt;integer&gt;</span> <span class="comment"># 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略）</span></span><br><span class="line">  <span class="string">hostIP</span> <span class="string">&lt;string&gt;</span> <span class="comment"># 要将外部端口绑定到的主机IP(一般省略)</span></span><br><span class="line">  <span class="string">protocol</span> <span class="string">&lt;string&gt;</span> <span class="comment"># 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-ports</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 设置镜像拉取策略</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span> <span class="comment"># 端口名称，如果执行，必须保证name在Pod中是唯一的</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器要监听的端口 （0~65536）</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 端口协议</span></span><br></pre></td></tr></table></figure>

<h2 id="资源配额"><a href="#资源配额" class="headerlink" title="资源配额"></a>资源配额</h2><blockquote>
<p>器中的程序要运行，肯定会占用一定的资源，比如CPU和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量的资源，导致其他的容器无法运行。<br>针对这种情况，kubernetes提供了对内存和CPU的资源进行配额的机制，这种机制主要通过resources选项实现，它有两个子选项</p>
</blockquote>
<ul>
<li>limits：用于限制运行的容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启</li>
<li>requests：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动</li>
<li></li>
</ul>
<h3 id="创建pod-resoures-yaml"><a href="#创建pod-resoures-yaml" class="headerlink" title="创建pod-resoures.yaml"></a>创建pod-resoures.yaml</h3><blockquote>
<p>cpu：core数，可以为整数或小数。<br>memory：内存大小，可以使用Gi、Mi、G、M等形式。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-resoures</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 设置镜像拉取策略</span></span><br><span class="line">      <span class="attr">ports:</span> <span class="comment"># 端口设置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span> <span class="comment"># 端口名称，如果执行，必须保证name在Pod中是唯一的</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器要监听的端口 （0~65536）</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 端口协议</span></span><br><span class="line">      <span class="attr">resources:</span> <span class="comment"># 资源配额</span></span><br><span class="line">        <span class="attr">limits:</span> <span class="comment"># 限制资源的上限</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;10Gi&quot;</span> <span class="comment"># 内存限制</span></span><br><span class="line">        <span class="attr">requests:</span> <span class="comment"># 限制资源的下限</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span> <span class="comment"># CPU限制，单位是core数 </span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;10Mi&quot;</span> <span class="comment"># 内存限制</span></span><br></pre></td></tr></table></figure>
<p>可以修改requests的 cpu 或 memory大小，让其大于node的最大值，之后就会发现pod启动失败。因为资源不够了</p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（七）- K8S Pod详解 - Pod的生命周期</title>
    <url>/2022/03/19/k8s-study-notes-7/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们一般将Pod对象从创建到终止的这段时间范围称为Pod的生命周期，它主要包含下面的过程：</p>
<ul>
<li>Pod创建过程。</li>
<li>运行初始化容器（init container）过程</li>
<li>运行主容器（main container） <ul>
<li>容器启动后钩子（post start）、容器终止前钩子（pre stop）</li>
<li>容器的存活性探测（liveness probe）、就绪性探测（readiness probe）</li>
</ul>
</li>
<li>Pod终止过程<br><img src="/1.png" alt="1"></li>
</ul>
<p>在整个生命周期中，Pod会出现5种状态（相位），分别如下：</p>
<ul>
<li>挂起（Pending）：API Server已经创建了Pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中。 </li>
<li>运行中（Running）：Pod已经被调度到某节点，并且所有容器都已经被kubelet创建完成。 </li>
<li>成功（Succeeded）：Pod中的所有容器都已经成功终止并且不会被重启。 </li>
<li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态。</li>
<li>未知（Unknown）：API Server无法正常获取到Pod对象的状态信息，通常由于网络通信失败所导致。</li>
</ul>
<h1 id="创建和终止"><a href="#创建和终止" class="headerlink" title="创建和终止"></a>创建和终止</h1><h2 id="Pod的创建过程"><a href="#Pod的创建过程" class="headerlink" title="Pod的创建过程"></a>Pod的创建过程</h2><p><img src="/2.png" alt="2"></p>
<ul>
<li>① 用户通过kubectl或其他的api客户端提交需要创建的Pod信息给API Server。</li>
<li>② API Server开始生成Pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端。</li>
<li>③ API Server开始反映etcd中的Pod对象的变化，其它组件使用watch机制来跟踪检查API Server上的变动。</li>
<li>④ Scheduler发现有新的Pod对象要创建，开始为Pod分配主机并将结果信息更新至API Server。</li>
<li>⑤ Node节点上的kubelet发现有Pod调度过来，尝试调度Docker启动容器，并将结果回送至API Server。 </li>
<li>⑥ API Server将接收到的Pod状态信息存入到etcd中。</li>
</ul>
<h2 id="Pod的终止过程"><a href="#Pod的终止过程" class="headerlink" title="Pod的终止过程"></a>Pod的终止过程</h2><ul>
<li>① 用户向API Server发送删除Pod对象的命令。</li>
<li>② API Server中的Pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），Pod被视为dead。 </li>
<li>③ 将Pod标记为terminating状态。 </li>
<li>④ kubelete在监控到Pod对象转为terminating状态的同时启动Pod关闭过程。 </li>
<li>⑤ 端点控制器监控到Pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除。 </li>
<li>⑥ 如果当前Pod对象定义了preStop钩子处理器，则在其标记为terminating后会以同步的方式启动执行。 </li>
<li>⑦ Pod对象中的容器进程收到停止信号。 </li>
<li>⑧ 宽限期结束后，如果Pod中还存在运行的进程，那么Pod对象会收到立即终止的信号。 </li>
<li>⑨ kubectl请求API Server将此Pod资源的宽限期设置为0从而完成删除操作，此时Pod对于用户已经不可用了。</li>
</ul>
<h1 id="初始化容器"><a href="#初始化容器" class="headerlink" title="初始化容器"></a>初始化容器</h1><ul>
<li>初始化容器是在Pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：<ul>
<li>① 初始化容器必须运行完成直至结束，如果某个初始化容器运行失败，那么kubernetes需要重启它直至成功完成。</li>
<li>② 初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行。</li>
</ul>
</li>
<li>初始化容器有很多的应用场景，下面列出的是最常见的几个：<ul>
<li>① 提供主容器镜像中不具备的工具程序或自定义代码。</li>
<li>② 初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足。</li>
</ul>
</li>
</ul>
<p>接下来做一个案例，模拟下面这个需求：</p>
<ul>
<li>假设要以主容器来运行Nginx，但是要求在运行Nginx之前要能够连接上MySQL和Redis所在的服务器。</li>
<li>为了简化测试，事先规定好MySQL和Redis所在的IP地址分别为192.168.18.103和192.168.18.104（注意，这两个IP都不能ping通，因为环境中没有这两个IP）。</li>
</ul>
<h2 id="创建pod-initcontainer-yaml文件"><a href="#创建pod-initcontainer-yaml文件" class="headerlink" title="创建pod-initcontainer.yaml文件"></a>创建pod-initcontainer.yaml文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-initcontainer</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;10Gi&quot;</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;10Mi&quot;</span></span><br><span class="line">  <span class="attr">initContainers:</span> <span class="comment"># 初始化容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;until ping 192.168.18.103 -c 1;do echo waiting for mysql ...;sleep 2;done;&quot;</span>]</span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">privileged:</span> <span class="literal">true</span> <span class="comment"># 使用特权模式运行容器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-redis</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;until ping 192.168.18.104 -c 1;do echo waiting for redis ...;sleep 2;done;&quot;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建pod</span></span><br><span class="line">kubectl create -f pod-initcontainer.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl describe pod pod-initcontainer -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">动态查看</span></span><br><span class="line">kubectl get pod pod-initcontainer -n dev -w</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改上面的IP为可ping通IP后，重新创建就绪创建成功了</span></span><br></pre></td></tr></table></figure>

<h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p>
<p>kubernetes在主容器启动之后和停止之前提供了两个钩子函数：</p>
<ul>
<li>post start：容器创建之后执行，如果失败会重启容器。 </li>
<li>pre stop：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作。</li>
</ul>
<p>钩子处理器支持使用下面的三种方式定义动作：</p>
<ul>
<li>① exec命令：在容器内执行一次命令<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">     <span class="attr">postStart:</span> </span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">           <span class="attr">command:</span></span><br><span class="line">             <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">             <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
<li>② tcpSocket：在当前容器尝试访问指定的socket<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span> </span><br><span class="line">   <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">         <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
<li>③ httpGet：在当前容器中向某url发起HTTP请求<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span> </span><br><span class="line">   <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">         <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">            <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span> <span class="comment">#主机地址  </span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
接下来，以exec方式为例，演示下钩子函数的使用，创建pod-hook-exec.yaml文件，内容如下：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-hook-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;10Gi&quot;</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;10Mi&quot;</span></span><br><span class="line">      <span class="attr">lifecycle:</span> <span class="comment"># 生命周期配置</span></span><br><span class="line">        <span class="attr">postStart:</span> <span class="comment"># 容器创建之后执行，如果失败会重启容器</span></span><br><span class="line">          <span class="attr">exec:</span> <span class="comment"># 在容器启动的时候，执行一条命令，修改掉Nginx的首页内容</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo postStart ... &gt; /usr/share/nginx/html/index.html&quot;</span>]</span><br><span class="line">        <span class="attr">preStop:</span> <span class="comment"># 容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</span></span><br><span class="line">          <span class="attr">exec:</span> <span class="comment"># 在容器停止之前停止Nginx的服务</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-s&quot;</span>,<span class="string">&quot;quit&quot;</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-hook-exec.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod pod-hook-exec -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问, 10.244.36.66为容器IP</span></span><br><span class="line">curl 10.244.36.66</span><br></pre></td></tr></table></figure>
<h1 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>livenessProbe：存活性探测，决定是否重启容器。<br>readinessProbe：就绪性探测，决定是否将请求转发给容器。</p>
</blockquote>
<blockquote>
<p>k8s在1.16版本之后新增了startupProbe探针，用于判断容器内应用程序是否已经启动。<br>如果配置了startupProbe探针，就会先禁止其他的探针，直到startupProbe探针成功为止，一旦成功将不再进行探测。</p>
</blockquote>
<p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例“摘除”，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p>
<ul>
<li>liveness probes：存活性探测，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器。</li>
<li>readiness probes：就绪性探测，用于检测应用实例是否可以接受请求，如果不能，k8s不会转发流量。</li>
</ul>
<p>上面两种探针目前均支持三种探测方式：</p>
<ul>
<li>① exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">     <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">          <span class="string">-</span>	<span class="string">cat</span></span><br><span class="line">          <span class="string">-</span>	<span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
<li>② tcpSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">   <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">         <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
<li>③ httpGet：调用容器内web应用的URL，如果返回的状态码在200和399之前，则认为程序正常，否则不正常<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">   <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">         <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">         <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">         <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#主机地址</span></span><br><span class="line">         <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="exec方式"><a href="#exec方式" class="headerlink" title="exec方式"></a>exec方式</h2><p>创建pod-liveness-exec.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">livenessProbe:</span> <span class="comment"># 存活性探针</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/cat&quot;</span>,<span class="string">&quot;/tmp/hello.txt&quot;</span>] <span class="comment"># 执行一个查看文件的命令，必须失败，因为根本没有这个文件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-liveness-exec.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod pod-liveness-exec -n dev</span><br><span class="line">kubectl describe pod pod-liveness-exec -n dev</span><br></pre></td></tr></table></figure>
<blockquote>
<p>观察上面 describe 的信息就会发现nginx容器启动之后就进行了健康检查。<br>检查失败之后，容器被kill掉，然后尝试进行重启，这是重启策略的作用。<br>稍等一会之后，再观察Pod的信息，就会看到RESTARTS不再是0，而是一直增长。</p>
</blockquote>
<h2 id="tcpSocket方式"><a href="#tcpSocket方式" class="headerlink" title="tcpSocket方式"></a>tcpSocket方式</h2><p>创建pod-liveness-tcpsocket.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-tcpsocket</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">livenessProbe:</span> <span class="comment"># 存活性探针</span></span><br><span class="line">        <span class="attr">tcpSocket:</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 尝试访问8080端口，必须失败，因为Pod内部只有一个Nginx容器，而且只是监听了80端口</span></span><br></pre></td></tr></table></figure>
<h2 id="httpGet方式"><a href="#httpGet方式" class="headerlink" title="httpGet方式"></a>httpGet方式</h2><p>创建pod-liveness-httpget.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-httpget</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">livenessProbe:</span> <span class="comment"># 存活性探针</span></span><br><span class="line">        <span class="attr">httpGet:</span> <span class="comment"># 其实就是访问http://127.0.0.1:80/hello</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 端口号</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment"># 支持的协议，HTTP或HTTPS</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/hello</span> <span class="comment"># URI地址</span></span><br><span class="line">          <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 主机地址</span></span><br></pre></td></tr></table></figure>
<h2 id="容器探测的补充"><a href="#容器探测的补充" class="headerlink" title="容器探测的补充"></a>容器探测的补充</h2><p>上面已经使用了livenessProbe演示了三种探测方式，但是查看livenessProbe的子属性，会发现除了这三种方式，还有一些其他的配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl explain pod.spec.containers.livenessProbe</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FIELDS:<br>exec<br>tcpSocket<br>httpGet<br>initialDelaySeconds    # 容器启动后等待多少秒执行第一次探测<br>timeoutSeconds      # 探测超时时间。默认1秒，最小1秒<br>periodSeconds       # 执行探测的频率。默认是10秒，最小1秒<br>failureThreshold    # 连续探测失败多少次才被认定为失败。默认是3。最小值是1<br>successThreshold    # 连续探测成功多少次才被认定为成功。默认是1</p>
</blockquote>
<h1 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h1><p>在容器探测中，一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由Pod的重启策略决定的，Pod的重启策略有3种，分别如下：</p>
<ul>
<li>Always：容器失效时，自动重启该容器，默认值。 </li>
<li>OnFailure：容器终止运行且退出码不为0时重启。</li>
<li>Never：不论状态如何，都不重启该容器。</li>
</ul>
<p>重启策略适用于Pod对象中的所有容器，首次需要重启的容器，将在其需要的时候立即进行重启，<br>随后再次重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大的延迟时长。</p>
<p>创建pod-restart-policy.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-restart-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">livenessProbe:</span> <span class="comment"># 存活性探测</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/hello</span></span><br><span class="line">          <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-restart-policy.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod pod-restart-policy -n dev</span><br><span class="line">kubectl describe pod pod-restart-policy -n dev</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（八）- K8S Pod详解 - Pod的调度</title>
    <url>/2022/03/20/k8s-study-notes-8/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。<br>但是在实际使用中，这并不满足需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做？<br>这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式。</p>
<ul>
<li>自动调度：运行在哪个Node节点上完全由Scheduler经过一系列的算法计算得出。</li>
<li>定向调度：NodeName、NodeSelector。</li>
<li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity。</li>
<li>污点（容忍）调度：Taints、Toleration。</li>
</ul>
<h1 id="定向调度"><a href="#定向调度" class="headerlink" title="定向调度"></a>定向调度</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>定向调度，指的是利用在Pod上声明的nodeName或nodeSelector，以此将Pod调度到期望的Node节点上。<br>注意，这里的调度是<code>强制</code>的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过Pod运行失败而已。</p>
<h2 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h2><p>nodeName用于强制约束将Pod调度到指定的name的Node节点上。<br>这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。</p>
<p>创建一个pod-nodename.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodename</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">k8s-node1</span> <span class="comment"># 指定调度到k8s-node1节点上</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-nodename.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod pod-nodename -n dev -o wide</span><br></pre></td></tr></table></figure>

<h2 id="nodeSelector"><a href="#nodeSelector" class="headerlink" title="nodeSelector"></a>nodeSelector</h2><p>nodeSelector用于将Pod调度到添加了指定标签的Node节点上，它是通过kubernetes的label-selector机制实现的，<br>换言之，在Pod创建之前，会由Scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将Pod调度到目标节点，该匹配规则是<code>强制</code>约束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先给node节点添加标签</span></span><br><span class="line">kubectl label node k8s-node1 nodeenv=pro</span><br><span class="line">kubectl label node k8s-node2 nodeenv=test</span><br></pre></td></tr></table></figure>

<p>创建pod-nodeselector.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeselector</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">nodeenv:</span> <span class="string">pro</span> <span class="comment"># 指定调度到具有nodeenv=pro的Node节点上</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-nodeselector.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod pod-nodeselector -n dev -o wide</span><br></pre></td></tr></table></figure>

<h1 id="亲和性调度"><a href="#亲和性调度" class="headerlink" title="亲和性调度"></a>亲和性调度</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>虽然定向调度的两种方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用的Node列表也不行，这就限制了它的使用场景。<br>基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。<br>它在nodeSelector的基础之上进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使得调度更加灵活。<br>Affinity主要分为三类：</p>
<ul>
<li>nodeAffinity（node亲和性）：以Node为目标，解决Pod可以调度到那些Node的问题。</li>
<li>podAffinity（pod亲和性）：以Pod为目标，解决Pod可以和那些已存在的Pod部署在同一个拓扑域中的问题。</li>
<li>podAntiAffinity（pod反亲和性）：以Pod为目标，解决Pod不能和那些已经存在的Pod部署在同一拓扑域中的问题。</li>
</ul>
<p>关于亲和性和反亲和性的使用场景的说明： </p>
<ul>
<li>亲和性：如果两个应用频繁交互，那么就有必要利用亲和性让两个应用尽可能的靠近，这样可以较少因网络通信而带来的性能损耗。 </li>
<li>反亲和性：当应用采用多副本部署的时候，那么就有必要利用反亲和性让各个应用实例打散分布在各个Node上，这样可以提高服务的高可用性。</li>
</ul>
<h2 id="nodeAffinity"><a href="#nodeAffinity" class="headerlink" title="nodeAffinity"></a>nodeAffinity</h2><p>nodeAffinity的可选配置项:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">pod.spec.affinity.nodeAffinity</span></span><br><span class="line">  <span class="string">requiredDuringSchedulingIgnoredDuringExecution</span>  <span class="string">Node节点必须满足指定的所有规则才可以，相当于硬限制</span></span><br><span class="line">    <span class="string">nodeSelectorTerms</span>  <span class="string">节点选择列表</span></span><br><span class="line">      <span class="string">matchFields</span>  <span class="string">按节点字段列出的节点选择器要求列表</span> </span><br><span class="line">      <span class="string">matchExpressions</span>  <span class="string">按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line">        <span class="string">key</span>   <span class="string">键</span></span><br><span class="line">        <span class="string">values</span> <span class="string">值</span></span><br><span class="line">        <span class="string">operator</span> <span class="string">关系符</span> <span class="string">支持Exists,</span> <span class="string">DoesNotExist,</span> <span class="string">In,</span> <span class="string">NotIn,</span> <span class="string">Gt,</span> <span class="string">Lt</span></span><br><span class="line">  <span class="string">preferredDuringSchedulingIgnoredDuringExecution</span> <span class="string">优先调度到满足指定的规则的Node，相当于软限制</span> <span class="string">(倾向)</span>     </span><br><span class="line">    <span class="string">preference</span>   <span class="string">一个节点选择器项，与相应的权重相关联</span></span><br><span class="line">      <span class="string">matchFields</span> <span class="string">按节点字段列出的节点选择器要求列表</span></span><br><span class="line">      <span class="string">matchExpressions</span>   <span class="string">按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line">       <span class="string">key</span> <span class="string">键</span></span><br><span class="line">       <span class="string">values</span> <span class="string">值</span></span><br><span class="line">       <span class="string">operator</span> <span class="string">关系符</span> <span class="string">支持In,</span> <span class="string">NotIn,</span> <span class="string">Exists,</span> <span class="string">DoesNotExist,</span> <span class="string">Gt,</span> <span class="string">Lt</span>  </span><br><span class="line">    <span class="string">weight</span> <span class="string">倾向权重，在范围1-100。</span></span><br></pre></td></tr></table></figure>
<p>关系符的使用说明:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span> <span class="comment"># 匹配存在标签的key为nodeenv的节点</span></span><br><span class="line">	  <span class="attr">operator:</span> <span class="string">Exists</span>   </span><br><span class="line">	<span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span> <span class="comment"># 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span></span><br><span class="line">	  <span class="attr">operator:</span> <span class="string">In</span>    </span><br><span class="line">      <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span> <span class="comment"># 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">Gt</span>   </span><br><span class="line">      <span class="attr">values:</span> <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="requiredDuringSchedulingIgnoredDuringExecution"><a href="#requiredDuringSchedulingIgnoredDuringExecution" class="headerlink" title="requiredDuringSchedulingIgnoredDuringExecution"></a>requiredDuringSchedulingIgnoredDuringExecution</h3><p>创建pod-nodeaffinity-required.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment"># node亲和性配置</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># Node节点必须满足指定的所有规则才可以，相当于硬规则，类似于定向调度</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span> <span class="comment"># 节点选择列表</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span> <span class="comment"># 匹配存在标签的key为nodeenv的节点，并且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;yyy&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-nodeaffinity-required.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod状态（运行失败）</span></span><br><span class="line">kubectl get pod pod-nodeaffinity-required -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod详情（发现调度失败，提示node选择失败）：</span></span><br><span class="line">kubectl describe pod pod-nodeaffinity-required -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除pod</span></span><br><span class="line">kubectl delete -f pod-nodeaffinity-required.yaml</span><br></pre></td></tr></table></figure>
<p>修改pod-nodeaffinity-required.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment"># node亲和性配置</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># Node节点必须满足指定的所有规则才可以，相当于硬规则，类似于定向调度</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span> <span class="comment"># 节点选择列表</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span> <span class="comment"># 匹配存在标签的key为nodeenv的节点，并且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;pro&quot;</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;yyy&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-nodeaffinity-required.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看pod</span></span><br><span class="line">kubectl get pod pod-nodeaffinity-required -n dev -o wide</span><br></pre></td></tr></table></figure>

<h3 id="preferredDuringSchedulingIgnoredDuringExecution"><a href="#preferredDuringSchedulingIgnoredDuringExecution" class="headerlink" title="preferredDuringSchedulingIgnoredDuringExecution"></a>preferredDuringSchedulingIgnoredDuringExecution</h3><p>创建pod-nodeaffinity-preferred.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-preferred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment"># node亲和性配置</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 优先调度到满足指定的规则的Node，相当于软限制 (倾向)</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">preference:</span> <span class="comment"># 一个节点选择器项，与相应的权重相关联</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;yyy&quot;</span></span><br><span class="line">          <span class="attr">weight:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-nodeaffinity-preferred.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pod pod-nodeaffinity-preferred -n dev -o wide</span><br></pre></td></tr></table></figure>
<p>nodeAffinity的注意事项：</p>
<ul>
<li>如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都满足，Pod才能运行在指定的Node上。</li>
<li>如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可。</li>
<li>如果一个nodeSelectorTerms中有多个matchExpressions，则一个节点必须满足所有的才能匹配成功。</li>
<li>如果一个Pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的nodeAffinity的要求，则系统将忽略此变化。</li>
</ul>
<h2 id="podAffinity"><a href="#podAffinity" class="headerlink" title="podAffinity"></a>podAffinity</h2><p>podAffinity主要实现以运行的Pod为参照，实现让新创建的Pod和参照的Pod在一个区域的功能。<br>PodAffinity的可选配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">pod.spec.affinity.podAffinity</span></span><br><span class="line">  <span class="string">requiredDuringSchedulingIgnoredDuringExecution</span>  <span class="string">硬限制</span></span><br><span class="line">    <span class="string">namespaces</span> <span class="string">指定参照pod的namespace</span></span><br><span class="line">    <span class="string">topologyKey</span> <span class="string">指定调度作用域</span></span><br><span class="line">    <span class="string">labelSelector</span> <span class="string">标签选择器</span></span><br><span class="line">      <span class="string">matchExpressions</span>  <span class="string">按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line">        <span class="string">key</span>    <span class="string">键</span></span><br><span class="line">        <span class="string">values</span> <span class="string">值</span></span><br><span class="line">        <span class="string">operator</span> <span class="string">关系符</span> <span class="string">支持In,</span> <span class="string">NotIn,</span> <span class="string">Exists,</span> <span class="string">DoesNotExist.</span></span><br><span class="line">      <span class="string">matchLabels</span>    <span class="string">指多个matchExpressions映射的内容</span>  </span><br><span class="line">  <span class="string">preferredDuringSchedulingIgnoredDuringExecution</span> <span class="string">软限制</span>    </span><br><span class="line">    <span class="string">podAffinityTerm</span>  <span class="string">选项</span></span><br><span class="line">      <span class="string">namespaces</span></span><br><span class="line">      <span class="string">topologyKey</span></span><br><span class="line">      <span class="string">labelSelector</span></span><br><span class="line">         <span class="string">matchExpressions</span> </span><br><span class="line">            <span class="string">key</span>    <span class="string">键</span>  </span><br><span class="line">            <span class="string">values</span> <span class="string">值</span>  </span><br><span class="line">            <span class="string">operator</span></span><br><span class="line">         <span class="string">matchLabels</span> </span><br><span class="line">    <span class="string">weight</span> <span class="string">倾向权重，在范围1-100</span></span><br></pre></td></tr></table></figure>
<p>topologyKey用于指定调度的作用域，例如:</p>
<ul>
<li>如果指定为<code>kubernetes.io/hostname</code>，那就是以Node节点为区分范围。 </li>
<li>如果指定为<code>beta.kubernetes.io/os</code>，则以Node节点的操作系统类型来区分。</li>
</ul>
<h3 id="requiredDuringSchedulingIgnoredDuringExecution-1"><a href="#requiredDuringSchedulingIgnoredDuringExecution-1" class="headerlink" title="requiredDuringSchedulingIgnoredDuringExecution"></a>requiredDuringSchedulingIgnoredDuringExecution</h3><p>创建pod-podaffinity-target.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-target</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">podenv:</span> <span class="string">pro</span> <span class="comment"># 设置标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">k8s-node1</span> <span class="comment"># 将目标pod定向调度到k8s-node1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-podaffinity-target.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看参照Pod</span></span><br><span class="line">kubectl get pod pod-podaffinity-target -n dev -o wide</span><br></pre></td></tr></table></figure>

<p>创建pod-podaffinity-requred.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-requred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">podAffinity:</span> <span class="comment"># Pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span> <span class="comment"># 该Pod必须和拥有标签podenv=xxx或者podenv=yyy的Pod在同一个Node上，显然没有这样的Pod</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;yyy&quot;</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-podaffinity-requred.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod状态，发现没有运行：</span></span><br><span class="line">kubectl get pod pod-podaffinity-requred -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod详情：</span></span><br><span class="line">kubectl get pod pod-podaffinity-requred -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除Pod</span></span><br><span class="line">kubectl delete -f pod-podaffinity-requred.yaml</span><br></pre></td></tr></table></figure>

<p>修改pod-podaffinity-requred.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-requred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">podAffinity:</span> <span class="comment"># Pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span> <span class="comment"># 该Pod必须和拥有标签podenv=xxx或者podenv=yyy的Pod在同一个Node上，显然没有这样的Pod</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;pro&quot;</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;yyy&quot;</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-podaffinity-requred.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次查看Pod</span></span><br><span class="line">kubectl get pod pod-podaffinity-requred -n dev -o wide</span><br></pre></td></tr></table></figure>
<h2 id="podAntiAffinity"><a href="#podAntiAffinity" class="headerlink" title="podAntiAffinity"></a>podAntiAffinity</h2><p>podAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod和参照的Pod不在一个区域的功能。<br>其配置方式和podAffinity一样，此处不做详细解释。<br>使用上个案例中的目标Pod：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n dev -o wide</span><br></pre></td></tr></table></figure>
<p>创建pod-podantiaffinity-requred.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podantiaffinity-requred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span> <span class="comment"># Pod反亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;pro&quot;</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f pod-podantiaffinity-requred.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看</span></span><br><span class="line">kubectl get pod -n dev -o wide</span><br></pre></td></tr></table></figure>

<h1 id="污点和容忍"><a href="#污点和容忍" class="headerlink" title="污点和容忍"></a>污点和容忍</h1><h2 id="污点（Taints）"><a href="#污点（Taints）" class="headerlink" title="污点（Taints）"></a>污点（Taints）</h2><p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加污点属性，来决定是否运行Pod调度过来。<br>Node被设置了污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。<br>污点的格式为：<code>key=value:effect</code>，key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p>
<ul>
<li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可以调度。</li>
<li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但是不会影响当前Node上已经存在的Pod。 </li>
<li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已经存在的Pod驱逐。<br><img src="/1.png" alt="1"></li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置污点</span></span><br><span class="line">kubectl taint node xxx key=value:effect</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除污点</span></span><br><span class="line">kubectl taint node xxx key:effect-</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除所有污点</span></span><br><span class="line">kubectl taint node xxx key-</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定节点上的污点：</span></span><br><span class="line">kubectl describe node 节点名称</span><br></pre></td></tr></table></figure>

<p>接下来，演示污点效果：</p>
<ul>
<li>① 准备节点k8s-node1（为了演示效果更加明显，暂时停止k8s-node2节点）。</li>
<li>② 为k8s-node1节点设置一个污点：tag&#x3D;test:PreferNoSchedule，然后创建Pod1（Pod1可以）。</li>
<li>③ 修改k8s-node1节点的污点为：tag&#x3D;test:NoSchedule，然后创建Pod2（Pod1可以正常运行，Pod2失败）。</li>
<li>④ 修改k8s-node1节点的污点为：tag&#x3D;test:NoExecute，然后创建Pod3（Pod1、Pod2、Pod3失败）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为k8s-node1设置污点（PreferNoSchedule）</span></span><br><span class="line">kubectl taint node k8s-node1 tag=xudaxian:PreferNoSchedule</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod1</span></span><br><span class="line">kubectl run pod1 --image=nginx:1.17.1 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">kubectl get pod pod1 -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为k8s-node1取消污点（PreferNoSchedule），并设置污点（NoSchedule）</span></span><br><span class="line">kubectl taint node k8s-node1 tag:PreferNoSchedule-</span><br><span class="line">kubectl taint node k8s-node1 tag=xudaxian:NoSchedule</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod2</span></span><br><span class="line">kubectl run pod2 --image=nginx:1.17.1 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">kubectl get pod pod1 -n dev -o wide</span><br><span class="line">kubectl get pod pod2 -n dev -o wide</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为k8s-node1取消污点（NoSchedule），并设置污点（NoExecute）</span></span><br><span class="line">kubectl taint node k8s-node1 tag:NoSchedule-</span><br><span class="line">kubectl taint node k8s-node1 tag=xudaxian:NoExecute</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod3</span></span><br><span class="line">kubectl run pod3 --image=nginx:1.17.1 -n dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">kubectl get pod pod1 -n dev -o wide</span><br><span class="line">kubectl get pod pod2 -n dev -o wide</span><br><span class="line">kubectl get pod pod3 -n dev -o wide</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用kubeadm搭建的集群，默认就会给Master节点添加一个污点标记，所以Pod就不会调度到Master节点上。</p>
</blockquote>
<h2 id="容忍（Toleration）"><a href="#容忍（Toleration）" class="headerlink" title="容忍（Toleration）"></a>容忍（Toleration）</h2><p>上面介绍了污点的作用，我们可以在Node上添加污点用来拒绝Pod调度上来，但是如果就是想让一个Pod调度到一个有污点的Node上去，这时候应该怎么做？这就需要使用到容忍。</p>
<blockquote>
<p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝Pod调度上去，Pod通过容忍忽略拒绝。</p>
</blockquote>
<p>容忍的详细配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">explain</span> <span class="string">pod.spec.tolerations</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">FIELDS:</span></span><br><span class="line">  <span class="string">key</span>       <span class="comment"># 对应着要容忍的污点的键，空意味着匹配所有的键</span></span><br><span class="line">  <span class="string">value</span>     <span class="comment"># 对应着要容忍的污点的值</span></span><br><span class="line">  <span class="string">operator</span>  <span class="comment"># key-value的运算符，支持Equal和Exists（默认）</span></span><br><span class="line">  <span class="string">effect</span>    <span class="comment"># 对应污点的effect，空意味着匹配所有影响</span></span><br><span class="line">  <span class="string">tolerationSeconds</span>   <span class="comment"># 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间</span></span><br></pre></td></tr></table></figure>

<p>当operator为Equal的时候，如果Node节点有多个Taint，那么Pod每个Taint都需要容忍才能部署上去。<br>当operator为Exists的时候，有如下的三种写法：<br>容忍指定的污点，污点带有指定的effect：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span> <span class="comment"># 容忍</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span> <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span> <span class="comment"># 操作符</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">NoExecute</span> <span class="comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span></span><br></pre></td></tr></table></figure>
<p>容忍指定的污点，不考虑具体的effect：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span> <span class="comment"># 容忍</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span> <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span> <span class="comment"># 操作符</span></span><br></pre></td></tr></table></figure>
<p>容忍一切污点（慎用）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span> <span class="comment"># 容忍</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">Exists</span> <span class="comment"># 操作符</span></span><br></pre></td></tr></table></figure>
<p>在上面的污点中，已经给k8s-node1打上了NoExecute的污点，此时Pod是调度不上去的，此时可以通过在Pod中添加容忍，将Pod调度上去。<br>创建pod-toleration.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-toleration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">tolerations:</span> <span class="comment"># 容忍</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span> <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">Equal</span> <span class="comment"># 操作符</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;test&quot;</span> <span class="comment"># 要容忍的污点的value</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">NoExecute</span> <span class="comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Pod</span></span><br><span class="line">kubectl create -f pod-toleration.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">kubectl get pod pod-toleration -n dev -o wide</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S学习笔记（九）- K8S Pod详解 - 临时容器</title>
    <url>/2022/03/23/k8s-study-notes-9/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>临时容器是一种特殊的容器，该容器可以在现有的Pod中临时运行，以便完成我们发起的操作，比如故障排查。<br>我们应该使用临时容器来检查服务，而不是用临时容器来构建应用程序。</p>
<p>Pod是kubernetes集群进行管理的最小单元，由于Pod是一次性且可以替换的，因此Pod一旦被创建，就无法将容器加入到Pod中。<br>而且，我们通常使用Deployment来删除并替换Pod。<br>但是，有的时候我们需要检查现有Pod的状态，比如对难以复现的故障进行排查。<br>在这些场景中，可以在现有Pod中运行临时容器来检查其状态并运行任意命令。</p>
<h1 id="什么是临时容器"><a href="#什么是临时容器" class="headerlink" title="什么是临时容器"></a>什么是临时容器</h1><p>临时容器和其他容器的不同之处在于，它们缺少对资源或执行的保证，并且永远不会自动重启，因此不适合用来构建应用程序。<br>临时容器使用和常规容器相同的ContainerSpec来描述，但是许多字段是不兼容或者不允许的。</p>
<ul>
<li>临时容器没有端口配置，因此像ports、livenessProbe、readinessProbe这样的字段是没有的。 </li>
<li>Pod的资源分配是不可变的，因此resources这样的配置临时容器也是没有的。 </li>
<li>……</li>
</ul>
<p>临时容器是使用ephemeralcontainers来进行创建的，而不是直接添加到pod.spec中，所以是无法使用kubectl edit来添加一个临时容器。</p>
<p>和常规容器一样，将临时容器添加到Pod后，不能更改或删除临时容器。</p>
<h1 id="临时容器的用途"><a href="#临时容器的用途" class="headerlink" title="临时容器的用途"></a>临时容器的用途</h1><ul>
<li>当由于容器奔溃或容器镜像不包含调试工具而导致kubectl exec无用的时候，临时容器对于交互式故障排查非常有用。</li>
<li>比如，像distroless 镜像允许用户部署最小的容器镜像，从而减少攻击面并减少故障和漏洞的暴露。由于distroless 镜像不包含Shell或任何的调试工具，因此很难单独使用kubectl exec命令进行故障排查。</li>
<li>使用临时容器的时候，启用<a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/share-process-namespace/">进程命名空间共享</a> 很有帮助，可以查看其他容器中的进程。</li>
</ul>
<h1 id="临时容器的配置"><a href="#临时容器的配置" class="headerlink" title="临时容器的配置"></a>临时容器的配置</h1><p>目前来说，临时容器默认是关闭的。<br>查看临时容器是否开启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubelet -h | grep EphemeralContainers</span><br></pre></td></tr></table></figure>
<p>在每个节点（不管Master节点还是Node节点）修改kubectl的参数：</p>
<blockquote>
<p>注意：kubelet的启动文件的路径是&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kubelet.service.d&#x2F;10-kubeadm.conf</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改增加--feature-gates EphemeralContainers=<span class="literal">true</span></span></span><br><span class="line">KUBELET_EXTRA_ARGS=&quot;--cgroup-driver=systemd --feature-gates EphemeralContainers=true&quot;</span><br><span class="line">KUBE_PROXY_MODE=&quot;ipvs&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /var/lib/kubelet/config.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubelet.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">authentication:</span></span><br><span class="line">  <span class="attr">anonymous:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="string">falsevim</span> </span><br><span class="line">  <span class="attr">webhook:</span></span><br><span class="line">    <span class="attr">cacheTTL:</span> <span class="string">0s</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">x509:</span></span><br><span class="line">    <span class="attr">clientCAFile:</span> <span class="string">/etc/kubernetes/pki/ca.crt</span></span><br><span class="line"><span class="attr">authorization:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">Webhook</span></span><br><span class="line">  <span class="attr">webhook:</span></span><br><span class="line">    <span class="attr">cacheAuthorizedTTL:</span> <span class="string">0s</span></span><br><span class="line">    <span class="attr">cacheUnauthorizedTTL:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">clusterDNS:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line"><span class="attr">clusterDomain:</span> <span class="string">cluster.local</span></span><br><span class="line"><span class="attr">cpuManagerReconcilePeriod:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">evictionPressureTransitionPeriod:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">fileCheckFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">healthzBindAddress:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">healthzPort:</span> <span class="number">10248</span></span><br><span class="line"><span class="attr">httpCheckFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">imageMinimumGCAge:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeletConfiguration</span></span><br><span class="line"><span class="attr">nodeStatusReportFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">nodeStatusUpdateFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">rotateCertificates:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">runtimeRequestTimeout:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">staticPodPath:</span> <span class="string">/etc/kubernetes/manifests</span></span><br><span class="line"><span class="attr">streamingConnectionIdleTimeout:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">syncFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">volumeStatsAggPeriod:</span> <span class="string">0s</span></span><br><span class="line"><span class="comment"># 修改部分</span></span><br><span class="line"><span class="attr">featureGates:</span></span><br><span class="line">  <span class="attr">EphemeralContainers:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>加载配置文件重启kubelet：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>
<p>在Master节点修改kube-apiserver.yaml和kube-scheduler.yaml：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint:</span> <span class="number">192.168</span><span class="number">.49</span><span class="number">.100</span><span class="string">:6443</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">control-plane</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-apiserver</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--advertise-address=192.168.49.100</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--allow-privileged=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--authorization-mode=Node,RBAC</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--client-ca-file=/etc/kubernetes/pki/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--enable-admission-plugins=NodeRestriction</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--enable-bootstrap-token-auth=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--etcd-servers=https://127.0.0.1:2379</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--insecure-port=0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-allowed-names=front-proxy-client</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-extra-headers-prefix=X-Remote-Extra-</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-group-headers=X-Remote-Group</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-username-headers=X-Remote-User</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--secure-port=6443</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--service-account-issuer=https://kubernetes.default.svc.cluster.local</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--service-account-key-file=/etc/kubernetes/pki/sa.pub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--service-account-signing-key-file=/etc/kubernetes/pki/sa.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--service-cluster-ip-range=10.96.0.0/12</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--tls-cert-file=/etc/kubernetes/pki/apiserver.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--tls-private-key-file=/etc/kubernetes/pki/apiserver.key</span></span><br><span class="line">    <span class="comment"># 修改部分</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--feature-gates=EphemeralContainers=true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/kubernetes/manifests/kube-scheduler.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">kube-scheduler</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">control-plane</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-scheduler</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kube-scheduler</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--authentication-kubeconfig=/etc/kubernetes/scheduler.conf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--authorization-kubeconfig=/etc/kubernetes/scheduler.conf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--bind-address=127.0.0.1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--kubeconfig=/etc/kubernetes/scheduler.conf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--leader-elect=true</span></span><br><span class="line">    <span class="comment"># 修改部分</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--feature-gates=EphemeralContainers=true</span></span><br></pre></td></tr></table></figure>

<h1 id="使用临时容器在线debug"><a href="#使用临时容器在线debug" class="headerlink" title="使用临时容器在线debug"></a>使用临时容器在线debug</h1><p>创建一个nginx.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">shareProcessNamespace:</span> <span class="literal">true</span> <span class="comment"># 这个配置非常重要，一定要配置</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx.yaml</span><br></pre></td></tr></table></figure>
<p>创建ec.json文件，内容如下（注意：name是Pod的名称）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;EphemeralContainers&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ephemeralContainers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;sh&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;busybox&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;imagePullPolicy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IfNotPresent&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debugger&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stdin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tty&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;terminationMessagePolicy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;File&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用下面的命令更新已经运行的容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl replace --raw /api/v1/namespaces/default/pods/nginx/ephemeralcontainers  -f ec.json</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Pod</span></span><br><span class="line">kubectl describe pod nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接容器</span></span><br><span class="line">kubectl exec -it nginx -c debugger -- sh</span><br><span class="line">kubectl attach -it nginx -c debugger</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程的虚拟内存</title>
    <url>/2021/01/31/linux-process-vm/</url>
    <content><![CDATA[<p><strong>当我们创建一个进程时，我们知道进程有以下特点</strong>：</p>
<ul>
<li>每个进程都有自己独立的4G虚拟内存空间，各个进程的内存空间具有类似的结构</li>
<li>一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录 </li>
<li>每个进程已经分配的内存空间，都与对应的磁盘空间映射</li>
</ul>
<p><strong>那么问题来了</strong>：</p>
<ul>
<li>计算机明明没有那么多内存（n个进程的话就需要n*4G）内存</li>
<li>建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于一个程序对应的多个进程这种情况，浪费内存！</li>
</ul>
<p><strong>所以，实际上</strong>：</p>
<ul>
<li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址 </li>
<li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</li>
<li>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录</li>
<li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li>
<li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常</li>
<li>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘<br>进程的虚拟内存地址与实际物理内存映射理解图如下：<br><img src="/1.png" alt="1.png"></li>
</ul>
<p>页表工作原理及映射关系理解图如下：<br><img src="/2.png" alt="2.png"></p>
<p>可以认为虚拟空间都被映射到了磁盘空间中，并且由页表记录映射位置，当访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中，如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存，则选择牺牲页面，替换其他页面。</p>
<p>事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<p><strong>应用虚拟内存机制有很多优点</strong>：</p>
<ul>
<li>既然每个进程的内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处</li>
<li>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</li>
<li>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</li>
</ul>
]]></content>
      <tags>
        <tag>虚拟内存</tag>
        <tag>linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown Emoji</title>
    <url>/2021/01/31/markdown-emoji/</url>
    <content><![CDATA[<div class="row">
<div class="col col-sm-3">
<p><span class="github-emoji" alias="smile" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">&amp;#x1f604;</span> <code>:smile:</code> </p>

</div> 
<div class="col col-sm-3">
<p><span class="github-emoji" alias="rage" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f621.png?v8">&amp;#x1f621;</span> <code>:rage:</code> </p>

</div> 
<div class="col col-sm-3">
<p><span class="github-emoji" alias="x" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">&amp;#x274c;</span> <code>:x:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="clock1130" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f566.png?v8">&amp;#x1f566;</span> <code>:clock1130:</code> </p>

</div>
</div>
<div class="row">
<div class="col col-sm-3">
<p><span class="github-emoji" alias="house" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3e0.png?v8">&amp;#x1f3e0;</span> <code>:house:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="fire" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8">&amp;#x1f525;</span> <code>:fire:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="sun_with_face" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8">&amp;#x1f31e;</span> <code>:sun_with_face:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&amp;#x0031;&amp;#xfe0f;&amp;#x20e3;</span> <code>:one:</code> </p>

</div>
</div>
<div class="row">
<div class="col col-sm-3">
<p><span class="github-emoji" alias="recycle" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/267b.png?v8">&amp;#x267b;</span> <code>:recycle:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="dart" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3af.png?v8">&amp;#x1f3af;</span> <code>:dart:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="libra" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/264e.png?v8">&amp;#x264e;</span> <code>:libra:</code> </p>

</div>
<div class="col col-sm-3">
<p><span class="github-emoji" alias="underage" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f51e.png?v8">&amp;#x1f51e;</span> <code>:underage:</code> </p>

</div>
</div>

<blockquote>
<p>Check out the <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji Cheat Sheet</a> for all the emojis it supports</p>
</blockquote>
]]></content>
      <tags>
        <tag>emoji</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql常见面试题</title>
    <url>/2021/02/05/mysql-interview/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>面试题</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>分支管理模型</title>
    <url>/2022/04/25/project-dw-scm/</url>
    <content><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>构建一个能闭环管理分支生命周期的工具（系统），为业务团队提供便捷可靠的分支管理策略，为CI&#x2F;CD提供可数源的分支。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>为解决下面的问题，并为CI&#x2F;CD打造更加稳固的基石，我们决定立项做一个分支管理系统</p>
</blockquote>
<ul>
<li>项目越来越大，每次迭代都回有很多的功能分支，要上线的时候，不知道分支的合并情况</li>
<li>测试经常都需要进行功能组合测试，每次测试前都是需要找相应的研发进行分支合并</li>
<li>研发每次合并都要进入Gitlab页面进行手动创建</li>
<li>分支发布完成后，没有闭环将上线内容合入基线；发布分支不能及时更新基线变更，导致功能丢失</li>
</ul>
<h1 id="分支管理模型"><a href="#分支管理模型" class="headerlink" title="分支管理模型"></a>分支管理模型</h1><h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h2><blockquote>
<p>最早出现的分支管理模型，是若干模式的集大成者<br>通常包含五种类型的分支：Master(主干)、Develop(开发)、Feature(特性)、Release(发布)以及Hotfix(热修复)</p>
</blockquote>
<h3 id="分支类型"><a href="#分支类型" class="headerlink" title="分支类型"></a>分支类型</h3><ul>
<li><code>Master</code>：主干分支，也是正式发布版本的分支，其包含可以部署到生产环境中的代码，通常情况下只允许其他分支将代码合入，不允许向Master分支直接提交代码（对应生产环境）。</li>
<li><code>Develop</code>：开发分支，用来集成测试最新合入的开发成果，包含要发布到下一个Release的代码（对应开发环境）。</li>
<li><code>Feature</code>：特性分支，通常从Develop分支拉出，每个新特性的开发对应一个特性分支，用于开发人员提交代码并进行自测。自测完成后，会将Feature分支的代码合并至Develop分支，进入下一个Release。</li>
<li><code>Release</code>：发布分支，发布新版本时，基于Develop分支创建，发布完成后，合并到Master和Develop分支（对应集成测试环境）。</li>
<li><code>Hotfix</code>：热修复分支，生产环境发现新Bug时创建的临时分支，问题验证通过后，合并到Master和Develop分支。</li>
</ul>
<h3 id="分支流程"><a href="#分支流程" class="headerlink" title="分支流程"></a>分支流程</h3><p>通常开发过程中新特性的开发过程如下： </p>
<ol>
<li>从Develop分支拉取一条Feature分支，开发团队在Feature分支上进行新功能开发；</li>
<li>开发完成后，将Feature分支合入到Develop分支，并进行开发环境的验证；</li>
<li>开发环境验证完成，从Develop分支拉取一条Release分支，到测试环境进行SIT&#x2F;UAT测试；</li>
<li>测试无问题后，可将Develop分支合入Master分支，待发版时，直接将Master分支代码部署到生产环境。<br><img src="/1.png" alt="1"></li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>每个分支都有明确的定义，严格按照GitFlow管理项目代码的话，很难出现代码混乱</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>合并冲突，合并冲突在使用 Git Flow 是非常常见的。原因很简单：如果你有多个并行功能分支，他们长时间存在，那么很可能代码库的相同部分在两个功能分支中被分别更改。合并冲突不仅对于需要手动解决的开发人员来说是令人沮丧的，也增加了在代码中破坏某些功能的风险，因为当你不得不决定使用哪个版本代码时，很容易犯错。</li>
<li>功能分离，在合并到同一个分支之前，你不能测试两个功能的组合。当你在单独的分支中开发几天甚至几周的功能时，当合并回主分支后，可能也会发生两个功能的相互作用影响了你的代码。</li>
<li>并没有做到持续交付，在 Git Flow 分支模型下，发布是非常有计划的，一个 feature 必须要经过一系列步骤才能到达生产环境，在时间上平均一个 feature 都要等待 两周时间才能长线，这样的等待并非是需求上的“按计划发布”，而是从技术上就造成了发布瓶颈，显然难以达到持续交付的要求。</li>
<li>与持续集成相悖，你会发现，在坚持持续集成实践的情况下，feature 分支是一件非常矛盾的事情。持续集成鼓励更加频繁的代码集成和交互，让冲突越早解决越好。feature 分支的代码隔离策略却在尽可能推迟代码的集成。</li>
</ul>
<h2 id="AoneFlow"><a href="#AoneFlow" class="headerlink" title="AoneFlow"></a>AoneFlow</h2><blockquote>
<p>AoneFlow 是 GitFlow 的为适应持续集成的变种GitFlow<br>相对于 GitFlow，Aone要更加符合持续集成的理念</p>
</blockquote>
<p>AoneFlow 只使用三种分支类型：Master、feature、release，以及三条基本规则</p>
<h3 id="规则一，开始工作前，从master创建feature分支"><a href="#规则一，开始工作前，从master创建feature分支" class="headerlink" title="规则一，开始工作前，从master创建feature分支"></a>规则一，开始工作前，从master创建feature分支</h3><p>从代表最新已发布版本的master分支上创建一个通常以feature&#x2F;前缀命名的特性分支，然后在这个分支上提交代码修改。<br>也就是说，每个工作项（可以是一个人完成，或是多个人协作完成）对应一个特性分支，所有的修改都不允许直接提交到master分支。<br><img src="/2.png" alt="2"></p>
<h3 id="规则二，通过合并feature分支，形成release分支"><a href="#规则二，通过合并feature分支，形成release分支" class="headerlink" title="规则二，通过合并feature分支，形成release分支"></a>规则二，通过合并feature分支，形成release分支</h3><p>从master分支上拉出一条新分支，将所有本次要集成或发布的feature分支依次合并过去，从而得到release分支。<br>release分支通常以release&#x2F;前缀命名。<br><img src="/3.png" alt="3"></p>
<h3 id="规则三，发布到线上正式环境后，合并相应的release分支到master分支，在master分支上添加tag，同时删除该release分支关联的feature分支"><a href="#规则三，发布到线上正式环境后，合并相应的release分支到master分支，在master分支上添加tag，同时删除该release分支关联的feature分支" class="headerlink" title="规则三，发布到线上正式环境后，合并相应的release分支到master分支，在master分支上添加tag，同时删除该release分支关联的feature分支"></a>规则三，发布到线上正式环境后，合并相应的release分支到master分支，在master分支上添加tag，同时删除该release分支关联的feature分支</h3><p>为了避免在代码仓库里堆积大量历史上的feature分支，还应该清理掉已经上线部分feature分支。<br>如果要回溯历史版本，只需在master分支上找到相应的版本的tag即可。<br><img src="/4.png" alt="4"></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>保存了特性分支的概念，能独立的管理需求特性</li>
<li>去除了develop分支，强化了release分支的作用，加快了特性分支上线的进度</li>
<li>master作为主干分支，保证了一个永远稳定的版本</li>
<li>tag机制，保证代码可以快速回滚到指定的稳定版本</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>合并冲突依旧很多</li>
<li>没有hotfix概念，只能从master（或者tag）拉出分支进行开发上线；</li>
<li>hotfix没有明确规范，hotfix修改bug上线后，可能回导致当前release分支丢失hotfix的改动</li>
</ul>
<h2 id="TBD-Trunk-based-Development"><a href="#TBD-Trunk-based-Development" class="headerlink" title="TBD(Trunk based Development)"></a>TBD(Trunk based Development)</h2><p>Trunk based Development，又叫 主干开发 ，是一套代码分支管理策略，开发人员之间通过约定向被指定为 主干 的分支提交代码，以此抵抗因为长期存在的多分支导致的开发压力。<br>此举可 避免分支合并的困扰，保证随时拥有可发布的版本 。<br>“主干”这个词隐喻了树木生长的场景，树木最粗最长的部位是主干，分支从主干分离出来但是长度有限。<br>Trunk Based Development 模型是当下时代的产物，也已被 Google、Facebook、TW 等企业实践。<br><img src="/6.png" alt="6"><br>使用主干开发后，我们的代码库原则上就只能有一个 Trunk 分支即 master 分支了，所有新功能的提交也都提交到 master 分支上，保证每次提交后 master 分支都是可随时发布的状态。<br>没有了分支的代码隔离，测试和解决冲突都变得简单，持续集成也变得稳定了许多，但也有如下几个问题：</p>
<ul>
<li>如何避免发布引入未完成 Feature，答案是使用 Feature Toggle 。<ul>
<li>在代码库里加一个特性开关来随时打开和关闭新特性是最容易想到的也是最容易被质疑的解决方案。</li>
<li>Feature Toggle 是有成本的，不管是在加 Toggle 时的代码设计，还是在移除 Toggle 时的人力成本和风险，都是需要和它带来的价值进行衡量的。</li>
<li>如果功能能有统一的代码框架，将 Feature Toggle 融入到框架中，应该非常不错</li>
</ul>
</li>
<li>如何进行线上 Bug Fix，答案是在发布时打上 Release Tag，一旦发现这个版本有问题，如果此时 master 分支还没有其他提交，那可以直接在 master 分支上 Hot Fix 然后合并至 release 分支；如果 master 分支已经有了提交就需要做以下三件事：<ul>
<li>从 Release Tag 创建发布分支</li>
<li>在 master 上做 Fix Bug 提交。</li>
<li>将 Fix Bug 提交 Cherry Pick 到 release 分支。</li>
<li>为 release 分支打上新的 Tag 并做一次发布。</li>
</ul>
</li>
</ul>
<h3 id="优点（其实我个人比较喜欢这种）"><a href="#优点（其实我个人比较喜欢这种）" class="headerlink" title="优点（其实我个人比较喜欢这种）"></a>优点（其实我个人比较喜欢这种）</h3><ul>
<li>主干开发是助力实现 持续集成 和 持续交付 的关键因素。开发团队的成员一天多次地将代码提交到主干分支，满足了持续交付的必要条件。团队的工作在 24 小时内就可以被整合，这保证了代码版本随时处于可发布状态，使得持续交付成为可能。</li>
<li>分支模型非常简单，commit管理非常便捷</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>需要考虑未完成，或者有问题的commit上线，操作起来比较麻烦</li>
<li>需求进行上线问题修复时，需要手动进行Cherry Pick</li>
</ul>
<h2 id="GitHub-Flow"><a href="#GitHub-Flow" class="headerlink" title="GitHub Flow"></a>GitHub Flow</h2><p>GitHub Flow 是一个更轻量级的软件开发模型，示意图如下。<br>它摒弃了 Git Flow 中繁杂的分支， 只保留一个主分支 master 。<br>开发新功能时从 master 分支上拉取 feature 分支，开发完成后发起 Pull-Request ，小组内进行评审和反馈，此时也进行 Code Review 。<br>测试通过后合并回主分支。<br><img src="/5.png" alt="5"></p>
<p>相比于 Git Flow，这种方式因为省去了一些分支而降低了复杂度，同时也更符合持续集成的思想，以一张故事卡为集成的最小单位，相对来说集成的周期短，反馈的速度也快，能够及早的遇到问题并及早解决。</p>
<p>顺着持续集成的思想，如果我们把 GitHub Flow 分支模型做得再极致一点，我们不要 feature 分支，或者把 feature 分支只留在本地；<br>不需要使用 Pull-Request 而是直接 Push 到远程 master 分支，我们就做到了 Trunk based Development。</p>
<h2 id="我们的Flow"><a href="#我们的Flow" class="headerlink" title="我们的Flow"></a>我们的Flow</h2><p>由于个人的喜好，最初我的想法是用 TBD，作为我们们分支的模型。<br>但是公司的现状很快的否定了我的第一选择：</p>
<ul>
<li>当前公司还是半个月一个迭代，每个迭代都有固定的需求，业务方希望能通过分支来体现需求的开发上线进展</li>
<li>公司的CI检查机会可以说是没有，TBD的优势无法发挥出来，而TBD的特性会改变用户习惯，成为业务方的吐槽点。</li>
</ul>
<p>最终，我们选择AoneFlow，沿用了原先的三个规则的基础上，制定的一些新的规则：</p>
<ul>
<li>绝不允许直接master推送代码，只能代码发布验收通过之后，由系统自动合入。</li>
<li>尽量不要直接向release分支推送代码，release只是作为特性的集成分支，本身不需要带有任何特性，可以被随时删除，新建。</li>
<li>特性分支尽量不要拉去其他特性分支代码，这样会导致功能项目缠绕，如果被合并的特性有问题上不了线了，会导致自己的特性也上不了线。</li>
<li>hotfix分支也需要从master分支拉去，同时hotfix分支可以直接发布上线。</li>
</ul>
<h3 id="我们的分支流程（这里只有分支的流程，没有其他CI的流程）"><a href="#我们的分支流程（这里只有分支的流程，没有其他CI的流程）" class="headerlink" title="我们的分支流程（这里只有分支的流程，没有其他CI的流程）"></a>我们的分支流程（这里只有分支的流程，没有其他CI的流程）</h3><ol>
<li>当新版本迭代需求确认开始时，技术负责人会创建相应的release分支（默认 release&#x2F;v1.0.0&#x2F;test, release&#x2F;v1.0.0&#x2F;prod两个分支，release&#x2F;v1.0.0&#x2F;test 会自动绑定到 release&#x2F;v1.0.0&#x2F;prod ）。</li>
<li>研发在需求管理平台根据需求直接创建特性分支，特性分支会自动绑定到默认的测试release分支（release&#x2F;v1.0.0&#x2F;test）上。</li>
<li>研发在自己的特性分支进行代码开发，push之后，会自动合并到测试release分支中。</li>
<li>测试人员查看当前合入的特性的情况，进行功能或者集成测试。</li>
<li>测试完成测试工作后，合入代码到生产release分支中。</li>
<li>生产的release分支进行发布上线后，系统自动将其何如master分支，并进行自动归档操作。</li>
<li>master更新之后，会自动更新其他release分支（多版本同时迭代的情况），确保所有的release分支领先master分支。</li>
</ol>
<h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><ul>
<li>加入自动合并策略，特性分支提交可以直接合入release分支</li>
<li>立体化feature分支和release分支的管理，可明显的看的release分支下面的feature分支的合并情况</li>
<li>分支可以直接绑定需求，发布时可以直观看的当前发布是需求是哪些</li>
<li>master预检检查，确保当前发布代码不会落后master分支</li>
<li>master预合检查，确保当前发布代码可以没有冲突的合入到master分支（主干）</li>
<li>默认自动将发布验收的代码合入到master分支</li>
<li>master回合机制，前置保证所有的发布分支不会落后master分支</li>
</ul>
<h2 id="除了分支管理"><a href="#除了分支管理" class="headerlink" title="除了分支管理"></a>除了分支管理</h2><p>当然，分支管理不仅仅只是合并代码，我们还需要加入了代码质量检查，代码评审，自动化测试等环节，进一步推动 CI&#x2F;CD的脚步。</p>
]]></content>
      <tags>
        <tag>项目</tag>
        <tag>CI</tag>
        <tag>分支管理</tag>
      </tags>
  </entry>
  <entry>
    <title>【项目介绍】发布平台</title>
    <url>/2021/03/01/project-mb-phantom/</url>
    <content><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>公司现有的发布平台（简称老平台）使用Python的Django框架开发，随着业务量的提升，逐渐的出现的性能问题（发布高峰期接口返回明显时间大大的增加）<br>而老平台由于初期的架构设计已经日积月累的代码补丁，修复老平台代码变得异常困难。</p>
<h2 id="我们先看看老平台有哪些问题"><a href="#我们先看看老平台有哪些问题" class="headerlink" title="我们先看看老平台有哪些问题"></a>我们先看看老平台有哪些问题</h2><h3 id="老平台架构"><a href="#老平台架构" class="headerlink" title="老平台架构"></a>老平台架构</h3><p><img src="/phantom-1.png" alt="phantom-1"></p>
<h4 id="服务信息管理模块"><a href="#服务信息管理模块" class="headerlink" title="服务信息管理模块"></a>服务信息管理模块</h4><p>管理服务的相关信息（名称，应用类型，打包命令，启动命令，停止命令，容器配置，人员配置，发布配置）</p>
<h4 id="发布流程控制模块"><a href="#发布流程控制模块" class="headerlink" title="发布流程控制模块"></a>发布流程控制模块</h4><p>管理发布任务的流程：<br>创建任务 -&gt; 前置检查 -&gt; 打包 -&gt; 创建或者更新容器 -&gt; 服务启动检查 -&gt; 完成任务（回滚）</p>
<h4 id="权限模块"><a href="#权限模块" class="headerlink" title="权限模块"></a>权限模块</h4><p>管理人员信息，以及人员和项目的愿权限关系</p>
<h3 id="问题一：所有服务直接访问mysql"><a href="#问题一：所有服务直接访问mysql" class="headerlink" title="问题一：所有服务直接访问mysql"></a>问题一：所有服务直接访问mysql</h3><p>一开始这样其实也没什么大问题，毕竟系统都是一步一步做的，最初业务量不大的情况下，直接访问mysql，开发效率要高一些。<br>但是业务量的逐渐增加问题就来了，表越来越大，sql查询越来越慢，系统也越来越慢。</p>
<h3 id="问题二：三个服务职能没有分的很开"><a href="#问题二：三个服务职能没有分的很开" class="headerlink" title="问题二：三个服务职能没有分的很开"></a>问题二：三个服务职能没有分的很开</h3><p>服务信息管理存了服务的人员信息，权限模块也存储了人员信息，两者通过同步的方式来保证一致性。<br>服务的容器配置（容器数量，cpu，memory，hpa等），在发布流程控制和服务准入里面都有，也是通过同步的方式来保证一致性。</p>
<p>愿景都是美好的，我们通过同步的方式来相互同步信息，但是随着时间的推移，出现了大量的脏数据，清理花了我们很长时间，找问题也花了很长时间，反反复复的修改了好次。<br>最终起了一些定时任务，每天夜里定时全量同步。但是并没有解决问题，因为白天产生的不同步的问题，依然会给服务方带来不便。</p>
<h3 id="问题三：各个模块之间直接通过http接口相互调用"><a href="#问题三：各个模块之间直接通过http接口相互调用" class="headerlink" title="问题三：各个模块之间直接通过http接口相互调用"></a>问题三：各个模块之间直接通过http接口相互调用</h3><p>一个接口有问题，整个平台GG。<br>直接使用ip端口调用，服务水平扩展成了幻想。<br>服务器故障，迁移如登天。</p>
<p>做过一些优化：</p>
<ul>
<li>服务内部同步域名访问</li>
<li>服务上面加一层 nginx模块作为代理，实现的服务能够水平扩展</li>
</ul>
<h3 id="问题四：前后虽然分离了，但是很多业务逻辑出现在了前端"><a href="#问题四：前后虽然分离了，但是很多业务逻辑出现在了前端" class="headerlink" title="问题四：前后虽然分离了，但是很多业务逻辑出现在了前端"></a>问题四：前后虽然分离了，但是很多业务逻辑出现在了前端</h3><p>比如， dev环境自动发布是由前端触发的；应用的容器列表，通过前端刷新了之后更新到后端<br>说的好听些是前后端分离的架构，其实还不如不分离，维护成本大大的提升，还有没有带来收益。</p>
<h3 id="问题五：多个k8s集群直接调用"><a href="#问题五：多个k8s集群直接调用" class="headerlink" title="问题五：多个k8s集群直接调用"></a>问题五：多个k8s集群直接调用</h3><ul>
<li>每次都要根据不同的机房加载k8s config</li>
<li>k8s接口接口复杂，对于开发有学习成本</li>
</ul>
<h2 id="新平台优化"><a href="#新平台优化" class="headerlink" title="新平台优化"></a>新平台优化</h2><h3 id="新平台架构"><a href="#新平台架构" class="headerlink" title="新平台架构"></a>新平台架构</h3><p><img src="/phantom-2.png" alt="phantom-2"></p>
<h3 id="优化一：将原来的3个服务拆分成了13个微服务，同时添加服务注册中心"><a href="#优化一：将原来的3个服务拆分成了13个微服务，同时添加服务注册中心" class="headerlink" title="优化一：将原来的3个服务拆分成了13个微服务，同时添加服务注册中心"></a>优化一：将原来的3个服务拆分成了13个微服务，同时添加服务注册中心</h3><ul>
<li><strong>发布系统</strong>：发布流程管理，容器配置管理</li>
<li><strong>打包系统</strong>：打包配置管理，完成发布的打包任务</li>
<li><strong>服务准入</strong>：服务的基本信息</li>
<li><strong>权限系统</strong>：管理用户的权限</li>
<li><strong>管理系统</strong>：管理员后台系统，用于一些系统配置，比如添加jar版本检查，添加维护规则，添加白名单等</li>
<li><strong>平台事件</strong>：搜集平台的事件写入MQ，比如应用开始发布，应用权限修改，应用信息修改，重启容器，销毁容器等等</li>
<li><strong>工单系统</strong>：管理流程审批</li>
<li><strong>前置检查</strong>：发布前检查当前发布是否可以进行</li>
<li><strong>平台事件发送系统</strong>：从MQ读取事件，更具配置发送到指定的钉钉群</li>
<li><strong>事件消费</strong>：这里的事件是K8S的事件和上面的平台事件是不一样的，改逐渐主要消费K8S产生的Pod， Deployment，HPA的事件</li>
<li><strong>事件系统</strong>：生产K8S的变更事件</li>
<li><strong>Runtime</strong>：K8S controller复杂封装K8S接口</li>
</ul>
<p>架构支持服务自动水平扩容；<br>注册中心有失败重试的机制，一个服务有问题，会尝试调用其他节点；</p>
<h3 id="优化二：在K8S上加了一层"><a href="#优化二：在K8S上加了一层" class="headerlink" title="优化二：在K8S上加了一层"></a>优化二：在K8S上加了一层</h3><blockquote>
<p>没有什么问题是加一层解决不了的，如果有，就加两层</p>
</blockquote>
<p>我们有多套K8S集群，之前是直接调用K8S的接口的，每个集群都是单独一个client。<br>加了runtime之后，runtime对K8S的接口进行了二次封装，平台内部不需要在管理各个K8S集群的client，直接调用RunTime服务就好。<br>优化入参和返回值，符合系统整体的标准。<br>整合一个底层接口，一个接口完成一套业务。</p>
<h3 id="优化三：K8S事件和平台事件接入MQ"><a href="#优化三：K8S事件和平台事件接入MQ" class="headerlink" title="优化三：K8S事件和平台事件接入MQ"></a>优化三：K8S事件和平台事件接入MQ</h3><p>防治了因为接口调用失败，导致的事件丢失<br>平台事件可以提供给他部门使用<br>当K8S产生大量事件的时候，MQ启动很好的消峰作用</p>
<h3 id="优化四：添加redis缓存"><a href="#优化四：添加redis缓存" class="headerlink" title="优化四：添加redis缓存"></a>优化四：添加redis缓存</h3><p>所有服务添加缓存机制，大大的加快的查询的速度，同时也大大的减小的mysql的压力</p>
<h3 id="优化五：mysql各个系统独立的database，读写分离。"><a href="#优化五：mysql各个系统独立的database，读写分离。" class="headerlink" title="优化五：mysql各个系统独立的database，读写分离。"></a>优化五：mysql各个系统独立的database，读写分离。</h3><p>各个系统独立database互不影响<br>读写分离，同时提升了读和写的效率</p>
<h3 id="优化六：-统一的网关服务暴露restful接口"><a href="#优化六：-统一的网关服务暴露restful接口" class="headerlink" title="优化六： 统一的网关服务暴露restful接口"></a>优化六： 统一的网关服务暴露restful接口</h3><p>各个服务只需要编写RPC方法就好，由网关服务统一进行restful和RPC的转化。</p>
<h2 id="有待继续优化"><a href="#有待继续优化" class="headerlink" title="有待继续优化"></a>有待继续优化</h2><ul>
<li>DB上层应该要再加一层DB连接控制层</li>
<li>session虽然做了redis缓存，但是不应该用mysql存储，直接放在redis里面就好了</li>
<li>redis只要string的数据类型，其他同的信息可以用不用的类型存储</li>
<li>k8s事件只写到了一个分片里面，因为消费事件需要是有续的，所有分片，多个消费者的情况下就变得无序了</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实新平台的架构并不是很先进，也就是常规的微服务的架构。<br>在cache，DB，MQ的选型上并没有花太多功夫，主要考虑了自己熟悉的服务。<br>系统是一步一步迭代的，老平台 -&gt; 新平台 的优化，主要是针对老平台的缺点来的，新平台应该也会有一些问题。<br>我只一步一步的走，但当前平台又不能处理现有的业务场景的时候，就是考虑下一代架构的时候了。</p>
<h2 id="附上一些系统图片"><a href="#附上一些系统图片" class="headerlink" title="附上一些系统图片"></a>附上一些系统图片</h2><p><img src="/phantom-3.png" alt="phantom-3"><br><img src="/phantom-4.png" alt="phantom-4"><br><img src="/phantom-5.png" alt="phantom-5"><br><img src="/phantom-6.png" alt="phantom-6"><br><img src="/phantom-7.png" alt="phantom-7"><br><img src="/phantom-8.png" alt="phantom-8"><br><img src="/phantom-9.png" alt="phantom-9"><br><img src="/phantom-10.png" alt="phantom-10"><br><img src="/phantom-11.png" alt="phantom-11"></p>
]]></content>
      <tags>
        <tag>项目</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>redis常见面试题</title>
    <url>/2021/02/05/redis-interview/</url>
    <content><![CDATA[<h1 id="Redis常见的数据结构？"><a href="#Redis常见的数据结构？" class="headerlink" title="Redis常见的数据结构？"></a>Redis常见的数据结构？</h1><blockquote>
<p>String、Hash、List、Set、ZSet</p>
</blockquote>
<h2 id="String-字符串类型"><a href="#String-字符串类型" class="headerlink" title="String 字符串类型"></a>String 字符串类型</h2><p>string类型是redis中最基本的数据类型，一个key对应一个value。<br>string类型是二进制安全的，意思是redis的string可以包含任何数据, 如数字, 字符串, jpg图片或者序列化的对象。<br><strong>实战场景：</strong></p>
<ul>
<li>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li>
<li>session：常见方案spring session + redis实现session共享</li>
</ul>
<h2 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h2><p>是一个Map，指值本身又是一种键值对结构，如 value&#x3D;<code>&#123;&#123;field1,value1&#125;,......fieldN,valueN&#125;&#125;</code><br><strong>实战场景</strong></p>
<ul>
<li>缓存： 能直观，相比<strong>string更节省空间</strong>，的维护缓存信息，如用户信息，视频信息等。</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>List 说白了就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。<br><strong>使用列表的技巧</strong></p>
<ul>
<li>lpush+lpop&#x3D;Stack(栈)</li>
<li>lpush+rpop&#x3D;Queue（队列）</li>
<li>lpush+ltrim&#x3D;Capped Collection（有限集合）</li>
<li>lpush+brpop&#x3D;Message Queue（消息队列）<br><strong>实战场景</strong></li>
<li>timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。</li>
</ul>
<h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><p>集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 </p>
<ul>
<li>不允许有重复的元素 </li>
<li>集合中的元素是无序的，不能通过索引下标获取元素</li>
<li>支持集合间的操作，可以取多个集合取交集、并集、差集。<br><strong>实战场景</strong></li>
<li>标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li>
<li>点赞，或点踩，收藏等，可以放到set中实现</li>
</ul>
<h2 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset 有序集合"></a>zset 有序集合</h2><p>有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。</p>
<blockquote>
<p>有序集合中的元素不可以重复，但是score 分数 可以重复，就和一个班里的同学学号不能重复，但考试成绩可以相同</p>
</blockquote>
<p><strong>实战场景</strong></p>
<ul>
<li>排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li>
</ul>
<h1 id="Redis持久化的原理及优化"><a href="#Redis持久化的原理及优化" class="headerlink" title="Redis持久化的原理及优化"></a>Redis持久化的原理及优化</h1><blockquote>
<p><strong>原文作者:</strong> 大愚Talk<br><strong>原文地址:</strong> <a href="https://juejin.cn/post/6844903655527677960">一文看懂Redis的持久化原理</a></p>
</blockquote>
<p>Redis为持久化提供了两种方式：</p>
<ul>
<li><strong>RDB</strong>：在指定的时间间隔能对你的数据进行快照存储。</li>
<li><strong>AOF</strong>：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</li>
</ul>
<p>本文将通过下面内容的介绍，希望能够让大家更全面、清晰的认识这两种持久化方式，同时理解这种保存数据的思路，应用于自己的系统设计中。</p>
<ul>
<li>持久化的配置 </li>
<li>RDB与AOF持久化的工作原理</li>
<li>如何从持久化中恢复数据</li>
<li>关于性能与实践建议</li>
</ul>
<h2 id="持久化的配置"><a href="#持久化的配置" class="headerlink" title="持久化的配置"></a>持久化的配置</h2><p>为了使用持久化的功能，我们需要先知道该如何开启持久化的功能。</p>
<h3 id="RDB的持久化配置"><a href="#RDB的持久化配置" class="headerlink" title="RDB的持久化配置"></a>RDB的持久化配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间策略</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件保存路径</span></span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果持久化出错，主进程是否停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否压缩</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入时是否检查</span></span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>
<p>配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。</p>
<ul>
<li><code>save 900 1</code> 表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份</li>
<li><code>save 300 10</code> 表示300s内有10条写入，就产生快照</li>
</ul>
<p>下面的类似，那么为什么需要配置这么多条规则呢？<br>因为Redis每个时段的读写请求肯定不是均衡的，为了平衡性能与数据安全，我们可以自由定制什么情况下触发备份。所以这里就是根据自身Redis写入情况来进行合理配置。</p>
<p><code>stop-writes-on-bgsave-error yes</code> 这个配置也是非常重要的一项配置，这是当备份进程出错时，主进程就停止接受新的写入操作，是为了保护持久化的数据一致性问题。<br><strong>如果自己的业务有完善的监控系统，可以禁止此项配置，否则请开启</strong></p>
<p>关于压缩的配置 <code>rdbcompression yes</code>，建议没有必要开启，毕竟Redis本身就属于CPU密集型服务器，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。</p>
<p>当然如果你想要禁用RDB配置，也是非常容易的，只需要在save的最后一行写上：<code>save &quot;&quot;</code></p>
<h3 id="AOF的配置"><a href="#AOF的配置" class="headerlink" title="AOF的配置"></a>AOF的配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否开启aof</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件名称</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">aof重写期间是否同步</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重写触发配置</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载aof时如果有错如何处理</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件重写策略</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
<p>还是重点解释一些关键的配置：<br><code>appendfsync everysec</code> 它其实有三种模式:</p>
<ul>
<li><strong>always</strong>：把每个写命令都立即同步到aof，很慢，但是很安全</li>
<li><strong>everysec</strong>：每秒同步一次，是折中方案</li>
<li><strong>no</strong>：redis不处理交给OS来处理，非常快，但是也最不安全</li>
</ul>
<p>一般情况下都采用 <strong>everysec</strong> 配置，这样可以兼顾速度与安全，最多损失1s的数据。</p>
<p><code>aof-load-truncated yes</code> 如果该配置启用，在加载时发现aof尾部不正确时，会向客户端写入一个log，但是会继续执行<br>如果设置为 <code>no</code> ，发现错误就会停止，必须修复后才能重新加载。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>关于原理部分，我们主要来看RDB与AOF是如何完成持久化的，他们的过程是如何。</p>
<p>在介绍原理之前先说下Redis内部的定时任务机制，定时任务执行的频率可以在配置文件中通过 <code>hz 10</code> 来设置（这个配置表示1s内执行10次，也就是每100ms触发一次定时任务）。<br>该值最大能够设置为：<code>500</code>，但是不建议超过：<code>100</code>，因为值越大说明执行频率越频繁越高，这会带来CPU的更多消耗，从而影响主进程读写性能。</p>
<p>定时任务使用的是Redis自己实现的 <code>TimeEvent</code>，它会定时去调用一些命令完成定时任务，这些任务可能会阻塞主进程导致Redis性能下降。<br>因此我们在配置Redis时，一定要整体考虑一些会触发定时任务的配置，根据实际情况进行调整。</p>
<h3 id="RDB的原理"><a href="#RDB的原理" class="headerlink" title="RDB的原理"></a>RDB的原理</h3><p>在Redis中RDB持久化的触发分为两种：自己手动触发与Redis定时触发。<br><strong>针对RDB方式的持久化，手动触发可以使用：</strong></p>
<ul>
<li>save：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。</li>
<li>bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。</li>
</ul>
<p><strong>而自动触发的场景主要是有以下几点：</strong></p>
<ul>
<li>根据我们的 <code>save m n</code> 配置规则自动触发；</li>
<li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 <code>bgsave</code>；</li>
<li>执行 <code>debug reload</code> 时；</li>
<li>执行 <code>shutdown</code>时，如果没有开启aof，也会触发。</li>
</ul>
<p>由于 <code>save</code> 基本不会被使用到，我们重点看看 <code>bgsave</code> 这个命令是如何完成RDB的持久化的。<br><img src="/redis-1.png" alt="redis-1"><br>这里注意的是 <code>fork</code> 操作会阻塞，导致Redis读写性能下降。<br>我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。<br>以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。</p>
<h3 id="AOF的原理"><a href="#AOF的原理" class="headerlink" title="AOF的原理"></a>AOF的原理</h3><p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是 <code>appendfsync everysec</code> 配置，会有1s损耗），第二步是对aof文件的重写。</p>
<p>对于增量追加到文件这一步主要的流程是：命令写入-&gt;追加到aof_buf-&gt;同步到aof磁盘。<br>那么这里为什么要先写入buf在同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。</p>
<p>aof重写是为了减少aof文件的大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。<br>fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。</p>
<ul>
<li>手动触发： <code>bgrewriteaof</code></li>
<li>自动触发 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</li>
</ul>
<p>下面来看看重写的一个流程图：<br><img src="/redis-2.png" alt="redis-2"><br>对于上图有四个关键点补充一下：</p>
<ul>
<li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。</li>
<li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。</li>
<li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li>
<li>AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。</li>
</ul>
<blockquote>
<p>不论是RDB还是AOF都是先写入一个临时文件，然后通过 rename 完成文件的替换工作。</p>
</blockquote>
<h2 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h2><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p>
<p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：<br><img src="/redis-3.png" alt="redis-3"><br>启动时会先检查AOF文件是否存在，如果不存在就尝试加载RDB。<br>那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p>
<h2 id="新能与实践"><a href="#新能与实践" class="headerlink" title="新能与实践"></a>新能与实践</h2><p>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</p>
<ul>
<li>降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</li>
<li>控制Redis最大使用内存，防止fork耗时过长；</li>
<li>使用更牛逼的硬件；</li>
<li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li>
</ul>
<p>在线上我们到底该怎么做？我提供一些自己的实践经验。</p>
<ul>
<li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li>
<li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li>
<li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li>
<li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li>
<li>RDB持久化与AOF持久化可以同时存在，配合使用。</li>
</ul>
<p>本文的内容主要是运维上的一些注意点，但我们开发者了解到这些知识，在某些时候有助于我们发现诡异的bug。</p>
<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><blockquote>
<p><strong>原文作者:</strong> 原来是咔咔<br><strong>原文地址:</strong> <a href="https://juejin.cn/post/6844904178519654414">写给大忙人的Redis主从复制，花费五分钟让你面试不尴尬</a><br>相信很多小伙伴都已经配置过主从复制，但是对于redis主从复制的工作流程和常见问题很多都没有深入的了解。</p>
</blockquote>
<h2 id="什么是Redis主从复制"><a href="#什么是Redis主从复制" class="headerlink" title="什么是Redis主从复制"></a>什么是Redis主从复制</h2><p>主从复制就是现在有俩台redis服务器，把一台redis的数据同步到另一台redis数据库上。<br>前者称之为主节点（master），后者为从节点（slave）。<br>数据是只能master往slave同步单向。</p>
<p>但是在实际过程中是不可能只有俩台redis服务器来做主从复制的，这也就意味这每台redis服务器都有可能会称为主节点（master）</p>
<p>下图案例中，我们的slave3既是master的从节点，也是slave的主节点。<br><img src="/redis-4.png" alt="redis-4"><br>先知道这么个概念，更多详解继续查看下文。</p>
<h2 id="为什么需要Redis主从复制"><a href="#为什么需要Redis主从复制" class="headerlink" title="为什么需要Redis主从复制"></a>为什么需要Redis主从复制</h2><p>假设我们现在就一台redis服务器，也就是单机状态。<br>在这种情况下会出现的第一个问题就是服务器宕机，直接导致数据丢失。如果项目是跟￥占关系的，那造成的后果就可想而知。<br>第二个情况就是内存问题了，当只有一台服务器时内存肯定会到达峰值的，不可能对一台服务器进行无限升级的。<br>所以针对以上俩个问题，我们就多准备几台服务器，配置主从复制。<br>将数据保存在多个服务器上,并且保证每个服务器的数据是同步的。<br>即使有一个服务器宕机了，也不会影响用户的使用。redis可以继续实现高可用、同时实现数据的冗余备份。<br><img src="/redis-5.png" alt="redis-5"><br>这会应该会有很多疑问，master跟slave怎么连接呢？ 如何同步数据呢？ 假如master服务器宕机了呢？别着急，一点一点解决你的问题。</p>
<h2 id="Redis主从复制的作用"><a href="#Redis主从复制的作用" class="headerlink" title="Redis主从复制的作用"></a>Redis主从复制的作用</h2><p>在上边我们说了为什么使用redis的主从复制，那么主从复制的作用就是针对为什么使用它来讲了。<br>我们继续使用这个图来谈论<br><img src="/redis-5.png" alt="redis-5"></p>
<ul>
<li>第一点是数据冗余了，实现了数据的热备份，是持久化之外的另一种方式。</li>
<li>第二点是针对单机故障问题。当主节点也就是master出现问题时，可以由从节点来提供服务也就是slave，实现了快速恢复故障，也就是服务冗余。</li>
<li>第三点是读写分离，master服务器主要是写，slave主要用来读数据，可以提高服务器的负载能力。同时可以根据需求的变化，添加从节点的数量。</li>
<li>第四点是负载均衡，配合读写分离，有主节点提供写服务，从节点提供读服务，分担服务器负载，尤其在写少读多的情况下，通过多个从节点分担读负载，可以大大提高redis服务器的并发量和负载。</li>
<li>第五点是高可用的基石，主从复制是哨兵和集群能够实施的基础，因此我们可以说主从复制是高可用的基石。</li>
</ul>
<h2 id="配置Redis主从复制"><a href="#配置Redis主从复制" class="headerlink" title="配置Redis主从复制"></a>配置Redis主从复制</h2><p>从redis：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">slave-serve-stale-data yes  // 默认就是开启的，当slave和master断开链接时，slave依旧会返回数据</span><br><span class="line">slave-read-only yes // 默认只读</span><br></pre></td></tr></table></figure>

<h2 id="主从复制工作原理"><a href="#主从复制工作原理" class="headerlink" title="主从复制工作原理"></a>主从复制工作原理</h2><h3 id="主从复制的三个阶段"><a href="#主从复制的三个阶段" class="headerlink" title="主从复制的三个阶段"></a>主从复制的三个阶段</h3><p>主从复制完整的工作流程分为以下三个阶段。每一段都有自己的内部工作流程，那么我们会对这三个过程进行谈论。</p>
<ul>
<li>建立连接过程：这个过程就是slave跟master连接的过程</li>
<li>数据同步过程：是master给slave同步数据的过程</li>
<li>命令传播过程：是反复同步数据<br><img src="/redis-6.png" alt="redis-6"></li>
</ul>
<h3 id="第一阶段：建立连接过程"><a href="#第一阶段：建立连接过程" class="headerlink" title="第一阶段：建立连接过程"></a>第一阶段：建立连接过程</h3><p><img src="/redis-7.png" alt="redis-7"><br>上图是一个完整主从复制建立连接工作流程。然后使用简短的话语来描述上边的工作流程。</p>
<ul>
<li>设置master的地址和端口，保存master的信息</li>
<li>建立socket连接（这个连接做的事情下文会说）</li>
<li>持续发送ping命令</li>
<li>身份验证</li>
<li>发送slave端口信息</li>
</ul>
<p>在建立连接的过程中，从节点会保存master的地址和端口、主节点master保存从节点slave的端口。</p>
<h3 id="第二阶段：数据同步阶段过程"><a href="#第二阶段：数据同步阶段过程" class="headerlink" title="第二阶段：数据同步阶段过程"></a>第二阶段：数据同步阶段过程</h3><p><img src="/redis-8.png" alt="redis-8"><br>这张图是详细描述第一次从节点连接主节点时的数据同步过程。<br>当从节点第一次连接主节点时，先会执行一次全量复制这次的全量复制是无法避免的。<br>全量复制执行完成后，主节点就会发送复制积压缓冲区的数据，然后从节点就会执行bgrewriteaof恢复数据，这也就是部分复制。<br>在这个阶段提到了三个新点，全量复制、部分复制、复制缓冲积压区。会在下文的常见问题里详细说明这几个点。</p>
<h3 id="第三阶段：命令传播阶段"><a href="#第三阶段：命令传播阶段" class="headerlink" title="第三阶段：命令传播阶段"></a>第三阶段：命令传播阶段</h3><p>当master数据库被修改后，主从服务器的数据不一致后，此时就会让主从数据同步到一致，这个过程称之为命令传播。<br>master会将接收到的数据变更命令发送给slave，slave接收命令后执行命令，让主从数据达到一致。<br><strong>命令传播阶段的部分复制</strong></p>
<ul>
<li>在命令传播阶段出现断网的情况，或者网络抖动时会导致连接断开（connection  lost）</li>
<li>这个时候主节点master还是会继续往replbackbuffer（复制缓冲积压区）写数据</li>
<li>从节点会继续尝试连接主机（connect to master）</li>
<li>当从节点把自己的runid和复制偏移量发送给主节点，并且执行pysnc命令同步</li>
<li>如果master判断偏移量是在复制缓冲区范围内，就会返回continue命令。并且发送复制缓冲区的数据给从节点。</li>
<li>从节点接收数据执行bgrewriteaof，恢复数据</li>
</ul>
<h2 id="详细介绍主从复制原理（全量复制-部分复制）"><a href="#详细介绍主从复制原理（全量复制-部分复制）" class="headerlink" title="详细介绍主从复制原理（全量复制+部分复制）"></a>详细介绍主从复制原理（全量复制+部分复制）</h2><p><img src="/redis-9.png" alt="redis-9"><br>这个过程就是主从复制最齐全的流程讲解。那么下来我们对每一步进程简单的介绍</p>
<ul>
<li>从节点发送指令<code>psync ? 1 psync runid offset</code>找对应的runid索取数据。但是这里可以考虑一下，当从节点第一次连接的时候根本就不知道主节点的<code>runid</code>和<code>offset</code>。所以第一次发送的指令是<code>psync ？ 1</code>意思就是主节点的数据我全要。</li>
<li>主节点开始执行bgsave生成RDB文件，记录当前的复制偏移量offset</li>
<li>主节点这个时候会把自己的<code>runid</code>和<code>offset</code>通过 +FULLRESYNC runid offset 指令 通过socket发送RDB文件给从节点。</li>
<li>从节点接收到+FULLRESYNC 保存主节点的<code>runid</code>和<code>offset</code>然后清空当前所有数据，通过socket接收RDB文件，开始恢复RDB数据。</li>
<li>在全量复制后，从节点已经获取到了主节点的<code>runid</code>和<code>offset</code>，开始发送指令<code>psync runid offset</code></li>
<li>主节点接收指令，判断<code>runid</code>是否匹配，判断<code>offset</code>是否在复制缓冲区中。</li>
<li>主节点判断<code>runid</code>和<code>offset</code>有一个不满足，就会在返回到步骤2继续执行全量复制。这里的<code>runid</code>不匹配只有的可能是从节点重启了这个问题后边会解决，offset（偏移量）不匹配就是复制积压缓冲区溢出了。 如果runid或offset校验通过，从节点的offset和主节点的offset相同时则忽略。 如果runid或offset检验通过，从节点的offset与offset不相同，则会发送 +CONTINUE  offset(这个offset为主节点的)，通过socket发送复制缓冲区中从节点offset到主节点offset的数据。</li>
<li>从节点收到+CONTINUE 保存master的offset 通过socket接收到信息后，执行bgrewriteaof，恢复数据。</li>
</ul>
<p>1-4是全量复制 5-8是部分复制<br>在主节点的第3步下面 主节点在主从复制的期间是一直在接收客户端的数据，主节点的offset是一直变化的。<br>只有有变化就会给每个slave进行发送，这个发送的过程称之为心跳机制</p>
<h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>在命令传播阶段是，主节点与从节点之间一直都需要进行信息互换，使用心跳机制进行维护，实现主节点和从节点连接保持在线。<br><strong>master心跳</strong></p>
<ul>
<li>指令：ping </li>
<li>默认10秒进行一次，是由参数repl-ping-slave-period决定的</li>
<li>主要做的事情就是判断从节点是否在线</li>
<li>可以使用info replication 来查看从节点租后一次连接时间的间隔，lag为0或者为1就是正常状态。<br><strong>slave心跳任务</strong></li>
<li>指令：replconf ack {offset}</li>
<li>每秒执行一次</li>
<li>主要做的事情是给主节点发送自己的复制偏移量，从主节点获取到最新的数据变更命令，还做一件事情就是判断主节点是否在线。</li>
</ul>
<p><strong>心跳阶段的注意事项</strong><br>主节点为保障数据稳定性，当从节点挂掉的数量或者延迟过高时。将会拒绝所有信息同步。<br>这里有俩个参数可以进行配置调整：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 2</span><br><span class="line">min-slaves-max-lag 8</span><br></pre></td></tr></table></figure>
<p>这俩个参数表示从节点的数量就剩余2个，或者从节点的延迟大于8秒时，主节点就会强制关闭master功能，停止数据同步。<br>那么主节点是如何知道从节点挂掉的数量和延迟时间呢！<br>在心跳机制里边slave 会每隔一秒发送perlconf ack 这个指令，这个指令可携带偏移量，也可以携带从节点的延迟时间和从节点的数量。</p>
<h2 id="部分复制的三个核心要素"><a href="#部分复制的三个核心要素" class="headerlink" title="部分复制的三个核心要素"></a>部分复制的三个核心要素</h2><h3 id="服务器的运行id（run-id）"><a href="#服务器的运行id（run-id）" class="headerlink" title="服务器的运行id（run id）"></a>服务器的运行id（run id）</h3><p>我们先看一下这个run id是什么，执行info命令即可看到。在上文中我们查看启动日志信息也可以看到。<br><img src="/redis-11.png" alt="redis-11"><br>redis在启动时会自动生成一个随机的id（这里需要注意的是每次启动的id都会不一样），是由40个随机的十六进制字符串组成，用来唯一识别一个redis节点。<br>在主从复制初次启动时，master会把自己的runid发送给slave，slave会保存master的这个id，我们可以使用info命令查看<br><img src="/redis-12.png" alt="redis-12"><br>当断线重连时，slave把这个id发送给master，如果slave保存的runid与master现在的runid相同，master会尝试使用部分复制（这块能否复制成功还有一个因素就是偏移量）。<br>如果slave保存的runid与master现在的runid不同，则会直接进行全量复制。</p>
<h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><p>复制缓冲积压区是一个先进先出的队列，用户存储master收集数据的命令记录。复制缓冲区的默认存储空间是1M。<br>可以在配置文件修改<code>repl-backlog-size 1mb</code>来控制缓冲区大小，这个比例可以根据自己的服务器内存来修改。<br><strong>复制缓冲区到底存储的是什么？</strong><br>复制积压缓冲区就是存储的aof持久化的数据，并且以字节分开，并且每个字节都有自己的偏移量。这个偏移量也就是复制偏移量（offset）<br><img src="/redis-13.png" alt="redis-13"><br><strong>那为什么会说复制缓冲积压区有可能会导致全量复制呢</strong><br>在命令传播阶段，主节点会把收集的数据存储到复制缓冲区中，然后在发送给从节点。<br>就是这里出现了问题，当主节点数据量在一瞬间特别大的时候，超出了复制缓冲区的内存，就会有一部分数据会被挤出去，从而导致主节点和从节点的数据不一致。<br>从而进行全量复制。如果这个缓冲区大小设置不合理那么很大可能会造成死循环，从节点就会一直全量复制，清空数据，全量复制。</p>
<h3 id="复制偏移量（offset）"><a href="#复制偏移量（offset）" class="headerlink" title="复制偏移量（offset）"></a>复制偏移量（offset）</h3><p><img src="/redis-14.png" alt="redis-14"><br>主节点复制偏移量是给从节点发送一次记录一次，从节点是接收一次记录一次。<br>用于同步信息，对比主节点和从节点的差异，当slave断联时恢复数据使用。<br>这个值也就是来自己于复制缓冲积压区里边的那个偏移量。</p>
<h2 id="主从复制常见的问题"><a href="#主从复制常见的问题" class="headerlink" title="主从复制常见的问题"></a>主从复制常见的问题</h2><h3 id="主节点重启问题（内部优化）"><a href="#主节点重启问题（内部优化）" class="headerlink" title="主节点重启问题（内部优化）"></a>主节点重启问题（内部优化）</h3><p>当主节点重启后，runid的值将发生变化，会导致所有的从节点进行全量复制。<br>这个问题我们无需考虑，知道系统是怎么优化的即可。<br>在建立完主从复制后主节点会创建master-replid变量，这个生成的策略跟runid一样，长度是41位，runid长度是40位，然后发送给从节点。<br><img src="/redis-10.png" alt="redis-10"><br>在主节点执行shutdown save命令时，进行了一次RDB持久化会把runid 和 offset保存到RDB文件中。可以使用命令redis-check-rdb查看该信息。</p>
<h3 id="从节点网络中断偏移量越界导致全量复制"><a href="#从节点网络中断偏移量越界导致全量复制" class="headerlink" title="从节点网络中断偏移量越界导致全量复制"></a>从节点网络中断偏移量越界导致全量复制</h3><p>由于网络环境不佳，从节点网络中断。复制积压缓冲区内存过小导致数据溢出，伴随着从节点偏移量越界，导致全量复制。有可能会导致反复的全量复制。<br><strong>解决方案</strong>：修改复制积压缓冲区的大小：repl-backlog-size<br><strong>设置建议</strong>：测试主节点连接从节点的时间，获取主节点每秒平均产生的命令总量write_size_per_second<br>复制缓冲区空间设置 &#x3D; 2 * 主从连接时间 * 主节点每秒产生的数据总量</p>
<h3 id="频繁的网路中断"><a href="#频繁的网路中断" class="headerlink" title="频繁的网路中断"></a>频繁的网路中断</h3><p>由于主节点的cpu占用过高，或者从节点频繁连接。出现这种情况造成的结果就是主节点各种资源被严重占用，其中包括但不限于缓冲区，宽带，连接等。<br>为什么会出现主节点资源被严重占用？<br>在心跳机制中，从节点每秒会发送一个指令replconf ack指令到主节点。<br>从节点执行了慢查询，占用大量的cpu<br>主节点每秒调用复制定时函数replicationCron，然后从节点长时间没有相应。</p>
<p><strong>解决方案</strong>：<br>设置从节点超时释放<br><strong>设置参数</strong>：repl-timeout<br>这个参数默认为60秒。超过60秒，释放slave。</p>
<h3 id="数据不一致问题"><a href="#数据不一致问题" class="headerlink" title="数据不一致问题"></a>数据不一致问题</h3><p>由于网络因素，多个从节点的数据会不一致。这个因素是没有办法避免的。<br>关于这个问题给出俩个解决方案：<br>第一个数据需要高度一致配置一台redis服务器，读写都用一台服务器，这种方式仅限于少量数据，并且数据需高度一直。<br>第二个监控主从节点的偏移量，如果从节点的延迟过大，暂时屏蔽客户端对该从节点的访问。<br>设置参数为slave-serve-stale-data  yes|no。这个参数一但设置就只能响应info slaveof等少数命令。</p>
<h3 id="从节点故障"><a href="#从节点故障" class="headerlink" title="从节点故障"></a>从节点故障</h3><p>这个问题直接在客户端维护一个可用节点列表，当从节点故障时，切换到其他节点进行工作，这个问题在后边集群会说到。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要讲解了什么是主从复制、主从复制工作的三大阶段以及工作流程、部分复制的三大核心。<br>命令传播阶段的心跳机制。最后说明了主从复制常见问题。<br>耗时俩天写的文章，这也是咔咔最近耗时最长的一篇文章，以后咔咔发的文章估计都是这样的，不会在把一问题单独出多篇文章来讲解，会一篇文章全部说完。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1>]]></content>
      <tags>
        <tag>面试题</tag>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
